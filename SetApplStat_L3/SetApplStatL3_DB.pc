/* $Header: $ */
/****************************************************************************/
/* Filename    : set_appl_stat_L3.pc										*/
/* Author      : Bakul Waghmare, Brijesh Patil								*/
/* Description : This file contains the database access functions for the	*/
/*				 service SET_APPL_STAT_L3.									*/
/****************************************************************************/

/* Include files	*/

#include<stdio.h>
#include<string.h>
#include <stdlib.h>
#define SQLCA_STORAGE_CLASS extern
#include <sqlca.h>

#include "gscbdef.h"
#include "gscbio.h"
#include "gscblog.h"
#include "gscblookupdef.h"
#include "KPPdef.h"
#include "KPPstruct.h"
#include "KPPproto.h"
#include "set_appl_stat_L3_io.h"
#include "set_appl_stat_L3.h"

#include "Jpj_upd_Sp_Caller_io.h"
#include "jpn_update_io.h"
#include "jpj_update_io.h"
#include "imm_update_io.h"
#include "pdrm_update_io.h"

//--uncomment all the headers below before compiling dll.
//#include "AfisUpdate_IO.h"


//#import  "JpnUpdate.tlb" no_namespace
//#import  "ImmUpdate.tlb" no_namespace
//#import  "JpjUpdate.tlb" no_namespace
//#import  "PDRMUpdate.tlb" no_namespace
//#import  "JpjUpdSpCaller.tlb" no_namespace


//#import  "AfisUpdate.tlb" no_namespace 

//--uncomment all the headers below before compiling dll.

extern "C" PROG_ACCESS_LOG_T prog_log;
extern "C" APPL_EXCEP_LOG_T excep_log;
extern "C" TXN_LOG_T tran_log;
READ_REG_GENERIC_T gen_reg;



char sqlmsg[SQL_MSG_SIZE];
char afis_call_flag = 'N';

extern "C" void userlog(char *szFormatString,...);

int Set_Appl_Stat_L3(SET_APPL_STAT_L3_REQ_T *pReq, 
		  SET_APPL_STAT_L3_RESP_T **pResp, long *pRespSize,void * ctx)
{


	SET_APPL_STAT_L3_REQ_T *req, *temp;
	SET_APPL_STAT_L3_RESP_T *resp;
	PROB_RESULT_T *problem, *temp_prob;
	NAME_ADDRESS_T *name_add, *temp_name;

	JPN_INFO_T *jpn,*temp_jpn;  //added on 24th MAR 2005 for IJPN 

	char *appnt_img = NULL;
	char curr_date_time[DATE_TIME_SIZE];
	int ret = 0;
	char program_id[PROG_ID_SIZE];
	//char type[9];
	//char subtype[17];
	long len = 0;
	char status;
	int disputed_flag = 0;
	char termination_flag = 'N';
	int jpj_flag = 0;
	char old_kptno[KPT_SIZE];

	int name_address_flag_cnt = 0;
	int jpn_info_rec_ind_cnt = 0;
    int counter = 0;
	int appl_stat_flag = 0;
	int dlkp_flag = 0; //Added by Salmi 
	memset(&prog_log, 0, PROG_LOG_SIZE);
	memset(&excep_log, 0, APPL_EXCEP_LOG_SIZE);
	
	/* Initialize the variables used for logging	*/
	/* Get current date-time for logging			*/
	strcpy(curr_date_time, get_date_time());

	userlog("Before Request copy");
	
	/* Assign request buffer	*/
	req = (SET_APPL_STAT_L3_REQ_T *) pReq;

	FILE *fptr=NULL;
	fptr = fopen("d:\\ijpn\\log\\sareq.txt","wb");
	fwrite(req, 2800,1,fptr);

	fclose(fptr);

		#ifdef DEBUG
			userlog(" ");
			userlog("SET_APPL_STAT_L3 : Version 3.48");
			userlog("SET_APPL_STAT_L3 : req->header.application_id:%s:",req->header.application_id);
			userlog("SET_APPL_STAT_L3 : req->header.branch_code:%s:", req->header.branch_code);
			userlog("SET_APPL_STAT_L3 : req->header.service_id:%d:", req->header.service_id);
			userlog("SET_APPL_STAT_L3 : req->header.user_id:%s:", req->header.user_id);
			userlog("SET_APPL_STAT_L3 : req->header.workstation_id:%s:", req->header.workstation_id);
			userlog("SET_APPL_STAT_L3 : req->kptno:%s:", req->kptno);
			userlog("SET_APPL_STAT_L3 : req->action_flag:%c:", req->action_flag);
			userlog("SET_APPL_STAT_L3 : req->prob_no:%d:", req->prob_no);
			userlog("SET_APPL_STAT_L3 : req->cancode_colldate:%s:", req->cancode_colldate);
			userlog("SET_APPL_STAT_L3 : req->gqd_branch_code:%s:", req->gqd_branch_code);
			userlog("SET_APPL_STAT_L3 : req->name_address_flag:%c:", req->name_address_flag);
			userlog("SET_APPL_STAT_L3 : req->reprint_flag:%c:", req->reprint_flag);
			userlog("SET_APPL_STAT_L3 : req-> collection_center:%s:", req->collection_center);
			userlog("SET_APPL_STAT_L3 : req->appl_remarks:%s:", req->appl_remarks);
			userlog("SET_APPL_STAT_L3 : req->appl_cancel_code:%s:", req->appl_cancel_code);
			userlog("SET_APPL_STAT_L3 : req->cancel_date:%s:", req->cancel_date);
		
			userlog("SET_APPL_STAT_L3 : req->szPermitIssueDate:%s:", req->szPermitIssueDate);
			userlog("SET_APPL_STAT_L3 : req->szImmRefDate:%s:", req->szImmRefDate);
			userlog("SET_APPL_STAT_L3 : req->szImmRefNo:%s:", req->szImmRefNo);
			userlog("SET_APPL_STAT_L3 : req->szPassportNo:%s:", req->szPassportNo);
			userlog("SET_APPL_STAT_L3 : req->szPassportIssueCountry:%s:", req->szPassportIssueCountry);
			userlog("SET_APPL_STAT_L3 : req->nPrDocType:%d", req->nPrDocType);
			userlog("SET_APPL_STAT_L3 : req->szImmCitizenship: %s", req->szImmCitizenship);
	
			// new fields
			userlog(" ");
			userlog("SET_APPL_STAT_L3 : req->szPermitNo:%s:", req->szPermitNo);
			userlog("SET_APPL_STAT_L3 : req->szPermittype:%d:", req->szPermittype);
			userlog("SET_APPL_STAT_L3 : req->szCurrLongName:%s:", req->szCurrLongName);
			userlog(" ");
			//end

			userlog("SET_APPL_STAT_L3 : req->aprvldocno:%s:", req->aprvldocno);
			userlog("SET_APPL_STAT_L3 : req->lr_photo_size:%ld:", req->lr_photo_size);
			userlog("SET_APPL_STAT_L3 : req->hr_photo_size:%ld:", req->hr_photo_size);
			userlog("SET_APPL_STAT_L3 : req->jpn_info_rec_ind:%c:", req->jpn_info_rec_ind);
			userlog("SET_APPL_STAT_L3 : req->refbranchcode:%s:", req->refbranchcode);
			userlog("SET_APPL_STAT_L3 : req->newapplstat:%c:", req->newapplstat);
			userlog("SET_APPL_STAT_L3 : req->apprv_status:%d:", req->apprv_status);
			userlog("SET_APPL_STAT_L3 : req->operId :%s:", req->operId);
			userlog("SET_APPL_STAT_L3 : req->status:%c:", req->status);
			userlog("SET_APPL_STAT_L3 : req->intvDateTime:%s:", req->intvDateTime);
			userlog("SET_APPL_STAT_L3 : req->remark:%s:", req->remark);
			userlog("SET_APPL_STAT_L3 : req->apprvBranch :%s:", req->apprvBranch);
			userlog("SET_APPL_STAT_L3 : req->dateTimeStamp :%s:", req->dateTimeStamp);
			userlog("SET_APPL_STAT_L3 : req->szRejectdate :%s:", req->szRejectdate);
			userlog("SET_APPL_STAT_L3 : req->szAppealdate :%s:", req->szAppealdate);
			userlog("SET_APPL_STAT_L3 : req->userKptno :%s:", req->userKptno);
			userlog(" ");
		#endif


	userlog("After Request copy");
	temp = req;
	//temp++;

	problem = (PROB_RESULT_T *)(req + 1);  //salmi add
	temp_prob = problem;

	userlog("problem->problem_number :%d:",problem->problem_number);
	userlog("problem->prob_stat :%c:",problem->prob_stat);
	userlog("problem->transaction_code :%s:",problem->transaction_code);
	userlog("problem->note :%s:",problem->note);
	userlog("problem->bskrecd :%c:",problem->bskrecd);
	//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020
	userlog("problem->gUser1 :%s:", problem->gUser1);
	userlog("problem->gUser1TimeStamp :%s:", problem->gUser1TimeStamp);
	userlog("problem->gUser2 :%s:", problem->gUser2);
	userlog("problem->gUser2TimeStamp :%s:", problem->gUser2TimeStamp);
	//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020-End
	for(counter = 0;counter < req->prob_no; counter++,problem++);
	
	
	userlog("After PROB_RESULT_T ");
	
	//problem = problem + req->prob_no;
	userlog("After PROB_RESULT_T ");

   /* This code is added for IJPN */
	if(req->name_address_flag == 'Y')
		name_address_flag_cnt = 1;

	if(req->jpn_info_rec_ind == 'Y')
		jpn_info_rec_ind_cnt = 1;

	name_add = (NAME_ADDRESS_T *)problem;
	//name_add = (NAME_ADDRESS_T *)apprv_htr; //Change from problem to apprv_htr
	temp_name = name_add;


	userlog("NAME ADDRESS ");
	userlog("currlongname :%s:",name_add->currlongname);
	userlog("gmpcshortname1 :%s:",name_add->gmpcshortname1);
	userlog("gmpcshortname2 :%s:",name_add->gmpcshortname2);
	userlog("gmpcshortname3 :%s:",name_add->gmpcshortname3);
	userlog("currshortname1 :%s:",name_add->currshortname1);
	userlog("currshortname2 :%s:",name_add->currshortname2);
	userlog("address1 :%s:",name_add->address.address1);
	userlog("address2 :%s:",name_add->address.address2);
	userlog("address3 :%s:",name_add->address.address3);
	userlog("post_code :%s:",name_add->address.post_code);
	userlog("state_code :%s:",name_add->address.state_code);
	userlog("city_code :%d:",name_add->address.city_code);

    // for(counter=0;counter<name_address_flag_cnt;counter++,name_add++);

	 //jpn = (JPN_INFO_T *)(name_add + name_address_flag_cnt);
	
	jpn = (JPN_INFO_T *)(name_add+1);
	
	temp_jpn = jpn;
    
	for(counter=0;counter<jpn_info_rec_ind_cnt;counter++,jpn++)
    {
	#ifdef DEBUG
			userlog("insert_into_jpn_info : Input buffer data");
			userlog("insert_into_jpn_info :jpn->kptno %s",jpn->kptno);
			userlog("insert_into_jpn_info :jpn->birthdistrictcode %d",jpn->birthdistrictcode);
			userlog("insert_into_jpn_info :jpn->policeid %s",jpn->policeid);
			userlog("insert_into_jpn_info :jpn->militaryid %s",jpn->militaryid);
			userlog("insert_into_jpn_info :jpn->kppno %s",jpn->kppno);
			userlog("insert_into_jpn_info :jpn->gender %c",jpn->gender);
			userlog("insert_into_jpn_info :jpn->personstatcode %c",jpn->personstatcode);
			userlog("insert_into_jpn_info :jpn->birthdate %s",jpn->birthdate);
			userlog("insert_into_jpn_info :jpn->unknownbirthind %c",jpn->unknownbirthind);
			userlog("insert_into_jpn_info :jpn->religioncode %c",jpn->religioncode);
			userlog("insert_into_jpn_info :jpn->racecode %s",jpn->racecode);
			userlog("insert_into_jpn_info :jpn->residentstat %c",jpn->residentstat);
			userlog("insert_into_jpn_info :jpn->citizenshipstatcode %c",jpn->citizenshipstatcode);
			userlog("insert_into_jpn_info :jpn->colourarticlecode %s",jpn->colourarticlecode);
			userlog("insert_into_jpn_info :jpn->hkind %c",jpn->hkind);
			userlog("insert_into_jpn_info :jpn->iccolorcode %c",jpn->iccolorcode);
			userlog("insert_into_jpn_info :jpn->origname %s",jpn->origname);
			userlog("insert_into_jpn_info :jpn->currlongname %s",jpn->currlongname);
			userlog("insert_into_jpn_info :jpn->currshortname1 %s",jpn->currshortname1);
			userlog("insert_into_jpn_info :jpn->currshortname2 %s",jpn->currshortname2);
			userlog("insert_into_jpn_info :jpn->gmpcshortname1 %s",jpn->gmpcshortname1);
			userlog("insert_into_jpn_info :jpn->gmpcshortname2 %s",jpn->gmpcshortname2);
			userlog("insert_into_jpn_info :jpn->gmpcshortname3 %s",jpn->gmpcshortname3);
			userlog("insert_into_jpn_info :jpn->address1 %s",jpn->address1);
			userlog("insert_into_jpn_info :jpn->address2 %s",jpn->address2);
			userlog("insert_into_jpn_info :jpn->address3 %s",jpn->address3);
			userlog("insert_into_jpn_info :jpn->postcode %s",jpn->postcode);
			userlog("insert_into_jpn_info :jpn->citycode %d",jpn->citycode);
			userlog("insert_into_jpn_info :jpn->statecode %s",jpn->statecode);
			userlog("insert_into_jpn_info :jpn->ktindcode %s",jpn->ktindcode);
			userlog("insert_into_jpn_info :jpn->jpnremarks1 %s",jpn->jpnremarks1);
			userlog("insert_into_jpn_info :jpn->jpnremarks2 %s",jpn->jpnremarks2);
			userlog("insert_into_jpn_info :jpn->afisflag %c",jpn->afisflag);
			userlog("insert_into_jpn_info :jpn->cardlostcnt %d",jpn->cardlostcnt);
			userlog("insert_into_jpn_info :jpn->kptapplstat %c",jpn->kptapplstat);
			userlog("insert_into_jpn_info :jpn->kptappldate %s",jpn->kptappldate);
			userlog("insert_into_jpn_info :jpn->kptcollectiondate %s",jpn->kptcollectiondate);
			userlog("insert_into_jpn_info :jpn->kptcollectionplaccode %s",jpn->kptcollectionplaccode);
			userlog("insert_into_jpn_info :jpn->lastaddchangedate %s",jpn->lastaddchangedate);
			userlog("insert_into_jpn_info :jpn->lastcardissuedate %s",jpn->lastcardissuedate);
			userlog("insert_into_jpn_info :jpn->juvenileflag %c",jpn->juvenileflag);
			userlog("insert_into_jpn_info :jpn->cardversionno %d",jpn->cardversionno);
			userlog("insert_into_jpn_info :jpn->birthplace %s",jpn->birthplace);
			userlog("insert_into_jpn_info :jpn->rjind %s",jpn->rjind);
			userlog("insert_into_jpn_info :jpn->birthcertno %s",jpn->birthcertno);
			userlog("insert_into_jpn_info :jpn->kptversionno %d",jpn->kptversionno);
			userlog("insert_into_jpn_info :jpn->polmilitaryjoindate %s",jpn->polmilitaryjoindate);
			userlog("insert_into_jpn_info :jpn->retirementdate %s",jpn->retirementdate);
			userlog("insert_into_jpn_info :jpn->orignameind %c",jpn->orignameind);
			userlog("insert_into_jpn_info :jpn->surrenderdate %s",jpn->surrenderdate);
			userlog("insert_into_jpn_info :jpn->citizennationcode %s",jpn->citizennationcode);
			userlog("insert_into_jpn_info :jpn->applapprovaldate %s",jpn->applapprovaldate);
			userlog("insert_into_jpn_info :jpn->greencardexpdate %s",jpn->greencardexpdate);
			userlog("insert_into_jpn_info :jpn->immrefno %s",jpn->immrefno);
			userlog("insert_into_jpn_info :jpn->immrefdate %s",jpn->immrefdate);
			userlog("insert_into_jpn_info :jpn->immexpdate %s",jpn->immexpdate);
			userlog("insert_into_jpn_info :jpn->passportno %s",jpn->passportno);
			userlog("insert_into_jpn_info :jpn->passportissuedate %s",jpn->passportissuedate);
			userlog("insert_into_jpn_info :jpn->passportissuecountry %s",jpn->passportissuecountry);
			userlog("insert_into_jpn_info :jpn->ucflag %c",jpn->ucflag);
			userlog("insert_into_jpn_info :jpn->permitno %s",jpn->permitno);
			userlog("insert_into_jpn_info :jpn->permitissuedate %s",jpn->permitissuedate);
			userlog("insert_into_jpn_info :jpn->permittype %d",jpn->permittype);
			userlog("insert_into_jpn_info :jpn->prdoctype %d",jpn->prdoctype);
			userlog("insert_into_jpn_info :jpn->rjstartdate %s",jpn->rjstartdate);
			userlog("insert_into_jpn_info :jpn->rjenddate %s",jpn->rjenddate);
			userlog("insert_into_jpn_info :jpn->ktstartdate %s",jpn->ktstartdate);
			userlog("insert_into_jpn_info :jpn->ktenddate %s",jpn->ktenddate);
			userlog("insert_into_jpn_info :jpn->blklstind %c",jpn->blklstind);
			userlog("insert_into_jpn_info :jpn->blklstcode %s",jpn->blklstcode);
			userlog("insert_into_jpn_info :jpn->birthregndate %s",jpn->birthregndate);
			userlog("insert_into_jpn_info :jpn->ktareacode %s",jpn->ktareacode);
			userlog("insert_into_jpn_info :jpn->apjareacode %s",jpn->apjareacode);
		#endif
	}

	appnt_img = (char *)(jpn);
	problem =temp_prob;	
	jpn = temp_jpn;
	name_add = temp_name;
	
	 /* End IJPN */
	
	
	userlog(" After .... appnt_img");
	//problem = temp_prob;

	//	problem = (PROB_RESULT_T *) (req + SET_APPL_STAT_L3_REQ_SIZE);

	userlog(" Before copying variables");
	/* Program access log variable */
	itoa(SET_APPL_STAT_ID, program_id, 10);
	strcpy(prog_log.program_id, program_id);
	strcpy(prog_log.user_id, req->header.user_id);
	strcpy(prog_log.workstation_id, req->header.workstation_id);
	strcpy(prog_log.branch_code, req->header.branch_code);
	strcpy(prog_log.access_start_time, curr_date_time);
	strcpy(prog_log.remarks, "");
	strcpy(prog_log.application_id, req->header.application_id);
	
	/* Application exception log variable */
	strcpy(excep_log.program_id, program_id);
	strcpy(excep_log.user_id, req->header.user_id); 	
	strcpy(excep_log.workstation_id, req->header.workstation_id);
	strcpy(excep_log.branch_code, req->header.branch_code);
	strcpy(excep_log.error_date, curr_date_time);
	strcpy(excep_log.error_msg, "");
	strcpy(excep_log.application_id, req->header.application_id); 	
	excep_log.severity = '\0';	
	excep_log.termination_flag = 'Y';	

	userlog("After copying variables");
	
	/* Allocate response buffer	*/
	
	if(NULL == (resp = (SET_APPL_STAT_L3_RESP_T *) malloc(SET_APPL_STAT_L3_RESP_SIZE)))
	{

	
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Service failed due to RESP_BUF_ERR");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 :Service failed due to RESP_BUF_ERR ");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);

		//tpreturn(TPFAIL, RESP_BUF_ERR, (char *) NULL, 0, 0);
		return RESP_BUF_ERR;
	}

	userlog("After memory allocation!");

	memset(resp, 0, SET_APPL_STAT_L3_RESP_SIZE);

	#ifdef DEBUG

			userlog("SET_APPL_STAT_L3 : req->header.application_id:%s:",req->header.application_id);
			userlog("SET_APPL_STAT_L3 : req->header.branch_code:%s:", req->header.branch_code);
			userlog("SET_APPL_STAT_L3 : req->header.service_id:%d:", req->header.service_id);
			userlog("SET_APPL_STAT_L3 : req->header.user_id:%s:", req->header.user_id);
			userlog("SET_APPL_STAT_L3 : req->header.workstation_id:%s:", req->header.workstation_id);
			userlog("SET_APPL_STAT_L3 : req->kptno:%s:", req->kptno);
			userlog("SET_APPL_STAT_L3 : req->action_flag:%c:", req->action_flag);
			userlog("SET_APPL_STAT_L3 : req->prob_no:%d:", req->prob_no);
			userlog("SET_APPL_STAT_L3 : req->cancode_colldate:%s:", req->cancode_colldate);
			userlog("SET_APPL_STAT_L3 : req->gqd_branch_code:%s:", req->gqd_branch_code);
			userlog("SET_APPL_STAT_L3 : req->name_address_flag:%c:", req->name_address_flag);
			userlog("SET_APPL_STAT_L3 : req->reprint_flag:%c:", req->reprint_flag);
			userlog("SET_APPL_STAT_L3 : req-> collection_center:%s:", req->collection_center);
			userlog("SET_APPL_STAT_L3 : req->appl_remarks:%s:", req->appl_remarks);
			userlog("SET_APPL_STAT_L3 : req->appl_cancel_code:%s:", req->appl_cancel_code);
			userlog("SET_APPL_STAT_L3 : req->cancel_date:%s:", req->cancel_date);
	
	//27 Aug '04. JRS 147
			userlog("SET_APPL_STAT_L3 : Permit Issue Date:%s:", req->szPermitIssueDate);
			userlog("SET_APPL_STAT_L3 : IMM Ref Date:%s:", req->szImmRefDate);
			userlog("SET_APPL_STAT_L3 : IMM Ref No:%s:", req->szImmRefNo);
			userlog("SET_APPL_STAT_L3 : Passport No:%s:", req->szPassportNo);
			userlog("SET_APPL_STAT_L3 : Passport Issued Country:%s:", req->szPassportIssueCountry);
			userlog("SET_APPL_STAT_L3 : PR Doc Type:%d", req->nPrDocType);
			userlog("SET_APPL_STAT_L3 : IMM Citizenship: %s", req->szImmCitizenship);
	//JRS 147
			// new fields
			userlog("SET_APPL_STAT_L3 : req->szPermitNo:%s:", req->szPermitNo);
			userlog("SET_APPL_STAT_L3 : req->szPermittype:%d:", req->szPermittype);
			userlog("SET_APPL_STAT_L3 : req->szCurrLongName:%s:", req->szCurrLongName);			
			//end

			userlog("SET_APPL_STAT_L3 : req->aprvldocno:%s:", req->aprvldocno);
			userlog("SET_APPL_STAT_L3 : req->lr_photo_size:%ld:", req->lr_photo_size);
			userlog("SET_APPL_STAT_L3 : req->hr_photo_size:%ld:", req->hr_photo_size);
			userlog("SET_APPL_STAT_L3 : req->jpn_info_rec_ind:%c:", req->jpn_info_rec_ind);
			
			for(counter = 0;counter < req->prob_no; counter++,problem++)
			{
			
				userlog("SET_APPL_STAT_L3 : problem->problem_number:%d:", problem->problem_number);
				userlog("SET_APPL_STAT_L3 : problem->prob_stat:%c:", problem->prob_stat);
				userlog("SET_APPL_STAT_L3 : problem->transaction_code:%s:", problem->transaction_code);
				//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020
				userlog("SET_APPL_STAT_L3 : problem->gUser1 :%s:", problem->gUser1);
				userlog("SET_APPL_STAT_L3 : problem->gUser1TimeStamp :%s:", problem->gUser1TimeStamp);
				userlog("SET_APPL_STAT_L3 : problem->gUser2 :%s:", problem->gUser2);
				userlog("SET_APPL_STAT_L3 : problem->gUser2TimeStamp :%s:", problem->gUser2TimeStamp);
				//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020

            }

			problem = temp_prob;

			//len = tptypes((char*) req, type, subtype);
			//userlog("SET_APPL_STAT_L3 : req len = %ld", len);

			{
				FILE *fp = NULL;
				char *imgtemp = appnt_img;

				if ((fp = fopen("d:\\ijpn\\log\\Photo4K.jpg", "wb")) != NULL)
				{
					fwrite(imgtemp, req->lr_photo_size, 1, fp);
					fclose(fp);
				
				}

				imgtemp = imgtemp + req->lr_photo_size;

				if ((fp = fopen("Photo12K.jpg", "wb")) != NULL)
				{
					fwrite(imgtemp, req->hr_photo_size, 1, fp);
					fclose(fp);
				
				}

	
			}
		
	#endif

	ret = check_header(req->header,ctx);
	if (ret != SUCCESS)
	{
	#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 : check header failed");
	#endif
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : check header failed");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : check header failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);

		//tpreturn(TPSUCCESS, ret, (char *) NULL, 0, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
	}
	#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :After check header did not fail");
	#endif

	resp->header = req->header;
	#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :After copying header to resp");
	#endif

	/* Validate input data	*/
	if(0 == strcmp(req->header.application_id, ""))
	{

		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Service failed due to DATA_ERROR");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Application ID NULL");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);

		//tpreturn(TPSUCCESS, APP_ID_NULL, (char *) NULL , 0, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return APP_ID_NULL;
	}

	#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :After valid applid");
	#endif

	appl_stat_flag = INITIAL_CHK;
	if(GMPC_GOOD == (ret = check_appl_status(req->header.application_id, appl_stat_flag,ctx)))
	{
		//tpreturn(TPSUCCESS, INVALID_APPL_STAT, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return INVALID_APPL_STAT;
	}

	/* Begin a transaction	*/
	if(GMPC_GOOD != (ret = gscbbegin_trans(ctx)))
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : gscbbegin_trans failed");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : gscbbegin_trans failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);

		//tpreturn(TPSUCCESS, BEGIN_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return BEGIN_TRAN_ERROR;
	}

	/* added this function to update application table with aprvldocno field*/
	// added on 30/11/05
	if((req->aprvldocno[0] != '\0') && (req->aprvldocno[0] != ' '))
	{
		if(GMPC_GOOD != (ret = update_application(req->header.application_id, req->aprvldocno,ctx)))
		{
			//tpreturn(TPSUCCESS, INVALID_APPL_STAT, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return UPDATE_ERROR;
		}
	}

	//Added by Salmi Date:12th May, 2020 Insert into dlewat_apprv_history. CRAPPL-  SKP002/CR/2020
	#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :problem->transaction_code [%s]", problem->transaction_code);
	#endif

	if(GMPC_GOOD != (ret = check_dlkp_trans(req->header.application_id, &dlkp_flag,ctx)))
	{

		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
		//memcpy(*pResp, resp, resp_len);
		*pResp = resp;
		return ret;
	}

	if ((strncmp(problem->transaction_code, "204", 3) == 0) || (strncmp(problem->transaction_code, "205",3) == 0))
		dlkp_flag = 1;  //Missed opex transaction also insert into DLEWAT_APPRV_HISTORY

	#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :dlkp_flag [%d]", dlkp_flag);
	#endif


	if(dlkp_flag == 1)
	{
		#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Inside DLKP flag 1");
		userlog("SET_APPL_STAT_L3 :req->apprvNo [%d]", req->apprvNo);
		#endif

		if(req->apprvNo > 0)
		{
		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :insert_into_dlewat_apprv_history_table");
		#endif
			ret = insert_into_dlewat_apprv_history_table( req->header.application_id, req, ctx );
			if((ret != SUCCESS))
			{
			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Insert into dlewat_apprv_history failed");
			#endif
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Insert into dlewat_apprv_history failed");
				strcpy(excep_log.error_msg,"SET_APPL_STAT_L3 : Insert into dlewat_apprv_history failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);
				return ret;
			} 
		}
	}
	//Added by Salmi Date:12th May, 2020 Insert into dlewat_apprv_history. CRAPPL-  SKP002/CR/2020-End

	//Added by Subramaniam.P on 10th June,2020 Insert into regn_dlewat_table. CRAPPL-  SKP002/CR/2020
	if((req->szRejectdate[0] != '\0') && (req->szRejectdate[0] != ' ') && (req->szAppealdate[0] != '\0') && (req->szAppealdate[0] != ' '))
	{
		if(GMPC_GOOD != (ret = update_regn_dlewat(req->header.application_id, req->szRejectdate, req->szAppealdate,ctx)))
		{
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			*pResp = resp;
				return UPDATE_ERROR;
		}
	}
	//Added by Subramaniam.P on 10th June,2020 Insert into regn_dlewat_table. CRAPPL-  SKP002/CR/2020 -End

	/* Check value of action flag	*/
	switch(req->action_flag)
	{

			// Added this case code here on 04/10/2016 for Release 3.32 and CR 293	
			case BSK_INV:

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before update BSK Investigation");
			#endif

			
			if(GMPC_GOOD != (ret = update_bsk_inv(req->header, req->appl_remarks,ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

			strcpy(prog_log.remarks,"SET_APPL_STAT_L3: BSK Investigation Completed Successfully");

			/* Commit the current transaction	*/
			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

				//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
			}

			log_exit(ctx);

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Service Completed");
			#endif

			//tpreturn(TPSUCCESS, GMPC_GOOD, (char *)resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return GMPC_GOOD;

			// Addition of code 04/10/2016 for Release 3.32 and CR 293 ends here

		case TO_BE_CANCELLED:

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before check_appl_status");
			#endif
			appl_stat_flag = TO_BE_CAN_CHK;
			if(GMPC_GOOD != (ret = check_appl_status(req->header.application_id, appl_stat_flag,ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before change_appl_status");
			#endif
			if(GMPC_GOOD != (ret = change_appl_status(req->header, PENDING_CANCEL, "",ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before update_cancelcode");
			#endif
			if(GMPC_GOOD != (ret = update_cancelcode(req->header.application_id,req->cancode_colldate,ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

			strcpy(prog_log.remarks,"SET_APPL_STAT_L3: Completed Successfully");

			/* Commit the current transaction	*/
			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

				//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
			}

			log_exit(ctx);

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Service Completed");
			#endif

			//tpreturn(TPSUCCESS, GMPC_GOOD, (char *)resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return GMPC_GOOD;


		case RESTORE_PREV_STAT:

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before get_previous_appl_status");
			#endif
			ret = get_previous_appl_status(req->header.application_id, &status,ctx);

			if(ret != SUCCESS)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before change_appl_status");
			#endif
			ret = change_appl_status(req->header, status, "",ctx);

			if(ret != SUCCESS)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}


			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Completed Successfully");
			#endif
			strcpy(prog_log.remarks,"SET_APPL_STAT_L3: Completed Successfully");


			/* Commit the current transaction	*/
			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

				//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
			}

			log_exit(ctx);
			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Service Completed");
			#endif

			//tpreturn(TPSUCCESS, GMPC_GOOD, (char *)resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return GMPC_GOOD;



		/* The application has been terminated	*/
		case TERMINATE:

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before close_problems");
			#endif
			if((GMPC_GOOD != (ret = update_appl_remarks(req->header.application_id, TERMINATED_GSC, req->appl_remarks, req->appl_cancel_code, req->cancel_date,ctx))))
			{
				//tpreturn(TPSUCCESS, ret, (char *)resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}
			
			if(GMPC_GOOD != (ret = close_problems(req->header.application_id, problem, req->prob_no, req->header.user_id,ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After close_problems");
			#endif

			if(GMPC_GOOD != (ret = change_appl_status(req->header, 
			  TERMINATED_GSC, "",ctx)))
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After change_appl_status");
			#endif

			//if(dlkp_flag != 1)//Added by Salmi Date:28th Jul, 2020 Exclude DLKP Trans CRAPPL-  SKP002/CR/2020-End
			if (dlkp_flag != 1 || req->action_flag == 'T') //added by samsuri on 01 mar 2022 SKP005/PM/2021
			{
				userlog("SET_APPL_STAT_L3 :SKP005/PM/2021 before delete_card_status");

				if(GMPC_GOOD != (ret = delete_card_status(req->header.application_id,ctx)))
				{
					sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function delete_card_status failed");
					excep_log.termination_flag = NO;
					excep_log.severity = NON_FATAL;
					log_error(ctx);
				}
			}

			/* Commit the current transaction	*/
			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

				//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
			}

			/* Commented out on 20/6/2001, until HTP is ready for termination messages */
			
			termination_flag = 'Y';
			// Fire updates to legacy
			if(GMPC_GOOD != (ret = send_legacy_updates(req->header, termination_flag, NULL, req->lr_photo_size, req->hr_photo_size, req->name_address_flag, ctx)))
			{
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function send_legacy_updates failed");
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After send_legacy_updates");
			#endif
			

			strcpy(prog_log.remarks,"SET_APPL_STAT_L3: Completed Successfully");

			log_exit(ctx);


			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Service Completed");
			#endif

			//tpreturn(TPSUCCESS, GMPC_GOOD, (char *)resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return GMPC_GOOD;

		/* The application has been referred to GQD	*/
		case REFER_GQD:

			ret = change_appl_status_gqdssc(req->header, REFFERED_GQD, req->gqd_branch_code,problem,req->prob_no,ctx);
			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After change_appl_status again");
			#endif
			if(ret != GMPC_GOOD)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}

			break;

		/* Do nothing	*/
		default:
			;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Before close_problems -Action flag-> %c",req->action_flag);
	#endif

	/* Set problem status to closed for all	*/
	/* problems which have been resolved	*/
//	close_problems(req->header.application_id, problem, req->prob_no);
	if(GMPC_GOOD != (ret = close_problems(req->header.application_id, problem, req->prob_no, req->header.user_id,ctx)))
	{
		//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
		//memcpy(*pResp, resp, resp_len);
		*pResp = resp;
		return ret;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After close_problems");
	#endif

	if((0 != req->cancode_colldate[CANCEL_CODE_SIZE - 1]) || (0 != req->collection_center[0]))
	{
		if(GMPC_GOOD != (ret = set_collection_date(req->header.application_id,
		  req->cancode_colldate, req->collection_center,ctx)))
		{
			//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
		}
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After set_collection_date");
	#endif

	/* If the application is referred to GQD then commit and return	*/
	if(REFER_GQD == req->action_flag)
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3: Completed Successfully");
		prog_access_log(ctx);

		/* Commit the current transaction	*/
		if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
		{
			userlog("SET_APPL_STAT_L3: gscbcommit_trans failed\n");
			//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
		}

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :Service Completed");
		#endif

		//tpreturn(TPSUCCESS, GMPC_GOOD, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return GMPC_GOOD;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Before set_collection_date");
	#endif


/*Brijesh - This part added here after discussion with Azlinda and approval from SAM 
	on 21 Jan 2002 */

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :calling check_disputed_data");
	#endif

	if(GMPC_GOOD != (ret = check_disputed_data(req->header.application_id, &disputed_flag,ctx)))
	{
		//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :after calling check_disputed_data value for disputed_flag %d", disputed_flag);
	#endif

	disputed_flag = 1;	//Added by Amarjith on 6th Aug '04 to update from JPN_INFO to APPNT_JPN_INFO for all records.
	
	if(disputed_flag == 1)
	{
		/* added on 25th Mar 2005 for IJPN */
		/* insert latest data into jpn_info */
		if(req->jpn_info_rec_ind == 'Y')
		{
			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Calling insert_into_jpn_info()");
			#endif

			if(GMPC_GOOD != (ret = insert_into_jpn_info(jpn,ctx)))

			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}
			userlog("SET_APPL_STAT_L3 :After calling insert_into_jpn_info()");

			/* Commit	*/
			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed at insert_into_jpn_info()");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed at insert_into_jpn_info()");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

				//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return END_TRAN_ERROR;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 : insert_into_jpn_info, commit successful()");
			#endif
		}

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :Before get_fresh_jpn_data");
		#endif
		
		if(req->name_address_flag == 'Y')
		{

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :Before checking GMPC names and address");
			#endif
			if((strlen(name_add->currlongname) < 2) || (strlen(name_add->gmpcshortname1) < 2) ||
				(strlen(name_add->address.address1) == 0))
			{
				strcpy(prog_log.remarks, "SET_APPL_STAT_L3 : Problem with Currlongname/GMPC shortname1/Adress1");
				sprintf(excep_log.error_msg, "SET_APPL_STAT_L3 : Problem with Currlongname/GMPC shortname1/Adress1");
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				//tpreturn(TPSUCCESS, GMPC_NAME1_NULL, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return GMPC_NAME1_NULL;
			}

			#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After checking GMPC names and address");
			#endif

			/* Update the data in disputed data tables to APPNT tables	*/

			userlog("SET_APPL_STAT_L3 :Calling put_approved_data() for addup='Y'");

			if(GMPC_GOOD != (ret = put_approved_data(req, name_add, temp_prob->transaction_code,ctx	)))	///JRS 147.
//			if(GMPC_GOOD != (ret = put_approved_data(req, name_add, req->kptno)))	///Comment for JRS 147
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

		}
		else if(req->name_address_flag == 'N')
		{
			userlog("SET_APPL_STAT_L3 :Calling put_approved_data() for addup='N'");

			/* Update the data in disputed data tables to APPNT tables	*/
			if(GMPC_GOOD != (ret = put_approved_data(req, NULL, temp_prob->transaction_code,ctx)))	///JRS 147.
//			if(GMPC_GOOD != (ret = put_approved_data(req, NULL, req->kptno)))	///Comment for JRS 147
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
			}

		}

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :After put_approved_data");
		#endif

		/* No need for this as this is done from the front - end */
		/* Get fresh legacy data	*/
/*		if(GMPC_GOOD != (ret = get_fresh_jpn_data(req->header)))
		{
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			log_error(ctx);

			tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		}
*/
	}


	/* If all problems of a application have been resolved then the status	*/
	/* has to be set accordingly to allow the transaction to proceed.		*/
	/* Ideally at this point all problems  should be resolved				*/
	ret = all_probs_resolved(req->header.application_id,ctx);

	switch(ret)
	{
		userlog("Inside the switch stmt");

		case GMPC_GOOD:
			break;
		case NOT_ALL_PROB_CLOSED:
		/*	if(GMPC_GOOD != (ret = change_appl_status(req->header, REFFERED_GQD, req->gqd_branch_code,ctx)))
			{
				tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			}*/

			/* Commit	*/

			// This code is added on 01/06/2016 for release 3.32 and CR 293
			if(req->newapplstat != '\0')
			{
				#ifdef DEBUG
					userlog("SET_APPL_STAT_L3 :before calling change_bsk_applstatus()");						
				#endif
				if(GMPC_GOOD != (ret = change_bsk_applstatus(req->header, name_add, req->refbranchcode, req->newapplstat, ctx)))
				{
					#ifdef DEBUG
						userlog("SET_APPL_STAT_L3 :change_bsk_applstatus function failed,ret : %d",ret);						
					#endif
					*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;				
					*pResp = resp;
					return ret;
				}

				#ifdef DEBUG
					userlog("SET_APPL_STAT_L3 :change_bsk_applstatus function Successful,ret : %d",ret);						
				#endif

			}

			if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
			{
				strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
				excep_log.termination_flag = 'Y';
				excep_log.severity = FATAL;
				log_error(ctx);

			//	tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return END_TRAN_ERROR;
			}

			//tpreturn(TPSUCCESS, GMPC_GOOD, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			//Added by Salmi, date 11th June 2020, CRAPPL-  SKP002/CR/2020
			/* Fire updates to legacy	*/
			if(GMPC_GOOD != (ret = send_legacy_updates(req->header, termination_flag, name_add, req->lr_photo_size, req->hr_photo_size, req->name_address_flag, ctx)))
			{
				sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function send_legacy_updates failed");
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
			}
			//Added by Salmi, date 11th June 2020, CRAPPL-  SKP002/CR/2020
			return GMPC_GOOD;
		default:
			//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
	}

	userlog("After the switch stmt ");
	
	ret = 0;
	if(req->kptno[0] != '\0')
	{
		userlog("Inside the req->kptno not null ");

	// commented this code to handle multiple records
	//	if(!strcmp(problem->transaction_code, "321") || !strcmp(problem->transaction_code, "421"))

		if(check_kpt_change(req->header.application_id,ctx) == 1)
		{
			userlog("Inside the problem->transaction_code=321or421");

			if((ret = get_kpt_no(req->header.application_id, old_kptno,ctx)) != GMPC_GOOD)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}

			ret = update_appl_table_chg_kpt(req->header.application_id, req->kptno, old_kptno,ctx);

			if(GMPC_GOOD != ret)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}
		}
		else
		{
			ret = update_appl_table(req->header.application_id, req->kptno,ctx);
			if(GMPC_GOOD != ret)
			{
				//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
				*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
				//memcpy(*pResp, resp, resp_len);
				*pResp = resp;
				return ret;
			}
		}


	}
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After update_appl_table");
		userlog("SET_APPL_STAT_L3 :calling check_jpj_data");
	#endif

	if(GMPC_GOOD != (ret = check_jpj_data(req->header.application_id, &jpj_flag,ctx)))
	{
		//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
		//memcpy(*pResp, resp, resp_len);
		*pResp = resp;
		return ret;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :after calling check_jpj_data value for disputed_flag %d", disputed_flag);
	#endif

	if(jpj_flag == 1)
	{
		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :Before put_jpj_data");
		#endif

		/* Update the data in disputed data tables to APPNT tables	*/
		if(GMPC_GOOD != (ret = put_jpj_data(req->header.application_id, req->kptno,ctx)))
		{
			//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
		}

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :After put_jpj_data");
		#endif

	}
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After put_jpj_data");
	#endif

/*#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :calling check_disputed_data");
#endif

	if(GMPC_GOOD != (ret = check_disputed_data(req->header.application_id, &disputed_flag)))
	{
		tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
	}

#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :after calling check_disputed_data value for disputed_flag %d", disputed_flag);
#endif

	if(disputed_flag == 1)
	{
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Before get_fresh_jpn_data");
	#endif

		if(req->name_address_flag == 'Y')
		{
//			 Update the data in disputed data tables to APPNT tables	
			if(GMPC_GOOD != (ret = put_approved_data(req->header.application_id, name_add, req->kptno)))
			{
				tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			}

		}else if(req->name_address_flag == 'N')
		{
//			 Update the data in disputed data tables to APPNT tables	
			if(GMPC_GOOD != (ret = put_approved_data(req->header.application_id, NULL, req->kptno)))
			{
				tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			}

		}
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After put_approved_data");
	#endif
*/
		// No need for this as this is done from the front - end 
		// Get fresh legacy data	
/*		if(GMPC_GOOD != (ret = get_fresh_jpn_data(req->header)))
		{
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			log_error(ctx);

			tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		}
*/
//	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Before set_appl_in_progress");
	#endif

	/* Set application in progress depending on value of afis flag	*/
	if(GMPC_GOOD != (ret = set_appl_in_progress(req->header, req->reprint_flag, problem->transaction_code,ctx)))
	{
		//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
		*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
		//memcpy(*pResp, resp, resp_len);
		*pResp = resp;
		return ret;
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :After set_appl_in_progress");
	#endif

	if (req->lr_photo_size > 0 && req->hr_photo_size > 0)
	{
		/* Put the images */
		if(GMPC_GOOD != (ret = put_appnt_images(req, appnt_img,ctx)))
		{
			//tpreturn(TPSUCCESS, ret, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
			//memcpy(*pResp, resp, resp_len);
			*pResp = resp;
			return ret;
		}

		#ifdef DEBUG
				userlog("SET_APPL_STAT_L3 :After put_appnt_images");
		#endif
	}

	// This function included on 22/09/2011 to update applicant data before calling legacy updates
	// for Release 3.22
	
	if(GMPC_GOOD != (ret = upd_legacy_appl_data(req->header, req->kptno, ctx)))
	{
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function upd_legacy_appl_data failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);
	}

	/* Commit	*/
	if(GMPC_GOOD != (ret = gscbcommit_trans(ctx)))
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function gscbcommit_trans failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);

		//tpreturn(TPSUCCESS, END_TRAN_ERROR, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
			*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
		//memcpy(*pResp, resp, resp_len);
		*pResp = resp;
		return END_TRAN_ERROR;
	}

	termination_flag = 'N';

	#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :Before send_legacy_updates");
	#endif
	/* Fire updates to legacy	*/
	if(GMPC_GOOD != (ret = send_legacy_updates(req->header, termination_flag, name_add, req->lr_photo_size, req->hr_photo_size, req->name_address_flag, ctx)))
	{
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Function send_legacy_updates failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);
	}


	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 :Service Completed");
	#endif

	strcpy(prog_log.remarks,"SET_APPL_STAT_L3: Completed Successfully");
	log_exit(ctx);

	//tpreturn(TPSUCCESS, GMPC_GOOD, (char *) resp, SET_APPL_STAT_L3_RESP_SIZE, 0);
	*pRespSize = SET_APPL_STAT_L3_RESP_SIZE;
	//memcpy(*pResp, resp, resp_len);
	*pResp = resp;
	return GMPC_GOOD;

}

// Added this function for Release 3.22
/****************************************************************************/
/* Function name: upd_legacy_appl_data										*/
/* Description	: This function updates the appropriate data before lagacy 	*/
/*				  updates                  										*/
/* Input		: None														*/
/* Return values: GMPC_GOOD, 												*/
/* Limitations	:															*/
/****************************************************************************/
int upd_legacy_appl_data(HEADER_T t_header, char *kptno1, void * ctx)
{

	EXEC SQL BEGIN DECLARE SECTION;

	int reccnt1 = 0;
	char lapplid[APP_ID_SIZE];
	char kpt_no[KPT_SIZE];

	sql_context pcCtx;
	EXEC SQL END DECLARE SECTION;

	pcCtx = ctx; 
	EXEC SQL CONTEXT USE :pcCtx;



	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3: ------------------------");
		userlog("SET_APPL_STAT_L3: input to function kptno1 :%s",kptno1);		
	#endif

	kpt_no[0] = '\0';
	strcpy(kpt_no,kptno1);
	strcpy(lapplid,t_header.application_id);
	
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3: after copy kpt_no :%s",kpt_no);
		userlog("SET_APPL_STAT_L3: after copy applid :%s",lapplid);
	#endif

	// Added this on 06/09/2011, 
	userlog("SET_APPL_STAT_L3: send_legacy_updates 06/09/2011");
	//strcpy(applid,t_header.application_id);
	
	//EXEC SQL SELECT COUNT(*) INTO :reccnt1 FROM APPL_TXN WHERE APPLID = :applid AND TXNCODE = '426';

	EXEC SQL SELECT COUNT(*) INTO :reccnt1 FROM APPL_TXN
				WHERE APPLID = :lapplid
				 AND TXNCODE IN ('426');				 

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3: cnt1 sqlcode :%d",sqlca.sqlcode);
		userlog("SET_APPL_STAT_L3: cnt1  :%d",reccnt1);
	#endif

	if(reccnt1 > 0)
	{
		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: Inside the cnt1 > 0 loop");			
		#endif

		EXEC SQL DELETE FROM APPNT_LIC_INFO WHERE APPLID = :lapplid;

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: delete appnt_lic_info sqlcode :%d",sqlca.sqlcode);			
		#endif

		EXEC SQL DELETE FROM APPNT_JPJ_INFO WHERE APPLID = :lapplid;

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: delete appnt_jpj_info sqlcode :%d",sqlca.sqlcode);			
		#endif

		EXEC SQL DELETE FROM APPNT_IMM_INFO WHERE APPLID = :lapplid;

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: delete appnt_imm_info sqlcode :%d",sqlca.sqlcode);			
		#endif

		EXEC SQL DELETE FROM APPNT_PP_INFO WHERE APPLID = :lapplid;

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: delete appnt_pp_info sqlcode :%d",sqlca.sqlcode);			
		#endif


		EXEC SQL UPDATE CARD_STATUS SET KPTNO = :kpt_no, AGENCYONCHIP = '01000000' WHERE APPLID = :lapplid;
		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: update card_status sqlcode :%d",sqlca.sqlcode);			
		#endif

		EXEC SQL UPDATE APPLICATION SET KPTNO = :kpt_no WHERE APPLID = :lapplid;

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: update application sqlcode :%d",sqlca.sqlcode);			
		#endif

		EXEC SQL UPDATE APPNT_JPN_IMG SET KPTNO = :kpt_no WHERE APPLID = :lapplid;

		EXEC SQL UPDATE APPNT_JPN_INFO SET KPTNO = :kpt_no,KPPNO=NULL,
			RJIND=NULL,KTINDCODE=NULL,RESTRICRESIDCODE=NULL,
			IDTYPE=NULL,IDNO=NULL,INVSERVICEFLAG=NULL,
			ORIGNAME = CURRLONGNAME  // Added this on 31/03/2015 for special branch cards
			WHERE APPLID = :lapplid;
		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: update appnt_jpn_info sqlcode :%d",sqlca.sqlcode);
			userlog("SET_APPL_STAT_L3: ------------------------------");
		#endif

	}

	return GMPC_GOOD;

}


/****************************************************************************/
/* Function name: send_legacy_updates										*/
/* Description	: This function sends the appropriate update messages to 	*/
/*				  the legacy systems.										*/
/* Input		: None														*/
/* Return values: GMPC_GOOD, 												*/
/* Limitations	:															*/
/****************************************************************************/
int send_legacy_updates(HEADER_T t_header, char termination_flag, NAME_ADDRESS_T *name_add, long lr_photo_size, long hr_photo_size, char name_address_flag, void * ctx)
{

	int ret_val = 0;
	char kptno[KPT_SIZE];
	char flag = '\0';
	int applstat_flag = 0;
	int name_change_flag = 0;
	int addr_change_flag = 0;
	int images_flag = 0;
	int jpj_info_flag = 0;
	char ownername_flag = NO;
	char owneridcat_flag = NO;
	int ret_code = 0;
	int reqtype = 0;
	
    ret_val = 0;
	if((ret_val = get_kpt_no(t_header.application_id, kptno,ctx)) != GMPC_GOOD)
	{
		return ret_val;
	}

	ret_val = 0;
	if((ret_val = check_jpj_info(kptno, t_header.application_id, &jpj_info_flag,ctx)) != GMPC_GOOD)
	{
		return ret_val;
	}

	if (termination_flag != 'Y')
	{
		if((ret_val = check_appl_card_status(t_header, kptno, &applstat_flag, &name_change_flag, &addr_change_flag, &images_flag, name_add, lr_photo_size, hr_photo_size,ctx)) != GMPC_GOOD)
		{
			return ret_val;
		}

		#ifdef DEBUG
				userlog("send_legacy_updates :After check_appl_card_status(applstat_flag) : %d",applstat_flag);
				userlog("send_legacy_updates :After check_appl_card_status(name_change_flag) : %d",name_change_flag);
		#endif

		if(name_address_flag == 'N')
		{
			int name_change_flag = 0;
			int addr_change_flag = 0;
		}

		if(applstat_flag == NO_UPDATE)
		{

			return GMPC_GOOD;
		}

		if(applstat_flag == SELECTIVE_UPDATES)
		{

			if((name_change_flag) || (images_flag) || (addr_change_flag))
			{
				ret_val = update_legacy_request(&t_header, 'D', '1', -1,ctx);

				if((ret_val != GMPC_GOOD) && (ret_val != NO_DATA1))
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: update_legacy_request() failed");
					#endif
					return ret_val;
				}

				if(ret_val == NO_DATA1)
				{
					if((ret_val = insert_into_legacy_request('D', &t_header, '1', -1, 1,ctx)) != GMPC_GOOD)
					{
						#ifdef DEBUG
								userlog("SET_APPL_STAT_L3: insert_into_legacy_request() failed");
						#endif
						return ret_val;
					}
				}

				if((ret_val = call_jpn_update(&t_header, 'M', ctx)) != GMPC_GOOD)
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: call_jpn_update() failed");
					#endif
			//		return ret_val;
				}
			}

			/*
			if((name_change_flag) && (jpj_info_flag))
			{
				ret_val = update_legacy_request(&t_header, 'M', '3', -1,ctx);

				if((ret_val != GMPC_GOOD) && (ret_val != NO_DATA1))
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: update_legacy_request() failed");
					#endif
					return ret_val;
				}

				if(ret_val == NO_DATA1)
				{
					if((ret_val = insert_into_legacy_request('M', &t_header, '3', -1, 0,ctx)) != GMPC_GOOD)
					{
						#ifdef DEBUG
								userlog("SET_APPL_STAT_L3: insert_into_legacy_request() failed");
						#endif
						return ret_val;
					}
				}

				if((ret_val = call_jpj_update(&t_header,ctx)) != GMPC_GOOD)
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: call_jpj_update() failed");
					#endif
			//		return ret_val;
				}
			}
			*/
			
			/* commented this on 17/04/2015 to enable JAVA web service few lines bellow here
			if((addr_change_flag) && (jpj_info_flag))
			{
				ret_val = update_legacy_request(&t_header, 'A', '3', -1,ctx);

				if((ret_val != GMPC_GOOD) && (ret_val != NO_DATA1))
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: update_legacy_request() failed");
					#endif
					return ret_val;
				}

				if(ret_val == NO_DATA1)
				{
					if((ret_val = insert_into_legacy_request('A', &t_header, '3', -1, 0,ctx)) != GMPC_GOOD)
					{
						#ifdef DEBUG
								userlog("SET_APPL_STAT_L3: insert_into_legacy_request() failed");
						#endif
						return ret_val;
					}
				}

				if((ret_val = call_jpj_update(&t_header,ctx)) != GMPC_GOOD)
				{
					#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: call_jpj_update() failed");
					#endif
			//		return ret_val;
				}

			}
			*/
			return GMPC_GOOD;
		}

		/* commented this on 17/04/2015 to enable JAVA web service few lines bellow here
		if ( (check_kpt_change(t_header.application_id,ctx) == 1) && (jpj_info_flag) )
		{
			ret_val = update_legacy_request(&t_header, 'K', '3', -1,ctx);
			
			if((ret_val != GMPC_GOOD) && (ret_val != NO_DATA1))
			{
#ifdef DEBUG
				userlog("SET_APPL_STAT_L3: update_legacy_request() failed");
#endif
				return ret_val;
			}
			
			if(ret_val == NO_DATA1)
			{
				if((ret_val = insert_into_legacy_request('K', &t_header, '3', -1, 0,ctx)) != GMPC_GOOD)
				{
#ifdef DEBUG
					userlog("SET_APPL_STAT_L3: insert_into_legacy_request() failed");
#endif
					return ret_val;
				}
			}
			/*
			if((ret_val = call_jpj_update(&t_header,ctx)) != GMPC_GOOD)
			{
				#ifdef DEBUG
				userlog("SET_APPL_STAT_L3: call_jpj_update() failed");
				#endif
				//		return ret_val;
			}
			
		}
		*/
	}

	// skip calling the call_jpn_update for dummy kptnos
	if(kptno[0] != 'D')
	{
		#ifdef DEBUG
			/* print input data to be used for debugging */
			userlog("SET_APPL_STAT_L3: Calling call_jpn_update(header, flag)");
		#endif

		/* Call JPN_UPDATE service to update the issuance information 
		   and / or the address to the legacy */
		ret_val = 0;
	//	flag = CARD_UPDATE;

		if((ret_val = call_jpn_update(&t_header, '\0', ctx)) != GMPC_GOOD)
		{
			#ifdef DEBUG
					userlog("SET_APPL_STAT_L3: call_jpn_update() failed");
			#endif
	//		return ret_val;
		}
	}

	/* calling afis update */
	if((termination_flag != 'Y')&&(afis_call_flag == 'Y' ))
	{
		#ifdef DEBUG
		/* print input data to be used for debugging */
			userlog("SET_APPL_STAT_L3: Calling call_afis_update(header, flag)");
		#endif

		if((ret_val = call_afis_update(&t_header, '\0',ctx)) != GMPC_GOOD)
		{
			#ifdef DEBUG
					userlog("SET_APPL_STAT_L3: call_afis_update() failed");
			#endif
			//return ret_val;
		}
	}

	/* Call JPJ_UPDATE service to update the issuance information 
	   and / or the address to the legacy */
	/* commented this on 17/04/2015 to enable JAVA web service few lines bellow here
	if(jpj_info_flag == 1)
	{
		#ifdef DEBUG
		/* print input data to be used for debugging 
			userlog("SET_APPL_STAT_L3: Calling call_jpj_update(header, flag)");
		#endif
		ret_val = 0;
//		flag = 'C';
		if((ret_val = call_jpj_update(&t_header,ctx)) != GMPC_GOOD)
		{
			#ifdef DEBUG
					userlog("SET_APPL_STAT_L3: call_jpj_update() failed");
			#endif
//			return ret_val;
		}
	}
	*/

	if(termination_flag == 'Y')
	{
		return GMPC_GOOD;
	}

	#ifdef DEBUG
		/* print input data to be used for debugging */
		userlog("SET_APPL_STAT_L3: calling check_imm_info");
	#endif

	ret_val = 0;
	if((ret_val = check_imm_info(kptno, t_header.application_id,ctx)) == SELECT_ERROR)
	{
		return ret_val;
	}

	if(ret_val == EXISTS)
	{
		#ifdef DEBUG
			/* print input data to be used for debugging */
			userlog("SET_APPL_STAT_L3: calling call_imm_update");
		#endif

		ret_val = 0;
//		flag = 'C';
		if((ret_val = call_imm_update(&t_header,ctx)) != GMPC_GOOD)
		{
			#ifdef DEBUG
						userlog("SET_APPL_STAT_L3: call_imm_update() failed");
			#endif
//			return ret_val;
		}
	}

	/////////////////////////////////////////////////////
	/* Call JPJ JAVA WEB Service from here, code Added on 17/04/2015    */
	// This function is to update Owner Name
	

	// ******** Update Owner Name ********

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3: Before calling jpj_upd_caller webservice");
	#endif

	ownername_flag = NO;
	ret_code=0;
    ret_code = change_owner_name_flag(t_header.application_id,ctx);

	if(ret_code == 1)
		ownername_flag = YES;


	if (YES == ownername_flag)
	{
		// for owner name update the reqtype = 8
			reqtype = 8;
		if (SUCCESS == (ret_code = insert_into_ijpn_jpj_updreq(&t_header,reqtype,ctx)))
			{
				if (SUCCESS != (ret_code = call_jpj_update(&t_header,reqtype,ctx)))
				{
					#ifdef DEBUG
						userlog("SET_APPL_STAT_L3: call to jpj_upd_caller webservice failed with %d", ret_code);
					#endif
				}
			}
			else
			{
				userlog("SET_APPL_STAT_L3: insert_into_ijpn_jpj_updreq failed!!");
				return ret_code;
			}
	}

	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3: After calling jpj_upd_caller webservice");
	#endif

	// ******** End Update Owner Name ********


	// ******** Start Update Owner Id category ********

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: Before Calling IDCatSub webservice");
		#endif
		owneridcat_flag = NO;
		ret_code=0;
		ret_code = change_owner_idcat_flag(t_header.application_id,ctx);

		if(ret_code == 1)
			owneridcat_flag = YES;


		if (YES == owneridcat_flag)
		{
			// for owneridcat update the reqtype = 7
				reqtype = 7;
			if (SUCCESS == (ret_code = insert_into_ijpn_jpj_updreq(&t_header,reqtype,ctx)))
				{
					if (SUCCESS != (ret_code = call_jpj_update(&t_header,reqtype,ctx)))
					{
						#ifdef DEBUG
							userlog("SET_APPL_STAT_L3: call to jpj_update webservice failed with %d", ret_code);
						#endif
					}
				}
				else
				{
					userlog("SET_APPL_STAT_L3: insert_into_ijpn_jpj_updreq failed!!");
					return ret_code;
				}	

				#ifdef DEBUG
					userlog("SET_APPL_STAT_L3: End of Calling IDCatSub webservice");
				#endif

		}


		// ******** End Owner Id category ********



	///////////////////////////////////////////////////////

	/* Commented on 13/04/2001 as PDRM_UPDATE is already being called by CREATE_APPLNT */
/*		ret_val = 0;
	if((ret_val = check_pdrm_info(kptno, t_header.application_id,ctx)) == SELECT_ERROR)
	{
		return ret_val;
	}

	if(ret_val == EXISTS)
	{
		ret_val = 0;
		flag = 'C';
		if((ret_val = call_pdrm_update(&t_header,ctx)) != GMPC_GOOD)
		{
#ifdef DEBUG
			userlog("SET_APPL_STAT_L3: call_pdrm_update() failed");
#endif
			return ret_val;
		}
	}
*/
	return GMPC_GOOD;
}


// added this on 26/03/2015 for JPJ JAVA changes
int insert_into_ijpn_jpj_updreq(HEADER_T *header, int reqtype, void * ctx)
{
		struct sqlca sqlca = {0};
	EXEC SQL BEGIN DECLARE SECTION;

	char applid[APP_ID_SIZE] = {0};	
	char kptno[KPT_SIZE] = {0};	
	char bcode[9] = {0};
	int  lcount=0;
	int  lcount1=0;	
	int  jreqtype = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;
	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	#ifdef DEBUG
		userlog("insert_into_ijpn_jpj_updreq : header->application_id : %s",header->application_id);
		userlog("insert_into_ijpn_jpj_updreq : header->branch_code : %s",header->branch_code);
		userlog("insert_into_ijpn_jpj_updreq : reqtype : %d",reqtype);		
    #endif

	strcpy(applid, header->application_id);
	strcpy(bcode, header->branch_code);
	jreqtype = reqtype;

	#ifdef DEBUG
		userlog("insert_into_ijpn_jpj_updreq : applid : %s",applid);
		userlog("insert_into_ijpn_jpj_updreq : branch code : %s",bcode);
		userlog("insert_into_ijpn_jpj_updreq : jreqtype : %d",jreqtype);	
    #endif

	lcount=0;
	EXEC SQL SELECT COUNT(*) INTO :lcount FROM IJPN_JPJ_UPD_REQ
		WHERE APPLID = :applid
		AND REQTYPE = :jreqtype;

	#ifdef DEBUG
		userlog("insert_into_ijpn_jpj_updreq : lcount FROM IJPN_JPJ_UPD_REQ: %d",lcount);
    #endif

	if(lcount == 0)
	{
		
		EXEC SQL INSERT INTO IJPN_JPJ_UPD_REQ(APPLID, BRANCHCODE, TXNID, REVTXNID, REQTYPE, REQSTAT, RESPONSECODE, TIMESTAMP)
			VALUES(:applid,:bcode,NULL,NULL,:jreqtype,-1,NULL,SYSDATE);


			if(sqlca.sqlcode == 0)
			{
				#ifdef DEBUG
					userlog("insert_into_ijpn_jpj_updreq : Record inserted into IJPN_JPJ_UPD_REQ ");
				#endif
			}
			else
			{
				#ifdef DEBUG
					userlog("insert_into_ijpn_jpj_updreq : Failed to inserted into IJPN_JPJ_UPD_REQ : %d",sqlca.sqlcode);
				#endif
				return INSERT_ERROR;
			}
	
	}
	else
	{
		#ifdef DEBUG
			userlog("insert_into_ijpn_jpj_updreq : record found in IJPN_JPJ_UPD_REQ for this applid : %s",applid);
		#endif
	}

	EXEC SQL COMMIT;

	return GMPC_GOOD;

}



int change_owner_idcat_flag(char *application_id, void * ctx)
{
	struct sqlca sqlca = {0};
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	int liccount = 0;
	int applcount = 0;
	int applcount1 = 0;
	int retcount = 0;
	int txncount = 0;
	int retirecount = 0;
	int liccount1 = 0;

		sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	/* Populate the variables	*/

	#ifdef DEBUG
		userlog("change_owner_idcat_flag : application_id : %s",application_id);
	#endif

	strcpy(appl_id, application_id);

	#ifdef DEBUG
		userlog("change_owner_idcat_flag : appl_id : %s",appl_id);
	#endif


		EXEC SQL SELECT COUNT(*) INTO :liccount
			FROM APPNT_LIC_INFO 
			WHERE APPLID = :appl_id;

	#ifdef DEBUG
		userlog("change_owner_idcat_flag : record count from APPNT_LIC_INFO : %d",liccount);
	#endif

	if(liccount > 0)
	{
		// Added this on 06/07/2015 to check this condition to proceed further
	
		#ifdef DEBUG
			userlog("change_owner_idcat_flag : Checking whether APPLICATION got LICIDNO info or not to proceed further");
		#endif

		EXEC SQL SELECT COUNT(*) INTO :liccount1
					FROM APPLICATION 
					WHERE APPLID = :appl_id
					AND LICIDNO IS NOT NULL;

		#ifdef DEBUG
			userlog("change_owner_idcat_flag : record count from APPLICATION : %d",liccount1);
		#endif

		if(liccount1 > 0)
		{

			EXEC SQL SELECT COUNT(*) INTO :applcount
				FROM APPL_TXN 
				WHERE APPLID = :appl_id
				AND LEGTXNCODE IN ('3250','4250');

			/*EXEC SQL SELECT COUNT(*) INTO :applcount FROM APPLICATION A , APPL_TXN B
				WHERE A.APPLSTAT NOT IN ('X','Q') AND 
					B.LEGTXNCODE IN ('3250','4250') AND
					A.APPLID = B.APPLID AND
					A.APPLID = :appl_id;*/


			#ifdef DEBUG
				userlog("change_owner_idcat_flag : record count from APPL_TXN applcount: %d",applcount);
			#endif

			if(applcount > 0)
			{
				retcount = 1;
			}
		
			
			EXEC SQL SELECT COUNT(*) INTO :applcount1
				FROM APPL_TXN 
				WHERE APPLID = :appl_id
				AND LEGTXNCODE IN ('3150','4150');

			/*EXEC SQL SELECT COUNT(*) INTO :applcount1 FROM APPLICATION A , APPL_TXN B
				WHERE A.APPLSTAT NOT IN ('X','Q') AND 
					B.LEGTXNCODE IN ('3150','4150') AND
					A.APPLID = B.APPLID AND
					A.APPLID = :appl_id;*/

			#ifdef DEBUG
				userlog("change_owner_idcat_flag : record count from APPL_TXN applcount1: %d",applcount1);
			#endif

			if(applcount1 > 0)
			{
				
					EXEC SQL SELECT COUNT(*) INTO :retirecount
						FROM APPNT_JPN_INFO
						WHERE APPLID = :appl_id
						AND RETIREMENTDATE IS NOT NULL;

					#ifdef DEBUG
						userlog("change_owner_idcat_flag : record count from APPNT_JPN_INFO retirecount: %d",retirecount);
					#endif

					if(retirecount > 0)
						retcount = 1;			
			}
		}
	}
		
		#ifdef DEBUG
			userlog("change_owner_idcat_flag : retcount: %d",retcount);
		#endif


	return retcount;
}


int change_owner_name_flag(char *application_id, void * ctx)
{
	struct sqlca sqlca = {0};
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	int liccount = 0;
	int applcount = 0;
	int applcount1 = 0;
	int retcount = 0;
	int txncount = 0;
	int reccount = 0;
	varchar lowname1[150+1] = {0};
	varchar lowname2[150+1] = {0};
	int liccount1 = 0;

		sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	/* Populate the variables	*/

	#ifdef DEBUG
		userlog("change_owner_name_flag : application_id : %s",application_id);
	#endif

	strcpy(appl_id, application_id);

	#ifdef DEBUG
		userlog("change_owner_name_flag : appl_id : %s",appl_id);
	#endif

		EXEC SQL SELECT COUNT(*) INTO :liccount
			FROM APPNT_LIC_INFO 
			WHERE APPLID = :appl_id;

	#ifdef DEBUG
		userlog("change_owner_name_flag : record count from APPNT_LIC_INFO : %d",liccount);
	#endif

	if(liccount > 0)
	{

		// Added this on 06/07/2015 to check this condition to proceed further
	
		#ifdef DEBUG
			userlog("change_owner_idcat_flag : Checking whether APPLICATION got LICIDNO info or not to proceed further");
		#endif

		EXEC SQL SELECT COUNT(*) INTO :liccount1
					FROM APPLICATION 
					WHERE APPLID = :appl_id
					AND LICIDNO IS NOT NULL;

		#ifdef DEBUG
			userlog("change_owner_name_flag : record count from APPLICATION : %d",liccount1);
		#endif

		if(liccount1 > 0)
		{

			EXEC SQL SELECT COUNT(*) INTO :applcount
				FROM APPL_TXN 
				WHERE APPLID = :appl_id
				AND TXNCODE IN ('306','406');

			#ifdef DEBUG
				userlog("change_owner_name_flag : record count from APPL_TXN applcount: %d",applcount);
			#endif

			if(applcount > 0)
			{
				EXEC SQL SELECT A.OWNERNAME INTO :lowname1
					FROM JPJ_INFO A, APPLICATION B
					WHERE B.APPLID = :appl_id
					AND B.LICIDNO = A.LICIDNO
					AND B.OWNERCAT = A.OWNERCAT;

				lowname1.arr[lowname1.len] = '\0';

				#ifdef DEBUG
					userlog("change_owner_name_flag : OWNERNAME from JPJ_INFO: %s",lowname1.arr);
				#endif
				
				EXEC SQL SELECT CURRLONGNAME INTO :lowname2
					FROM APPNT_JPN_INFO
					WHERE APPLID = :appl_id;

				lowname2.arr[lowname2.len] = '\0';

				#ifdef DEBUG
					userlog("change_owner_name_flag : CURRLONGNAME from APPNT_JPN_INFO : %s",lowname2.arr);
				#endif

				if(strcmp((char *)lowname1.arr,(char *)lowname2.arr) != 0)
				{
					EXEC SQL SELECT COUNT(*) INTO :reccount FROM IJPN_JPJ_UPD_REQ
						WHERE APPLID = :appl_id
						AND REQTYPE = '8';

					if(reccount == 0)
						retcount = 1;
				}						
			}
		}
	}
		
		#ifdef DEBUG
			userlog("change_owner_name_flag : retcount: %d",retcount);
		#endif
	

	return retcount;
}


/*********************************************************************/
/* Function Name:call_jpj_update									 */
/* Description	:This function calls the service JPJ_UPDATE			 */
/* Input		:Header,Applicant ID,update flag and resp buffer	 */   
/* Return Values:  GMPC_GOOD	 */
/*				 which have only header								 */
/* Limitations	:													 */
/*********************************************************************/
int call_jpj_update(HEADER_T *header, int reqtype,void * ctx)
{
	struct sqlca sqlca = {0};
	/*
	int ret;
	JPJ_UPD_CALLER_REQ_T *pstSendBuf;
	
	long ReqLen = 0;
	long RespLen = 0;
	long ret_code = 0;
	int callFlag = 0;
	ReqLen = sizeof(JPJ_UPD_CALLER_REQ_T);
	
	SAFEARRAY *psa;
	SAFEARRAY *psaRsp;
	char flag = UNKNOWN;
	unsigned char *pData = NULL;
	//long lSize;
	//int ret;
	  
	
	
	#ifdef DEBUG
			userlog("call_jpj_update: In call_jpj_update(HEADER header,char flag)");
	#endif

	if((pstSendBuf = (JPJ_UPD_CALLER_REQ_T *)malloc(ReqLen)) == NULL)
	{
		#ifdef DEBUG
			userlog("Memory allocation failed to Send Bufffer");
		#endif
		callFlag = 1;
		
	}
		else
		{
			memset(pstSendBuf, '\0', ReqLen);
			#ifdef DEBUG
				userlog("Memory allocated to Send Buf");
			#endif
			// Copy input data into request buffer 
			strcpy(pstSendBuf->header.user_id, header->user_id);
			strcpy(pstSendBuf->header.workstation_id,header->workstation_id);
			strcpy(pstSendBuf->header.branch_code, header->branch_code);
			strcpy(pstSendBuf->header.application_id, header->application_id);
			//pstSendBuf->jpjreqtype = reqtype;
			sprintf(pstSendBuf->jpjreqtype,"%d",reqtype);
			
		#ifdef DEBUG
			userlog("call_jpj_update : REQUEST DATA FOR JPJ_UPD_CALLER :");
			userlog("call_jpj_update : User Id - %s", pstSendBuf->header.user_id );
			userlog("call_jpj_update : Workstation Id - %s", pstSendBuf->header.workstation_id );
			userlog("call_jpj_update : Gsc No - %s", pstSendBuf->header.branch_code );
			userlog("call_jpj_update : Application Id - %s", pstSendBuf->header.application_id);
			userlog("call_jpj_update : jpjreqtype - %d", pstSendBuf->jpjreqtype);
		#endif 
			try
			{
						
				//IJpjUpdCallerServicePtr pI("JpjUpdCaller.JpjUpdCallerService.1");
				IJpjUpdSpCallerServicePtr pI("JpjUpdSpCaller.JpjUpdSpCallerService.1");
			
				// create a safe array to store the stream data
				psa = SafeArrayCreateVector( VT_UI1, 0, sizeof(JPJ_UPD_CALLER_REQ_T));
					if(!psa)
					{
						#ifdef DEBUG
							userlog("SafeArrayCreateVector() Failed.");
							userlog("call_jpj_update: Calling insert_into_legacy_request");
						#endif
						callFlag = 1;
					}
					else
					{
						if(FAILED(	SafeArrayAccessData( psa, (void**)&pData )))
						{
							#ifdef DEBUG
								userlog("REQ SafeArrayAccessData() Failed.");
								userlog("call_jpj_update: Calling insert_into_legacy_request");
							#endif
							callFlag = 1;
						}
						else
						{	
							// copy the memory into the safearray
							memcpy( pData, pstSendBuf, sizeof(JPJ_UPD_CALLER_REQ_T));		
							SafeArrayUnaccessData(psa);
							if(FAILED(ret = pI->Execute(psa, &psaRsp)))
							{
								#ifdef DEBUG
									userlog("Error while executing JpjUpdCallerService. Call to Method Execute() Failed. %d", ret);
								#endif
								callFlag =1;							
							}
						}
				    }
			}
		// Handle any COM exceptions from smart pointers
		catch (_com_error e)
		{
			  #ifdef DEBUG
					userlog("Error while executing JpjUpdCallerService. Call to Method Execute() Failed. %s", e.ErrorMessage());
			 #endif
			 
			  callFlag = 1;	
		}
	}
	
	  	#ifdef DEBUG
				userlog("Before free((char*)pstSendBuf)");
		#endif

		if(pstSendBuf)
			free((char*)pstSendBuf);

		#ifdef DEBUG
			userlog("After free((char*)pstSendBuf)");
		 #endif

     if(callFlag == 1)
	 {		
	    sprintf(excep_log.error_msg,"call_jpj_update : Failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);		
						
			return GMPC_BAD;
     }
	 */
		return GMPC_GOOD;

}


/*********************************************************************/
/* Function Name:call_jpj_update									 */
/* Description	:This function calls the service JPJ_UPDATE			 */
/* Input		:Header,Applicant ID,update flag and resp buffer	 */   
/* Return Values:  GMPC_GOOD	 */
/*				 which have only header								 */
/* Limitations	:													 */
/*********************************************************************/
/*int call_jpj_update(HEADER_T *header,void * ctx)
{

	int ret;
	JPJ_UPDATE_REQ_T *pstSendBuf;
	
	long ReqLen = 0;
	long RespLen = 0;
	long ret_code = 0;
	int callFlag = 0;
	//ReqLen = sizeof(JPN_UPDATE_REQ_T  *);
	ReqLen = sizeof(JPJ_UPDATE_REQ_T);
	
	SAFEARRAY *psa;
	SAFEARRAY *psaRsp;
	char flag = UNKNOWN;
	unsigned char *pData = NULL;
	//long lSize;
	//int ret;
	  
	
	
	#ifdef DEBUG
			userlog("call_jpj_update: In call_jpj_update(HEADER header,char flag)");
	#endif

	if((pstSendBuf = (JPJ_UPDATE_REQ_T *)malloc(ReqLen)) == NULL)
	{
		#ifdef DEBUG
			userlog("Memory allocation failed to Send Bufffer");
		#endif
		callFlag = 1;
		
	}
		else
		{
			memset(pstSendBuf, '\0', ReqLen);
			#ifdef DEBUG
				userlog("Memory allocated to Send Buf");
			#endif
			// Copy input data into request buffer 
			strcpy(pstSendBuf->header.user_id, header->user_id);
			strcpy(pstSendBuf->header.workstation_id, header->workstation_id);
			strcpy(pstSendBuf->header.branch_code, header->branch_code);
			strcpy(pstSendBuf->header.application_id, header->application_id);
			pstSendBuf->invoke_mode = SERVICE_CALL;
			
		#ifdef DEBUG
			userlog("call_jpj_update : REQUEST DATA FOR JPJ_UPDATE :");
			userlog("call_jpj_update : User Id - %s", pstSendBuf->header.user_id );
			userlog("call_jpj_update : Workstation Id - %s", pstSendBuf->header.workstation_id );
			userlog("call_jpj_update : Gsc No - %s", pstSendBuf->header.branch_code );
			userlog("call_jpj_update : Application Id - %s", pstSendBuf->header.application_id);
			userlog("call_jpj_update : Invoke mode - %c", pstSendBuf->invoke_mode);
		#endif 
			try
			{
						
				IJpjUpdateServicePtr pI("JpjUpdate.JpjUpdateService.1");
			
				// create a safe array to store the stream data
				psa = SafeArrayCreateVector( VT_UI1, 0, sizeof(JPJ_UPDATE_REQ_T));
					if(!psa)
					{
						#ifdef DEBUG
							userlog("SafeArrayCreateVector() Failed.");
							userlog("call_jpj_update: Calling insert_into_legacy_request");
						#endif
						callFlag = 1;
					}
					else
					{
						if(FAILED(	SafeArrayAccessData( psa, (void**)&pData )))
						{
							#ifdef DEBUG
								userlog("REQ SafeArrayAccessData() Failed.");
								userlog("call_jpj_update: Calling insert_into_legacy_request");
							#endif
							callFlag = 1;
						}
						else
						{	
							// copy the memory into the safearray
							memcpy( pData, pstSendBuf, sizeof(JPN_UPDATE_REQ_T));		
							SafeArrayUnaccessData(psa);
							if(FAILED(ret = pI->Execute(psa, &psaRsp)))
							{
								#ifdef DEBUG
									userlog("Error while executing JpjUpdateService. Call to Method Execute() Failed. %d", ret);
								#endif
								callFlag =1;
							
							}
						}
				  }
			}
		// Handle any COM exceptions from smart pointers
		catch (_com_error e)
		{
			  #ifdef DEBUG
					userlog("Error while executing JpjUpdateService. Call to Method Execute() Failed. %s", e.ErrorMessage());
			 #endif
			  callFlag = 1;		

		}
	}

	//if(pstSendBuf)
	//{
	//	free((char*)pstSendBuf);
	//}

     if(callFlag == 1)
	 {
		
	    sprintf(excep_log.error_msg,"call_jpj_update : Failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);

		 // Begin a new transaction 
		if(((ret = gscbbegin_trans(ctx))) == FAILURE)
		{
			userlog("call_jpj_update: Failed to begin a new transaction\n");
			return BEGIN_TRAN_ERROR;
		}

		ret = 0;
		if((ret = insert_into_legacy_request(flag, header, JPJ_ID, -1, 0,ctx)) == FAILURE)
		{
						
			return GMPC_GOOD;
		}

		// Commit the transaction 
		if(((ret = gscbcommit_trans(ctx))) == FAILURE)
		{
			userlog("call_jpj_update: insert_into_legacy_request failed\n");
			return END_TRAN_ERROR;
		}
     }
		return GMPC_GOOD;

}
*/

/*********************************************************************/
/* Function Name:call_jpn_update									 */
/* Description	:This function calls the service JPN_UPDATE			 */
/* Input		:Header,Applicant ID,update flag and resp buffer	 */   
/* Return Values:TPACALL_ERROR / GMPC_GOOD	 */
/*				 which have only header								 */
/* Limitations	:													 */
/*********************************************************************/
int call_jpn_update(HEADER_T *header, char invoke_mode,void * ctx)
{
///* //samsuri un remark this
	int ret;
	JPN_UPDATE_REQ_T *pstSendBuf;
	
	long ReqLen = 0;
	long RespLen = 0;
	long ret_code = 0;
	int callFlag = 0;
	//ReqLen = sizeof(JPN_UPDATE_REQ_T  *);
	ReqLen = sizeof(JPN_UPDATE_REQ_T);
	
	SAFEARRAY *psa;
	SAFEARRAY *psaRsp;
	char flag = UNKNOWN;
	unsigned char *pData = NULL;

	if((pstSendBuf = (JPN_UPDATE_REQ_T *)malloc(ReqLen+5)) == NULL)
	{
		#ifdef DEBUG
			userlog("Memory allocation failed to Send Bufffer");
		#endif
		callFlag = 1;
		
	}
	else
	{
		memset(pstSendBuf, '\0', ReqLen);
		#ifdef DEBUG
			userlog("Memory allocated to Send Buf");
		#endif
		// Copy input data into request buffer 
		strcpy(pstSendBuf->header.user_id, header->user_id);
		strcpy(pstSendBuf->header.workstation_id, header->workstation_id);
		strcpy(pstSendBuf->header.branch_code, header->branch_code);
		strcpy(pstSendBuf->header.application_id, header->application_id);
		if(invoke_mode != '\0')
		{
			pstSendBuf->invoke_mode = invoke_mode;
		}
		else
		{
			pstSendBuf->invoke_mode = SERVICE_CALL;
		}

	#ifdef DEBUG
		userlog("call_jpn_update : REQUEST DATA FOR JPN_UPDATE :");
		userlog("call_jpn_update : User Id - %s", pstSendBuf->header.user_id );
		userlog("call_jpn_update : Workstation Id - %s", pstSendBuf->header.workstation_id );
		userlog("call_jpn_update : Gsc No - %s", pstSendBuf->header.branch_code );
		userlog("call_jpn_update : Application Id - %s", pstSendBuf->header.application_id);
		userlog("call_jpn_update : Invoke mode - %c", pstSendBuf->invoke_mode);
	#endif 
	try
	{
				
		IJpnUpdateServicePtr pI("JpnUpdate.JpnUpdateService.1");
	
		// create a safe array to store the stream data
		psa = SafeArrayCreateVector( VT_UI1, 0, sizeof(JPN_UPDATE_REQ_T));
		if(!psa)
		{
			#ifdef DEBUG
				userlog("call_jpn_update: Calling insert_into_legacy_request");
			#endif
			callFlag = 1;
	    }
		else
		{
			if(FAILED(	SafeArrayAccessData( psa, (void**)&pData )))
			{
				#ifdef DEBUG
					userlog("REQ SafeArrayAccessData() Failed.");
				#endif
				callFlag = 1;
			}
			else
			{	
				// copy the memory into the safearray
				memcpy( pData, pstSendBuf, sizeof(JPN_UPDATE_REQ_T));		
				SafeArrayUnaccessData(psa);
				if(FAILED(ret = pI->Execute(psa, &psaRsp)))
				{
					#ifdef DEBUG
						userlog("Error while executing JpnUpdateService. Call to Method Execute() Failed. %d", ret);
					#endif
					callFlag =1;
				
				}
			  }
          }
	}
	
	// Handle any COM exceptions from smart pointers
	catch (_com_error e)
	{
		  #ifdef DEBUG
				userlog("Error while executing JpnUpdateService. Call to Method Execute() Failed. %s", e.ErrorMessage());
		 #endif
		  callFlag = 1;		
	
		}
	}

	//if(pstSendBuf)
	//{
		//free((char*)pstSendBuf);
	//}

     if(callFlag == 1)
	 {
		// Begin a new transaction 
		if(((ret = gscbbegin_trans(ctx))) == FAILURE)
		{
			userlog("call_jpn_update: Failed to begin a new transaction\n");
			return BEGIN_TRAN_ERROR;
		}

		ret = 0;
		if((ret = insert_into_legacy_request(flag, header, JPN_ID, -1, 1,ctx)) == FAILURE)
		{
						
			return GMPC_GOOD;
		}

		// Commit the transaction 
		if(((ret = gscbcommit_trans(ctx))) == FAILURE)
		{
			userlog("call_jpn_update: insert_into_legacy_request failed\n");
			return END_TRAN_ERROR;
		}
		
     }
//	*/ //samsuri unremark this
	return GMPC_GOOD;
	
}

/******************************************************************/
/* Function Name:call_afis_update								  */
/* Description	:This function calls the service AFIS_UPDATE	  */
/* Input		:Header,Applicant ID,update flag and resp buffer  */   
/* Return Values:TPACALL_ERROR / GMPC_GOOD						  */
/*				 which have only header							  */
/* Limitations	:												  */
/******************************************************************/
int call_afis_update(HEADER_T *header, char invoke_mode,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char applid[APP_ID_SIZE];

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int i = 0;
	int ret = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	userlog("Inside the call_afis_update()");

	strcpy(applid, header->application_id);

	userlog("header->application_id , applid : %s, %s",header->application_id,applid);

	
	EXEC SQL INSERT INTO IJPN_AFIS_REQ(APPLID,REQDATETIME,REQFLAG,
		REQSTAT,SERVICEID,TIMESTAMP)
		VALUES(:applid,TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'),
		'D',-1,76,TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'));
	
	userlog("Inserting into IJPN_AFIS_REQ : SQLCODE : %d",SQLCODE);

	if(SQLCODE != 0)
	{
		userlog("Inserting into IJPN_AFIS_REQ failed : %s",SQLMSG);

		strcpy(prog_log.remarks,"Inserting into IJPN_AFIS_REQ failed");
		sprintf(excep_log.error_msg,"Inserting into IJPN_AFIS_REQ failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

		return INSERT_ERROR;

	}
	    // added this on 21/12/2006
	    // Commit the transaction 
		if(((ret = gscbcommit_trans(ctx))) == FAILURE)
		{
			userlog("call_afis_update: insert into IJPN_AFIS_REQ failed\n");
			return END_TRAN_ERROR;
		}
	
	userlog("Inserting into IJPN_AFIS_REQ Successful");

	return GMPC_GOOD;
}

/*********************************************************************/
/* Function Name:call_imm_update									 */
/* Description	:This function calls the service JPN_UPDATE			 */
/* Input		:Header,Applicant ID,update flag and resp buffer	 */   
/* Return Values: TPACALL_ERROR /  GMPC_GOOD	 */
/*				 which have only header								 */
/* Limitations	:													 */
/*********************************************************************/
int call_imm_update(HEADER_T *header,void * ctx)
{
   
/*
    int ret;
	IMM_UPDATE_REQ_T *pstSendBuf;
	
	long ReqLen = 0;
	long RespLen = 0;
	long ret_code = 0;
	int callFlag = 0;
	//ReqLen = sizeof(IMM_UPDATE_REQ_T  *);
	ReqLen = sizeof(IMM_UPDATE_REQ_T);
	
	SAFEARRAY *psa;
	SAFEARRAY *psaRsp;
	char flag = UNKNOWN;
	unsigned char *pData = NULL;
	
	  
	
	
	#ifdef DEBUG
			userlog("call_imm_update: In call_imm_update(HEADER header,char flag)");
	#endif

	if((pstSendBuf = (IMM_UPDATE_REQ_T *)malloc(ReqLen)) == NULL)
	{
		#ifdef DEBUG
			userlog("Memory allocation failed to Send Bufffer");
		#endif
		callFlag = 1;
		
	}
		else
		{
			memset(pstSendBuf, '\0', ReqLen);
			#ifdef DEBUG
				userlog("Memory allocated to Send Buf");
			#endif
			// Copy input data into request buffer 
			strcpy(pstSendBuf->header.user_id, header->user_id);
			strcpy(pstSendBuf->header.workstation_id, header->workstation_id);
			strcpy(pstSendBuf->header.branch_code, header->branch_code);
			strcpy(pstSendBuf->header.application_id, header->application_id);
			pstSendBuf->no_of_passports = 0;
			//pstSendBuf->invoke_mode = SERVICE_CALL;
			
		#ifdef DEBUG
			userlog("call_imm_update : REQUEST DATA FOR JPJ_UPDATE :");
			userlog("call_imm_update : User Id - %s", pstSendBuf->header.user_id );
			userlog("call_imm_update : Workstation Id - %s", pstSendBuf->header.workstation_id );
			userlog("call_imm_update : Gsc No - %s", pstSendBuf->header.branch_code );
			userlog("call_imm_update : Application Id - %s", pstSendBuf->header.application_id);
			userlog("call_imm_update : no_of_passports - %d", pstSendBuf->no_of_passports);
		#endif 
			try
			{
						
				IImmUpdateServicePtr pI("ImmUpdate.ImmUpdateService.1");
			
				// create a safe array to store the stream data
				psa = SafeArrayCreateVector( VT_UI1, 0, sizeof(IMM_UPDATE_REQ_T));
					if(!psa)
					{
						#ifdef DEBUG
							userlog("SafeArrayCreateVector() Failed.");
							userlog("call_imm_update: Calling insert_into_legacy_request");
						#endif
						callFlag = 1;
					}
					else
					{
						if(FAILED(	SafeArrayAccessData( psa, (void**)&pData )))
						{
							#ifdef DEBUG
								userlog("REQ SafeArrayAccessData() Failed.");
								userlog("call_imm_update: Calling insert_into_legacy_request");
							#endif
							callFlag = 1;
						}
						else
						{	
							// copy the memory into the safearray
							memcpy( pData, pstSendBuf, sizeof(IMM_UPDATE_REQ_T));		
							SafeArrayUnaccessData(psa);
							if(FAILED(ret = pI->Execute(psa, &psaRsp)))
							{
								#ifdef DEBUG
									userlog("Error while executing ImmUpdateService. Call to Method Execute() Failed. %d", ret);
								#endif
								callFlag =1;
							
							}
						}
				  }
			}
		// Handle any COM exceptions from smart pointers
		catch (_com_error e)
		{
			  #ifdef DEBUG
					userlog("Error while executing ImmUpdateService. Call to Method Execute() Failed. %s", e.ErrorMessage());
			 #endif
			  callFlag = 1;		

		}
	}

	//if(pstSendBuf)
	//{
	//	free((char*)pstSendBuf);
	//}

     if(callFlag == 1)
	 {
		
	    sprintf(excep_log.error_msg,"call_imm_update : Failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);

		 // Begin a new transaction 
		if(((ret = gscbbegin_trans(ctx))) == FAILURE)
		{
			userlog("call_imm_update: Failed to begin a new transaction\n");
			return BEGIN_TRAN_ERROR;
		}

		ret = 0;
		if((ret = insert_into_legacy_request(flag, header, JIM_ID, -1, 0,ctx)) == FAILURE)
		{
						
			return GMPC_GOOD;
		}

		// Commit the transaction 
		if(((ret = gscbcommit_trans(ctx))) == FAILURE)
		{
			userlog("call_imm_update: insert_into_legacy_request failed\n");
			return END_TRAN_ERROR;
		}
     }
	
	
	*/ return GMPC_GOOD;

}


/*********************************************************************/
/* Function Name:call_pdrm_update									 */
/* Description	:This function calls the service JPN_UPDATE			 */
/* Input		:Header,Applicant ID,update flag and resp buffer	 */   
/* Return Values:TPACALL_ERROR / GMPC_GOOD	 */
/*				 which have only header								 */
/* Limitations	:													 */
/*********************************************************************/
int call_pdrm_update(HEADER_T *header,void * ctx)
{
/*
	int ret;
	PDRM_UPDATE_REQ_T *pstSendBuf;
	
	long ReqLen = 0;
	long RespLen = 0;
	long ret_code = 0;
	int callFlag = 0;
	//ReqLen = sizeof(PDRM_UPDATE_REQ_T  *);
	ReqLen = sizeof(PDRM_UPDATE_REQ_T);
	
	SAFEARRAY *psa;
	SAFEARRAY *psaRsp;
	char flag = UNKNOWN;
	unsigned char *pData = NULL;
	
	
	#ifdef DEBUG
			userlog("call_pdrm_update: In call_imm_update(HEADER header,char flag)");
	#endif

	if((pstSendBuf = (PDRM_UPDATE_REQ_T *)malloc(ReqLen)) == NULL)
	{
		#ifdef DEBUG
			userlog("Memory allocation failed to Send Bufffer");
		#endif
		callFlag = 1;	
	}
	else
	{
			memset(pstSendBuf, '\0', ReqLen);
			#ifdef DEBUG
				userlog("Memory allocated to Send Buf");
			#endif
			// Copy input data into request buffer 
			strcpy(pstSendBuf->header.user_id, header->user_id);
			strcpy(pstSendBuf->header.workstation_id, header->workstation_id);
			strcpy(pstSendBuf->header.branch_code, header->branch_code);
			strcpy(pstSendBuf->header.application_id, header->application_id);
						
		#ifdef DEBUG
			userlog("call_pdrm_update : REQUEST DATA FOR JPJ_UPDATE :");
			userlog("call_pdrm_update : User Id - %s", pstSendBuf->header.user_id );
			userlog("call_pdrm_update : Workstation Id - %s", pstSendBuf->header.workstation_id );
			userlog("call_pdrm_update : Gsc No - %s", pstSendBuf->header.branch_code );
			userlog("call_pdrm_update : Application Id - %s", pstSendBuf->header.application_id);
		#endif 
			try
			{
						
				IPDRMUpdateServicePtr pI("PDRMUpdate.PDRMUpdateService.1");
			
				// create a safe array to store the stream data
				psa = SafeArrayCreateVector( VT_UI1, 0, sizeof(PDRM_UPDATE_REQ_T));
					if(!psa)
					{
						#ifdef DEBUG
							userlog("SafeArrayCreateVector() Failed.");
							userlog("call_pdrm_update: Calling insert_into_legacy_request");
						#endif
						callFlag = 1;
					}
					else
					{
						if(FAILED(	SafeArrayAccessData( psa, (void**)&pData )))
						{
							#ifdef DEBUG
								userlog("REQ SafeArrayAccessData() Failed.");
								userlog("call_pdrm_update: Calling insert_into_legacy_request");
							#endif
							callFlag = 1;
						}
						else
						{	
							// copy the memory into the safearray
							memcpy(pData, pstSendBuf, sizeof(PDRM_UPDATE_REQ_T));		
							SafeArrayUnaccessData(psa);
							if(FAILED(ret = pI->Execute(psa, &psaRsp)))
							{
								#ifdef DEBUG
									userlog("Error while executing PdrmUpdateService. Call to Method Execute() Failed. %d", ret);
								#endif
								callFlag =1;
							
							}
						}
				  }
			}
		// Handle any COM exceptions from smart pointers
		catch (_com_error e)
		{
			  #ifdef DEBUG
					userlog("Error while executing PdrmUpdateService. Call to Method Execute() Failed. %s", e.ErrorMessage());
			 #endif
			  callFlag = 1;		

		}
	}

	//if(pstSendBuf)
	//{
	//	free((char*)pstSendBuf);
	//}

     if(callFlag == 1)
	 {
		
	    sprintf(excep_log.error_msg,"call_pdrm_update : Failed");
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);

		 // Begin a new transaction 
		if(((ret = gscbbegin_trans(ctx))) == FAILURE)
		{
			userlog("call_pdrm_update: Failed to begin a new transaction\n");
			return BEGIN_TRAN_ERROR;
		}

		ret = 0;
		if((ret = insert_into_legacy_request(flag, header, PDRM_ID, -1, 0,ctx)) == FAILURE)
		{
						
			return GMPC_GOOD;
		}

		// Commit the transaction 
		if(((ret = gscbcommit_trans(ctx))) == FAILURE)
		{
			userlog("call_pdrm_update: insert_into_legacy_request failed\n");
			return END_TRAN_ERROR;
		}
     }
	*/	
	return GMPC_GOOD;

}


/****************************************************************************/
/* Function name: close_problems											*/
/* Description	: This function 				                            */
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int close_problems(char *applid, PROB_RESULT_T *prob, int probno, char *user_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char problem_status;
	char problem_note[NOTE_SIZE];
	char hvuser_id[USER_ID_SIZE];
	int problem_no;

	short application_id_ind = 0;
	short problem_status_ind = 0;
	short problem_note_ind = 0;
	short problem_no_ind = 0;
	short hvuser_id_ind = 0;

	char  hvbskrecd='\0';
	short hvbskrecd_ind = -1;

	//Added by Salmi Date:12th May, 2020  CRAPPL-  SKP002/CR/2020
	char gUser1[USER_ID_SIZE];
	varchar gUser1TimeStamp[DATE_TIME_SIZE];
	char gUser2[USER_ID_SIZE];
	varchar gUser2TimeStamp[DATE_TIME_SIZE];

	short gUser1_ind = -1;
	short gUser1TimeStamp_ind = -1;
	short gUser2_ind = -1;
	short gUser2TimeStamp_ind = -1;
	//Added by Salmi Date:12th May, 2020  CRAPPL-  SKP002/CR/2020-End

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int i = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN


	
	
	strcpy(hvuser_id, user_id);

	if(hvuser_id[0] == '\0')
	{
		hvuser_id_ind = -1;
	}
	else
	{
		hvuser_id_ind = 0;
	}

	if(0 != applid)
	{
		strcpy(application_id, applid);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	/* Set the problem status = 'closed'	*/
	problem_status = PROBLEM_STATUS_CLOSED;
	problem_status_ind = 0;

	/* If the 2nd parameter is NULL then close all problems		*/
	if(NULL == prob)
	{
		EXEC SQL UPDATE PROBL_RECORD 
				 SET PROBLSTAT = :problem_status:problem_status_ind,
				 ACTDATETIME = SYSDATE,
				 ACTUSERID = :hvuser_id:hvuser_id_ind,
				 PROBLSOLVEDATE = SYSDATE
				 WHERE APPLID = :application_id:application_id_ind;
		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"close_problems : Service failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"close_problems : Service failed due to ORA_ERROR : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}
	}
	else
	{
		/* otherwise parse the buffer and close selected problems	*/
		for(i = 0; i < probno; i++)
		{
			problem_no = prob->problem_number;
			strcpy(problem_note,prob->note);
			hvbskrecd = prob->bskrecd; 
			#ifdef DEBUG
				userlog("close_problems : application_id:%s:", application_id);
				userlog("close_problems : problem_no:%d:", problem_no);
				userlog("close_problems : hvbskrecd:%c:", hvbskrecd);
				userlog("close_problems : prob->bskrecd:%c:", prob->bskrecd);

			#endif

			problem_status = prob->prob_stat;
		#ifdef DEBUG
			userlog("close_problems : problem_status:%c:", problem_status);
			userlog("close_problems : prob->prob_stat:%c:", prob->prob_stat);
			userlog("close_problems : prob notes:%s:", problem_note);
		#endif


			if (problem_note[0] == '\0')
			{
				problem_note_ind = -1;
			}
			else
			{
				problem_note_ind = 0;
			}

			if (problem_status == '\0')
			{
				problem_status_ind = -1;
			}
			else
			{
				problem_status_ind = 0;
			}

			if (hvbskrecd == '\0')
			{
				hvbskrecd_ind = -1;
			}
			else
			{
				hvbskrecd_ind = 0;
			}
			
			//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020

			if (prob->gUser1 == '\0')
			{
				gUser1_ind = -1;
			}
			else
			{
				gUser1_ind = 0;
				strcpy(gUser1,prob->gUser1);
			}
			if(prob->gUser1TimeStamp[0] !='\0')
			{
				strcpy((char *)gUser1TimeStamp.arr, prob->gUser1TimeStamp);
				setlen(gUser1TimeStamp);
				gUser1TimeStamp_ind = 0;
			}
			else
			{
				strcpy((char *)gUser1TimeStamp.arr, "");
				gUser1TimeStamp_ind = -1;
			}
			if (prob->gUser2 == '\0')
			{
				gUser2_ind = -1;
			}
			else
			{
				gUser2_ind = 0;
				strcpy(gUser2,prob->gUser2);
			}
			if(prob->gUser2TimeStamp[0] !='\0')
			{
				strcpy((char *)gUser2TimeStamp.arr, prob->gUser2TimeStamp);
				setlen(gUser2TimeStamp);
				gUser2TimeStamp_ind = 0;
			}
			else
			{
				strcpy((char *)gUser2TimeStamp.arr, "");
				gUser2TimeStamp_ind = -1;
			}
			#ifdef DEBUG
			userlog("close_problems : gUser1:%s:", gUser1);
			userlog("close_problems : gUser1TimeStamp:%s:", gUser1TimeStamp.arr);
			userlog("close_problems : gUser2:%s:", gUser2);
			userlog("close_problems : gUser2TimeStamp:%s:", gUser2TimeStamp.arr);
			#endif
			//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020-End

			EXEC SQL UPDATE PROBL_RECORD 
					 SET PROBLSTAT = :problem_status:problem_status_ind,
					 ACTREMARKS = :problem_note:problem_note_ind,
					 ACTDATETIME = SYSDATE,
					 ACTUSERID = :hvuser_id:hvuser_id_ind,
					 PROBLSOLVEDATE = SYSDATE,
					 BSKRECD = :hvbskrecd:hvbskrecd_ind,  // Added on 28/06/2016 for release 3.32
					 GUSER1 = :gUser1:gUser1_ind,
					 GUSER1TIMESTAMP = TO_DATE(:gUser1TimeStamp:gUser1TimeStamp_ind, 'DDMMYYYY HH24MISS'),
			         GUSER2 = :gUser2:gUser2_ind,
			         GUSER2TIMESTAMP = TO_DATE(:gUser2TimeStamp:gUser2TimeStamp_ind, 'DDMMYYYY HH24MISS')
					 WHERE APPLID = :application_id:application_id_ind
					 AND PROBLNO = :problem_no:problem_no_ind
					 AND PROBLSTAT <> 'C';

			if(SQLCODE && !(NO_DATA_FOUND))
			{
				strcpy(prog_log.remarks,"close_problems : Service failed due to ORA_ERROR");
				sprintf(excep_log.error_msg,"close_problems : Service failed due to ORA_ERROR : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return UPDATE_ERROR;
			}

			/* Advance problem pointer	*/
			prob++;
			#ifdef DEBUG
			userlog("close_problems :prob[%d]", prob);
			#endif
		}
			#ifdef DEBUG
			userlog("close_problems :Testing CLOSE");
			#endif

	}

	return GMPC_GOOD;
}

/****************************************************************************/
/* Function name: set_collection_date										*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int set_collection_date(char *applid, char *collection_date, char *collection_center,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char colln_date[DATE_SIZE];
//	char kptno[KPT_SIZE];
//	int cardversion;
	
	char colln_center[BRANCH_CODE_SIZE] = {0};
	short application_id_ind = 0;
	short colln_date_ind = 0;
	short kptno_ind = 0;
	short cardversion_ind = 0;
	short colln_center_ind = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;


	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if(0 != applid)
	{
		strcpy(application_id, applid);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	/* Set the collection date	*/
	if(0 != collection_date)
	{
		strcpy(colln_date, collection_date);
		colln_date_ind = 0;
	}
	else
	{
		strcpy(colln_date, "");
		colln_date_ind = -1;
	}

	if( collection_center[0] != '\0' && collection_center[0] != ' ' )  // included this space check on 10/3/2011
	{
		strcpy(colln_center, collection_center);
		colln_center_ind = 0;
	}
	else
	{
		colln_center_ind = -1;
	}


#ifdef DEBUG
	userlog("set_collection_date : collection date %s , collection center %s", colln_date, colln_center);
#endif //DEBUG

/*	EXEC SQL SELECT MAX(CARDVERSIONNO) INTO :cardversion:cardversion_ind 
			 FROM CARD_STATUS WHERE 
			 APPLID = :application_id:application_id_ind;

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR in set_collection_date");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return RET_SEL_KPT_CARD_VER;
	}

	EXEC SQL SELECT KPTNO INTO :kptno:kptno_ind
			 FROM CARD_STATUS WHERE 
			 APPLID = :application_id:application_id_ind AND 
			 CARDVERSIONNO = :cardversion:cardversion_ind;
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR in set_collection_date");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return RET_SEL_KPT_CARD_VER;
	}

	EXEC SQL UPDATE CARD_STATUS 
			 SET CARDISSUEDATE = TO_DATE(:colln_date:colln_date_ind, 'DDMMYYYY') 
			 WHERE KPTNO =  :kptno:kptno_ind
			 AND CARDVERSIONNO = :cardversion:cardversion_ind;
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR in set_collection_date");
		sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : Service failed due to ORA_ERROR : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return RET_UPD_CARD_COLL_DATE;
	}
*/
	EXEC SQL UPDATE APPLICATION 
			 SET 
			 //CARDCOLLDATE = NVL(TO_DATE(:colln_date:colln_date_ind, 'DDMMYYYY'), CARDCOLLDATE), // commented on 07/09/2007
			 COLLCENTER = NVL(:colln_center:colln_center_ind, COLLCENTER)
			 WHERE 
			 APPLID = :application_id:application_id_ind;
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"set_collection_date : Service failed due to ORA_ERROR in set_collection_date");
		sprintf(excep_log.error_msg,"set_collection_date : Service failed due to ORA_ERROR : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return UPDATE_ERROR;
	}

	return GMPC_GOOD;
}

/****************************************************************************/
/* Function name: all_probs_resolved										*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int all_probs_resolved(char *applid,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	//char exists;
	int exists=0;
	char problem_status = COMPLETED_GSC;
	
	short application_id_ind = 0;
	short exists_ind = 0;
	short problem_status_ind = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;


	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if(0 != applid)
	{
		strcpy(application_id, applid);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	userlog("all_probs_resolved : Before the select stmt");

	/* commeneted on 5/09/2005 as per vasanth instr. as this is returning more than one record

	EXEC SQL SELECT 'X' INTO :exists:exists_ind FROM PROBL_RECORD 
			 WHERE APPLID = :application_id:application_id_ind 
			 AND PROBLSTAT <> :problem_status:problem_status_ind;
	*/
	
	EXEC SQL SELECT COUNT(*) INTO :exists:exists_ind FROM PROBL_RECORD 
			 WHERE APPLID = :application_id:application_id_ind 
			 AND PROBLSTAT <> :problem_status:problem_status_ind;

	userlog("all_probs_resolved : After the select stmt");
	userlog("all_probs_resolved : sqlca.sqlcode : %d",sqlca.sqlcode);

	//if(SQLCODE && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
		userlog("all_probs_resolved : Inside the sqlcode check");
		strcpy(prog_log.remarks,"all_probs_resolved : Service failed due to ORA_ERROR in all_probs_resolved");
		sprintf(excep_log.error_msg,"all_probs_resolved : Service failed due to ORA_ERROR : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}
	if(exists == 0)
	{
		userlog("all_probs_resolved : Inside the NO DATA FOUND");
		return GMPC_GOOD;
	}
	else
	{
		#ifdef DEBUG
			userlog("all_probs_resolved : Unexpected condition: all problems not resolved");
		#endif

		strcpy(prog_log.remarks,"all_probs_resolved : Unexpected condition: all problems not resolved");
		sprintf(excep_log.error_msg,"all_probs_resolved : Unexpected condition: all problems not resolved ");
		//excep_log.termination_flag = YES;
		//excep_log.severity = FATAL;
		log_error(ctx);
		return NOT_ALL_PROB_CLOSED;
	}
	
	//return GMPC_GOOD;

}

/****************************************************************************/
/* Function name: put_approved_data											*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int put_approved_data(SET_APPL_STAT_L3_REQ_T *pReq, NAME_ADDRESS_T *name_add, 
						char *pTxnCode,void * ctx)	//Last param added for JRS 147
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char hv_applid[APP_ID_SIZE];
	varchar hv_kptno[KPT_SIZE]={0};
	int birthdistrictcode=0;
	char policeid[POLICE_ID_SIZE]={0};
	char militaryid[MILITARY_ID_SIZE]={0};
	char kppno[KPP_SIZE]={0};
	char gender='\0';
	char personstatcode='\0';
	char birthdate[DATE_SIZE]={0};
	char unknownbirthind='\0';
	char religioncode='\0';
	char racecode[RACE_CODE_SIZE]={0};
	char residentstat = '\0';
	char citizenshipstatcode='\0';
	char colourarticlecode[ARTICLE_COLOR_CODE_SIZE]={0};
	char hkind='\0';
	char iccolorcode = '\0';
	char origname[ORIG_NAME_SIZE]={0};
//	char currlongname[LONG_NAME_SIZE];

	varchar currshortname1[SIREN_SHORT_NAME]={0};
	varchar currshortname2[SIREN_SHORT_NAME]={0};
	
	char ktindcode[KT_CODE_SIZE]={0};
	char jpnremarks1[REMARK_SIZE]={0};
	char jpnremarks2[REMARK_SIZE]={0};
	char afisflag='\0';
	int cardlostcnt=0;
	char kptapplstat='\0';
	char kptappldate[DATE_SIZE]={0};
	char kptcollectiondate[DATE_SIZE]={0};
	varchar kptcollectionplaccode[KPT_COLLECTION_PLACE_SIZE]={0};
	char lastaddchangedate[DATE_SIZE]={0};
	char lastcardissuedate[DATE_SIZE]={0};
	char juvenileflag='\0';
	int cardversionno=0;
	char birthplace[BIRTH_PLACE_SIZE]={0};
	char rjind[RJ_SIZE]={0};
	char citizennationcode[CITIZEN_CODE_SIZE] = {0};

	char hv_cncode[CITIZEN_CODE_SIZE] = {0};

	varchar gmpcshortname1[GMPC_SNAME1_SIZE]={0};
	varchar gmpcshortname2[GMPC_SNAME2_SIZE]={0};
	varchar gmpcshortname3[GMPC_SNAME2_SIZE]={0};
	varchar address1[ADDRESS_SIZE]={0};
	varchar address2[ADDRESS_SIZE]={0};
	varchar address3[ADDRESS_SIZE]={0};
	varchar postcode[POST_CODE_SIZE]={0};
	int citycode=0;
	char statecode[STATE_CODE_SIZE]={0};

	varchar currlongname[LONG_NAME_SIZE]={0};
	char lcitizencode[CITIZEN_CODE_SIZE] = {"\0"};


	short int hv_kptno_ind = 0;
	short int birthdistrictcode_ind = 0;
	short int policeid_ind = 0;
	short int militaryid_ind = 0;
	short int kppno_ind = 0;
	short int gender_ind = 0;
	short int personstatcode_ind = 0;
	short int birthdate_ind = 0;
	short int unknownbirthind_ind = 0;
	short int religioncode_ind = 0;
	short int racecode_ind = 0;
	short int residentstat_ind = 0;
	short int citizenshipstatcode_ind = 0;
	short int colourarticlecode_ind = 0;
	short int hkind_ind = 0;
	short int iccolorcode_ind = 0;
	short int origname_ind = 0;
	short int currlongname_ind = 0;
	short int currshortname1_ind = 0;
	short int currshortname2_ind = 0;
	short int gmpcshortname1_ind = 0;
	short int gmpcshortname2_ind = 0;
	short int gmpcshortname3_ind = 0;
	short int address1_ind = 0;
	short int address2_ind = 0;
	short int address3_ind = 0;
	short int postcode_ind = 0;
	short int citycode_ind = 0;
	short int statecode_ind = 0;
	short int ktindcode_ind = -1;
	short int jpnremarks1_ind = 0;
	short int jpnremarks2_ind = 0;
	short int afisflag_ind = 0;
	short int cardlostcnt_ind = 0;
	short int kptapplstat_ind = 0;
	short int kptappldate_ind = 0;
	short int kptcollectiondate_ind = 0;
	short int kptcollectionplaccode_ind = 0;
	short int lastaddchangedate_ind = 0;
	short int lastcardissuedate_ind = 0;
	short int juvenileflag_ind = 0;
	short int cardversionno_ind = 0;
	short int birthplace_ind = 0;
	short int rjind_ind = -1;
	short int citizennationcode_ind = 0;

//	short int currlongname_ind = 0;
	int icount = 0;
	int icount1 = 0;
	int icount2 = 0;
	int ncount=0;
	char polmilidupdflag= '\0';

//Added by Amarjith on 27th Aug '04. JRS 147.

	char szTxnCode[TRANSACTION_CODE_SIZE] = {"\0"};
	char szPermitIssueDate[DATE_SIZE] = {"\0"};
	char szImmRefDate[DATE_SIZE] = {"\0"};
	char szImmRefNo[IMM_REF_NO_SIZE] = {"\0"};
	char szPassportNo[PASSPORT_NO_SIZE] = {"\0"};
	char szPassportIssueCountry[COUNTRY_CODE_SIZE] = {"\0"};
	char szImmCitizenship[IMM_CITIZENSHIP_SIZE] = {"\0"};

	char szCitizenNationCode[CITIZEN_CODE_SIZE] = {"\0"};
	char szIdNo[16] = {"\0"};

	int  nPrDocType = 0;
	short ind_CitizenNationCode = 0;
	short ind_IdNo = 0;

	//char szPermitType[4]={0}; // commenetd for IJPN on 25/10/2005
	int szPermitType=0;
	char szPermitNumber[13]={"\0"};
	char szCountryCodeJpn[5] = {"\0"};

	short szPermitType_ind = -1;
	short szPermitNumber_ind = -1;
	short szImmRefNo_ind = -1;
	short szImmRefDate_ind = -1;
	short szPassportNo_ind = -1;
	short szPassportIssueCountry_ind = -1;
	short szPermitIssueDate_ind = -1;
	short szImmCitizenship_ind = -1;
	short nPrDocType_ind = -1;
	short szCurrLongName_ind = -1;
	
	int nCnt=0,applcnt=0;
	int i=0;

	//varchar szCurrLongName[60+1];
	char szCurrLongName[60+1];

//JRS 147

//JRS 162

	char pmjdate[DATE_SIZE] = {"\0"};
	char pmretdate[DATE_SIZE] = {"\0"};

	short int pmjdate_ind = -1;
	short int pmretdate_ind = -1;

	char  isflag = '\0';
	


	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;


	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(hv_applid, pReq->header.application_id);
	strcpy((char *)hv_kptno.arr, pReq->kptno);
	setlen(hv_kptno);
	setnull(hv_kptno);
//JRS 147
	strcpy(szTxnCode, pTxnCode);
/*
	strcpy(szPermitIssueDate, pReq->szPermitIssueDate);
	strcpy(szImmRefDate, pReq->szImmRefDate);
	strcpy(szImmRefNo, pReq->szImmRefNo);
	strcpy(szPassportNo, pReq->szPassportNo);
	strcpy(szPassportIssueCountry, pReq->szPassportIssueCountry);
	nPrDocType = pReq->nPrDocType;
	strcpy(szImmCitizenship, pReq->szImmCitizenship);
*/

//JRS 147

	userlog("SET_APPL_STAT_L3 :Entered put_approved_data().");

	nCnt = 0;
	EXEC SQL SELECT COUNT(*) INTO :nCnt 
		FROM APPNT_IMM_PR_INFO
		WHERE APPLID = :hv_applid;

		if((SQLCODE != 0) && (SQLCODE != 1403))
		{
			userlog("put_approved_data : select count from appnt_imm_pr_info failed : %s", SQLMSG);
			strcpy(prog_log.remarks, "put_approved_data : select count from appnt_imm_pr_info failed");
			sprintf(excep_log.error_msg, "put_approved_data : select count from appnt_imm_pr_info failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

	if(nCnt > 0)
	{
		userlog("Inside the count> 0 condition");

		EXEC SQL 
			SELECT PERMITNO, TO_CHAR(PERMITISSUEDATE,'DDMMYYYY'), 
			PERMITTYPE, TO_CHAR(IMMREFDATE,'DDMMYYYY'),
			PASSPORTNO, PASSPORTISSUECOUNTRY, PRDOCTYPE, IMMREFNO,
			CITIZENSHIP
			INTO :szPermitNumber:szPermitNumber_ind,:szPermitIssueDate:szPermitIssueDate_ind,
				  :szPermitType:szPermitType_ind,:szImmRefDate:szImmRefDate_ind,
				  :szPassportNo:szPassportNo_ind,
				  :szPassportIssueCountry:szPassportIssueCountry_ind,:nPrDocType:nPrDocType_ind,
				  :szImmRefNo:szImmRefNo_ind,:szImmCitizenship:szImmCitizenship_ind
			FROM APPNT_IMM_PR_INFO
			WHERE APPLID = :hv_applid;

		if((SQLCODE != 0) && (SQLCODE != 1403))
		{
			userlog("put_approved_data : select from appnt_imm_pr_info failed : %s", SQLMSG);
			strcpy(prog_log.remarks, "put_approved_data : select from appnt_imm_pr_info failed :");
			sprintf(excep_log.error_msg, "put_approved_data : select from appnt_imm_pr_info failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		// select corresponding COUNTRYCODEJPN for PassportIssueCountry
		

		szPassportIssueCountry[3] = '\0'; // since the data length in database for this is 3 only, we terminate the 4th character with null to avoid any spaces at the end

		EXEC SQL SELECT COUNTRYCODEJPN INTO :szCountryCodeJpn
			FROM  IMM_COUNTRY_CODE
			WHERE CITIZENSHIP = :szPassportIssueCountry;

		if((SQLCODE != 0) && (SQLCODE != 1403))
		{
			userlog("put_approved_data : select from IMM_COUNTRY_CODE failed for PassportIssueCountry: %s", SQLMSG);
			strcpy(prog_log.remarks, "put_approved_data : select from IMM_COUNTRY_CODE failed for PassportIssueCountry");
			sprintf(excep_log.error_msg, "put_approved_data : select from IMM_COUNTRY_CODE failed for PassportIssueCountry: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		userlog("szPassportIssueCountry : %s",szPassportIssueCountry);
		userlog("szCountryCodeJpn : %s",szCountryCodeJpn);

		// copy back the szCountryCodeJpn to szPassportIssueCountry

		strcpy(szPassportIssueCountry,"\0"); // make it null
		strcpy(szPassportIssueCountry,szCountryCodeJpn);
		
		szPassportIssueCountry[4] = '\0';

	#ifdef DEBUG
		userlog("after copying CountryCodeJpn to szPassportIssueCountry : %s",szPassportIssueCountry);
	#endif

	
		if(pReq->szPermitIssueDate[0] != '\0')
		{
			strcpy(szPermitIssueDate, pReq->szPermitIssueDate);
			szPermitIssueDate_ind = 0;
		}
		
		if(pReq->szImmRefDate[0] != '\0')
		{
			strcpy(szImmRefDate, pReq->szImmRefDate);
			szImmRefDate_ind = 0;
		}

		if(pReq->szImmRefNo[0] != '\0')
		{
			strcpy(szImmRefNo, pReq->szImmRefNo);
			szImmRefNo_ind = 0;
		}

		if(pReq->szPassportNo[0] != '\0')
		{
			strcpy(szPassportNo, pReq->szPassportNo);
			szPassportNo_ind = 0;
		}

		#ifdef DEBUG
			userlog("Before copy pReq->szPassportIssueCountry");
		#endif

		if(pReq->szPassportIssueCountry[0] != '\0')
		{
			strcpy(szPassportIssueCountry, pReq->szPassportIssueCountry);
			szPassportIssueCountry_ind = 0;
		}

		#ifdef DEBUG
			userlog("After copy pReq->szPassportIssueCountry");
		#endif

		if(pReq->nPrDocType > 0)
		{
			nPrDocType = pReq->nPrDocType;
			nPrDocType_ind = 0;
		}

		#ifdef DEBUG
			userlog("After copy pReq->nPrDocType");
		#endif

		if(pReq->szImmCitizenship[0] != '\0')
		{
			strcpy(szImmCitizenship, pReq->szImmCitizenship);
			szImmCitizenship_ind = 0;

		}
		#ifdef DEBUG
			userlog("After copy pReq->szImmCitizenship");
		#endif

		// JRS 112
		if(pReq->szPermittype != 0)
		{
			szPermitType = pReq->szPermittype;
			szPermitType_ind = 0;
		}

		#ifdef DEBUG
			userlog("After copy pReq->szPermittype");
		#endif

		if(pReq->szPermitNo[0] != '\0')
		{
			strcpy(szPermitNumber, pReq->szPermitNo);
			szPermitNumber_ind=0;
		}

		#ifdef DEBUG
			userlog("After copy szPermitNumber :%s",szPermitNumber);
			userlog("After copy pReq->szPermitNo :%s",pReq->szPermitNo);
			userlog("After copy pReq->szPermitNo");
		#endif

		if(pReq->szCurrLongName[0] != '\0')
		{
			//strcpy((char *)szCurrLongName.arr, pReq->szCurrLongName);
			strcpy(szCurrLongName, pReq->szCurrLongName);
			szCurrLongName_ind=0;
		}

		//szCurrLongName.arr[szCurrLongName.len] = '\0';

		#ifdef DEBUG
			userlog("Before updating APPNT_IMM_PR_INFO ");
		#endif

    EXEC SQL UPDATE APPNT_IMM_PR_INFO
		SET PERMITNO = :szPermitNumber, 
		PERMITISSUEDATE = TO_DATE(:szPermitIssueDate,'DDMMYYYY'),
		PERMITTYPE = :szPermitType, 
		IMMREFDATE = TO_DATE(:szImmRefDate,'DDMMYYYY'),
		PASSPORTNO = :szPassportNo, 
		PASSPORTISSUECOUNTRY = (SELECT  CITIZENSHIP FROM  IMM_COUNTRY_CODE
					WHERE COUNTRYCODEJPN = :szPassportIssueCountry) ,
		PRDOCTYPE = :nPrDocType, 
		IMMREFNO = :szImmRefNo, 
		CURRLONGNAME = :szCurrLongName, 
		CITIZENSHIP = :szImmCitizenship
		WHERE APPLID = :hv_applid;
	// end

	#ifdef DEBUG
		userlog("After updating APPNT_IMM_PR_INFO ");
		userlog("After updating APPNT_IMM_PR_INFO :%d:",sqlca.sqlcode);
	#endif
    }
	else if(nCnt == 0)
	{
		userlog("Inside the count=0 condition");
		

		if(pReq->szPermitIssueDate[0] != '\0')
		{
			strcpy(szPermitIssueDate, pReq->szPermitIssueDate);
			szPermitIssueDate_ind = 0;
		}
		
		if(pReq->szImmRefDate[0] != '\0')
		{
			strcpy(szImmRefDate, pReq->szImmRefDate);
			szImmRefDate_ind = 0;
		}

		if(pReq->szImmRefNo[0] != '\0')
		{
			strcpy(szImmRefNo, pReq->szImmRefNo);
			szImmRefNo_ind = 0;
		}

		if(pReq->szPassportNo[0] != '\0')
		{
			strcpy(szPassportNo, pReq->szPassportNo);
			szPassportNo_ind = 0;
		}

		if(pReq->szPassportIssueCountry[0] != '\0')
		{
			strcpy(szPassportIssueCountry, pReq->szPassportIssueCountry);
			szPassportIssueCountry_ind = 0;
		}
	
		if(pReq->nPrDocType > 0)
		{
			nPrDocType = pReq->nPrDocType;
			nPrDocType_ind = 0;
		}

		if(pReq->szImmCitizenship[0] != '\0')
		{
			strcpy(szImmCitizenship, pReq->szImmCitizenship);
			szImmCitizenship_ind = 0;

		}

		// JRS 112
		if(pReq->szPermittype != 0)
		{
			szPermitType = pReq->szPermittype;
			szPermitType_ind = 0;
		}

		if(pReq->szPermitNo[0] != '\0')
		{
			strcpy(szPermitNumber, pReq->szPermitNo);
			szPermitNumber_ind=0;
		}
		// end

	}

#ifdef DEBUG
	userlog("szPermitNumber			: %s",szPermitNumber);
	userlog("szPermitType			: %d",szPermitType);
	userlog("szPermitIssueDate		: %s",szPermitIssueDate);
	userlog("szImmRefDate			: %s",szImmRefDate);
	userlog("szImmRefNo				: %s",szImmRefNo);
	userlog("szPassportNo			: %s",szPassportNo);
	userlog("szPassportIssueCountry : %s",szPassportIssueCountry);
	userlog("szImmCitizenship		: %s",szImmCitizenship);
	userlog("nPrDocType				: %d",nPrDocType);
#endif
	
	// included this check on 20/04/06 to remove empty spaces in the variable
	if((szPermitIssueDate[0] == ' ') && (szPermitIssueDate[1] == ' '))
	{
		for(i=0;i<DATE_SIZE;i++)
		   szPermitIssueDate[i] = '\0';
	}

	// included this check on 20/04/06 to remove empty spaces in the variable
	if((szImmRefDate[0] == ' ') && (szImmRefDate[1] == ' '))
	{
		for(i=0;i<DATE_SIZE;i++)
		   szImmRefDate[i] = '\0';
	}

	pmretdate[0] = '\0'; pmjdate[0] = '\0';
	EXEC SQL 
		SELECT BIRTHDISTRICTCODE, POLICEID, MILITARYID, KPPNO, GENDER, PERSONSTATCODE, 
		TO_CHAR(BIRTHDATE, 'DDMMYYYY'), UNKNOWNBIRTHIND, RELIGIONCODE, RACECODE, RESIDENTSTAT, CITIZENSHIPSTATCODE, 
		COLOURARTICLECODE, HKIND, ICCOLORCODE, ORIGNAME, CURRLONGNAME,
		CURRSHORTNAME1, CURRSHORTNAME2,
		KTINDCODE, JPNREMARKS1, JPNREMARKS2, AFISFLAG, 
		CARDLOSTCNT, KPTAPPLSTAT, TO_CHAR(KPTAPPLDATE, 'DDMMYYYY'), 
		TO_CHAR(KPTCOLLECTIONDATE, 'DDMMYYYY'), KPTCOLLECTIONPLACCODE, 
		TO_CHAR(LASTADDCHANGEDATE, 'DDMMYYYY'), 
		TO_CHAR(LASTCARDISSUEDATE, 'DDMMYYYY'), JUVENILEFLAG, CARDVERSIONNO, 
		BIRTHPLACE, RJIND, CITIZENNATIONCODE,
		TO_CHAR(POLMILITARYJOINDATE,'DDMMYYYY'), TO_CHAR(RETIREMENTDATE,'DDMMYYYY')
	INTO :birthdistrictcode:birthdistrictcode_ind, :policeid:policeid_ind, :militaryid:militaryid_ind,
	  :kppno:kppno_ind, :gender:gender_ind, :personstatcode:personstatcode_ind, :birthdate:birthdate_ind,
	  :unknownbirthind:unknownbirthind_ind, :religioncode:religioncode_ind, :racecode:racecode_ind,
	  :residentstat:residentstat_ind, :citizenshipstatcode:citizenshipstatcode_ind, :colourarticlecode:colourarticlecode_ind,
	  :hkind:hkind_ind, :iccolorcode:iccolorcode_ind, :origname:origname_ind, :currlongname:currlongname_ind,
	  :currshortname1:currshortname1_ind, :currshortname2:currshortname2_ind,
	  :ktindcode:ktindcode_ind,
	  :jpnremarks1:jpnremarks1_ind, :jpnremarks2:jpnremarks2_ind, :afisflag:afisflag_ind,
	  :cardlostcnt:cardlostcnt_ind, :kptapplstat:kptapplstat_ind, :kptappldate:kptappldate_ind, :kptcollectiondate:kptcollectiondate_ind, 
	  :kptcollectionplaccode:kptcollectionplaccode_ind, :lastaddchangedate:lastaddchangedate_ind, 
	  :lastcardissuedate:lastcardissuedate_ind, :juvenileflag:juvenileflag_ind, :cardversionno:cardversionno_ind, 
	  :birthplace:birthplace_ind, :rjind:rjind_ind, :citizennationcode:citizennationcode_ind,
	  :pmjdate:pmjdate_ind,pmretdate:pmretdate_ind
	FROM JPN_INFO
	WHERE KPTNO = :hv_kptno;

	userlog("put_approved_data : Fetching from JPN_INFO successful.");
	userlog("put_approved_data : ICCOLOURCODE from JPN_INFO is: %c. INDICATOR is: %d", iccolorcode, iccolorcode_ind);
	userlog("put_approved_data : RESIDENTSTAT from JPN_INFO is: %c. INDICATOR is: %d", residentstat, residentstat_ind);
	userlog("put_approved_data : SQL ERROR :%d",SQLCODE);
	userlog("put_approved_data : rjind from jpn_info table :%s",rjind);
	userlog("put_approved_data : rjind_ind from jpn_info table :%d",rjind_ind);
	userlog("put_approved_data : ktindcode from jpn_info table :%s",ktindcode);
	userlog("put_approved_data : ktindcode_ind from jpn_info table :%d",ktindcode_ind);

	userlog("put_approved_data : militaryid, militaryid_ind from jpn_info table :%s,%d",militaryid,militaryid_ind);
	userlog("put_approved_data : pmjdate,pmjdate_ind from jpn_info table :%s,%d",pmjdate,pmjdate_ind);
	userlog("put_approved_data : pmretdate,pmretdate_ind from jpn_info table :%s,%d",pmretdate,pmretdate_ind);
	

	if(SQLCODE != 0)
	{
		strcpy(prog_log.remarks, "put_approved_data : Service failed due to SELECT_ERROR");
		sprintf(excep_log.error_msg, "put_approved_data : select from jpn_info failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}


	// Added this code on 07/09/2010 as part of Release 3.19 to insert a retitrement & join date value if it is null
	//CR no 214

	if((militaryid_ind == 0) && ((militaryid[0] != '\0') && (militaryid[0] != ' ')))
	{
		userlog("put_approved_data : militaryid, militaryid_ind from jpn_info table :%s,%d",militaryid,militaryid_ind);
		userlog("put_approved_data : personstatcode :%c",personstatcode);

		if(personstatcode == 'A')
		{
			applcnt = 0;
			EXEC SQL SELECT COUNT(*) INTO :applcnt FROM APPL_TXN 
				WHERE APPLID = :hv_applid 
				AND LEGTXNCODE NOT IN ('3150','4150')
				AND SUBSTR(LEGTXNCODE,1,1) IN ('3','4');

			userlog("put_approved_data : applcnt :%d",applcnt);

			if(applcnt > 0)
			{
				if((strcmp(pmjdate,"\0") == 0) || (pmjdate[0] == ' '))
				{
					EXEC SQL SELECT TO_CHAR(TO_DATE(SUBSTR(:hv_applid,1,8),'YYYYMMDD'),'DDMMYYYY') INTO :pmjdate FROM DUAL;										
					pmjdate_ind = 0;
				}


				if((strcmp(pmretdate,"\0") == 0) || (pmretdate[0] == ' '))
				{
					EXEC SQL SELECT TO_CHAR(TO_DATE(SUBSTR(:hv_applid,1,8),'YYYYMMDD'),'DDMMYYYY') INTO :pmretdate FROM DUAL;										
					pmretdate_ind = 0;
				}
			}
		}
	}

	//

		#ifdef DEBUG			
			userlog("pmjdate, pmjdate_ind:%s, %d:", pmjdate,pmjdate_ind);
			userlog("pmjdate, pmretdate_ind:%s, %d:", pmretdate,pmretdate_ind);			
		#endif





//Added by Amarjith on 27th Aug '04. JRS 147
	if(strcmp(szTxnCode, "308") == 0 || strcmp(szTxnCode, "408") == 0)
	{
		iccolorcode = 'M';
		residentstat = 'M';
		iccolorcode_ind = 0;
		residentstat_ind = 0;
	}
	userlog("put_approved_data : ICCOLOURCODE after validation TXN code is : %c. INDICATOR is: %d. TXNCODE was: %s.", iccolorcode, iccolorcode_ind, szTxnCode);
	userlog("put_approved_data : RESIDENTSTAT after validation TXN code is: %c. INDICATOR is: %d, TXNCODE was: %s.", residentstat, residentstat_ind, szTxnCode);

//JRS 147.

	// added the following two select count stmts on 21/11/05 for updating birthdate and currlongname

		icount1 = 0;
		EXEC SQL SELECT COUNT(*) INTO :icount1 FROM APPL_TXN
				WHERE APPLID = :hv_applid
				 AND TXNCODE IN ('306', '406')
				 AND TXNCANCELCODE IS NULL;

		if(SQLCODE != 0)	
		{
			userlog("selecting from appl_txn failed for names update: %s",SQLMSG);
		}

		icount2 = 0;
		EXEC SQL SELECT COUNT(*) INTO :icount2 FROM APPL_TXN
				WHERE APPLID = :hv_applid
				 AND TXNCODE IN ('324', '424')
				 AND TXNCANCELCODE IS NULL;

		if(SQLCODE != 0)	
		{
			userlog("selecting from appl_txn failed for birthdate update: %s",SQLMSG);
		}

		// ADDED this update statement on 23/09/2008
		if(icount1 == 0)
		{
			EXEC SQL UPDATE APPNT_JPN_INFO 
				       SET (CURRLONGNAME,CURRSHORTNAME1,CURRSHORTNAME2) =
				       (SELECT CURRLONGNAME,CURRSHORTNAME1,CURRSHORTNAME2 
				          FROM JPN_INFO WHERE KPTNO=:hv_kptno) 
				     WHERE APPLID=:hv_applid;
		}

		// Added this code on 1/09/2010 to make rjind and ktind NULL when there is - as value

		if(strcmp(rjind, "-") == 0)
			strcpy(rjind, "\0");

		if(strcmp(ktindcode, "-") == 0)
			strcpy(ktindcode,"\0");
        //


	if(name_add == NULL)
	{
		EXEC SQL
			UPDATE APPNT_JPN_INFO
			SET KPPNO			= :kppno:kppno_ind, GENDER = :gender:gender_ind, 
			//BIRTHDATE			=  TO_DATE(:birthdate:birthdate_ind, 'DDMMYYYY'), 
			BIRTHDATE			=  DECODE(:icount2, 0, TO_DATE(:birthdate:birthdate_ind, 'DDMMYYYY'), 1, BIRTHDATE),
			UNKNOWNBIRTHIND		= :unknownbirthind:unknownbirthind_ind, 
			RELIGIONCODE		= :religioncode:religioncode_ind, RACECODE = :racecode:racecode_ind, 
			CITIZENSHIPSTATCODE =  :citizenshipstatcode:citizenshipstatcode_ind, 
			//HKIND				=  DECODE(:hkind_ind, 0, :hkind, -1, HKIND), 
			ORIGNAME			= :origname:origname_ind, 
			CURRLONGNAME		=  DECODE(:icount1, 1, :currlongname:currlongname_ind, 0, CURRLONGNAME),
			CURRSHORTNAME1		=  DECODE(:icount1, 1, :currshortname1:currshortname1_ind, 0, CURRSHORTNAME1),
			CURRSHORTNAME2		=  DECODE(:icount1, 1, :currshortname2:currshortname2_ind, 0, CURRSHORTNAME2),
			JPNREMARKS1			= :jpnremarks1:jpnremarks1_ind, 
			JPNREMARKS2			= :jpnremarks2:jpnremarks2_ind, 
			BIRTHPLACE			= :birthplace:birthplace_ind, 
			//RJIND				= DECODE(:rjind_ind, 0, :rjind, RJIND), // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			RESIDENTSTAT		= :residentstat:residentstat_ind, 
			PERSONSTATCODE		= :personstatcode:personstatcode_ind, 
			LASTADDCHANGEDATE	= TO_DATE(:lastaddchangedate:lastaddchangedate_ind, 'DDMMYYYY'), 
			AFISFLAG			= :afisflag:afisflag_ind, 
			//CARDLOSTCNT = :cardlostcnt:cardlostcnt_ind, commented on 29/04/2014 to block the update
			LASTKPTISSUEDDATE	= TO_DATE(:lastcardissuedate:lastcardissuedate_ind, 'DDMMYYYY'), 
			KPTAPPLSTAT			= :kptapplstat:kptapplstat_ind,
			HSCCOLORCODE		= DECODE(:iccolorcode_ind, 0, :iccolorcode, -1, HSCCOLORCODE), 
			CITIZENNATIONCODE	= DECODE(CITIZENNATIONCODE, NULL,:citizennationcode , CITIZENNATIONCODE), 
			PERMITISSUEDATE		= TO_DATE(:szPermitIssueDate:szPermitIssueDate_ind, 'DDMMYYYY'), 			
			IMMREFNO			= DECODE(:szImmRefNo_ind,0,:szImmRefNo,-1,IMMREFNO),
			IMMREFDATE			= DECODE(:szImmRefDate_ind,0,TO_DATE(:szImmRefDate, 'DDMMYYYY'),-1, IMMREFDATE),
			PASSPORTNO			= DECODE(:szPassportNo_ind,0,:szPassportNo,-1,PASSPORTNO),
			PASSPORTISSUECOUNTRY= DECODE(:szPassportIssueCountry_ind,0,:szPassportIssueCountry,-1,PASSPORTISSUECOUNTRY),
			PRDOCTYPE			= DECODE(:nPrDocType_ind,0,:nPrDocType,PRDOCTYPE), //JRS 147 
			PERMITNO			= DECODE(:szPermitNumber_ind,0,:szPermitNumber,PERMITNO),
			PERMITTYPE			= DECODE(:szPermitType_ind,0,:szPermitType,PERMITTYPE)
			//KTINDCODE           = DECODE(:ktindcode_ind, 0, :ktindcode,KTINDCODE), // CR211 3.18 25/06/2010 // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			//RESTRICRESIDCODE    = DECODE(:ktindcode_ind, 0, :ktindcode,KTINDCODE)  // CR211 3.18 25/06/2010 // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			WHERE APPLID		= :hv_applid;

		if(SQLCODE != 0)
		{
			strcpy(prog_log.remarks, "put_approved_data : Service failed due to UPDATE_ERROR");
			sprintf(excep_log.error_msg, "put_approved_data : UPDATE appnt_jpn_info failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}
	}
	else
	{

		#ifdef DEBUG
			userlog("put_approved_data : name_add->currlongname:%s:", name_add->currlongname);
			userlog("put_approved_data : name_add->gmpcshortname1:%s:", name_add->gmpcshortname1);
			userlog("put_approved_data : name_add->gmpcshortname2:%s:", name_add->gmpcshortname2);
			userlog("put_approved_data : name_add->gmpcshortname3:%s:", name_add->gmpcshortname3);
			userlog("put_approved_data : name_add->address1:%s:", name_add->address.address1);
			userlog("put_approved_data : name_add->address2:%s:", name_add->address.address2);
			userlog("put_approved_data : name_add->address3:%s:", name_add->address.address3);
			userlog("put_approved_data : name_add->post_code:%s:", name_add->address.post_code);
			userlog("put_approved_data : name_add->city_code:%d:", name_add->address.city_code);
			userlog("put_approved_data : name_add->state_code:%s:", name_add->address.state_code);
			userlog("put_approved_data : name_add->currshortname1:%s:", name_add->currshortname1);
			userlog("put_approved_data : name_add->currshortname2:%s:", name_add->currshortname2);
		#endif

		icount = 0;

		EXEC SQL SELECT COUNT(*) INTO :icount FROM APPL_TXN
				WHERE APPLID = :hv_applid
				 AND TXNCODE IN ('306', '406')
				 AND TXNCANCELCODE IS NULL;

		if(SQLCODE)	
		{
			strcpy(prog_log.remarks,"put_approved_data : Error while Selecting from APPL_TXN");
			sprintf(excep_log.error_msg,"put_approved_data : Error while Selecting from APPL_TXN: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		if(icount >= 1)
		{
			if(name_add->currlongname[0] != '\0')
			{
				strcpy((char *)currlongname.arr, name_add->currlongname);
				setlen(currlongname);
				currlongname_ind = 0;
			}
			else
			{
				currlongname_ind = -1;
			}

			if(name_add->currshortname1[0] != '\0')
			{
				strcpy((char *)currshortname1.arr, name_add->currshortname1);
				setlen(currshortname1);
				currshortname1_ind = 0;
			}
			else
			{
				currshortname1_ind = -1;
			}

			if(name_add->currshortname2[0] != '\0')
			{
				strcpy((char *)currshortname2.arr, name_add->currshortname2);
				setlen(currshortname2);
				currshortname2_ind = 0;
			}
			else
			{
				currshortname2_ind = -1;
			}
		}

		if(name_add->gmpcshortname1[0] != '\0')
		{
			strcpy((char *)gmpcshortname1.arr, name_add->gmpcshortname1);
			setlen(gmpcshortname1);
		}
		else
		{
			gmpcshortname1_ind = -1;
		}

		if(name_add->gmpcshortname2[0] != '\0')
		{
			strcpy((char *)gmpcshortname2.arr, name_add->gmpcshortname2);
			setlen(gmpcshortname2);
		}
		else
		{
			gmpcshortname2_ind = -1;
		}

		if(name_add->gmpcshortname3[0] != '\0')
		{
			strcpy((char *)gmpcshortname3.arr, name_add->gmpcshortname3);
			setlen(gmpcshortname3);
		}
		else
		{
			gmpcshortname3_ind = -1;
		}

		if(name_add->address.address1[0] != '\0')
		{
			strcpy((char *)address1.arr, name_add->address.address1);
			setlen(address1);
		}
		else
		{
			address1_ind = -1;
		}

		if(name_add->address.address2[0] != '\0')
		{
			strcpy((char *)address2.arr, name_add->address.address2);
			setlen(address2);
		}
		else
		{
			address2_ind = -1;
		}

		if(name_add->address.address3[0] != '\0')
		{
			strcpy((char *)address3.arr, name_add->address.address3);
			setlen(address3);
		}
		else
		{
			address3_ind = -1;
		}

		if(name_add->address.post_code[0] != '\0')
		{
			strcpy((char *)postcode.arr, name_add->address.post_code);
			setlen(postcode);
		}
		else
		{
			postcode_ind = -1;
		}

		if(name_add->address.city_code > 0)
		{
			citycode = name_add->address.city_code;
		}
		else
		{
			citycode_ind = -1;
		}

		if(name_add->address.state_code[0] != '\0')
		{
			strcpy(statecode, name_add->address.state_code);
		}
		else
		{
			statecode_ind = -1;
		}

		
			userlog("put_approved_data : Before updating the UPDATE APPNT_JPN_INFO");

			userlog("put_approved_data : citycode : %d",citycode);
			userlog("put_approved_data : cardlostcnt : %d",cardlostcnt);
			userlog("put_approved_data : rjind from jpn_info table :%s",rjind);
			userlog("put_approved_data : rjind_ind from jpn_info table :%d",rjind_ind);
			userlog("put_approved_data : ktindcode from jpn_info table :%s",ktindcode);
			userlog("put_approved_data : ktindcode_ind from jpn_info table :%d",ktindcode_ind);
		
		

		EXEC SQL
			UPDATE APPNT_JPN_INFO
			SET KPPNO			= :kppno:kppno_ind, 
			GENDER				= :gender:gender_ind, 
			//BIRTHDATE			= TO_DATE(:birthdate:birthdate_ind, 'DDMMYYYY'), 			
			BIRTHDATE			=  DECODE(:icount2, 0, TO_DATE(:birthdate:birthdate_ind, 'DDMMYYYY'), 1, BIRTHDATE),
			UNKNOWNBIRTHIND		= :unknownbirthind:unknownbirthind_ind, 
			RELIGIONCODE		= :religioncode:religioncode_ind, 
			RACECODE			= :racecode:racecode_ind, 
			CITIZENSHIPSTATCODE = :citizenshipstatcode:citizenshipstatcode_ind, 
			//HKIND				= DECODE(:hkind_ind, 0, :hkind, -1, HKIND), 
			ORIGNAME			= :origname:origname_ind, 
			//CURRLONGNAME		= :currlongname:currlongname_ind, 
			//CURRSHORTNAME1		= :currshortname1:currshortname1_ind, 
			//CURRSHORTNAME2		= :currshortname2:currshortname2_ind, 
			CURRLONGNAME		=  DECODE(:icount1, 1, :currlongname:currlongname_ind, 0, CURRLONGNAME),
			CURRSHORTNAME1		=  DECODE(:icount1, 1, :currshortname1:currshortname1_ind, 0, CURRSHORTNAME1),
			CURRSHORTNAME2		=  DECODE(:icount1, 1, :currshortname2:currshortname2_ind, 0, CURRSHORTNAME2),
			JPNREMARKS1			= :jpnremarks1:jpnremarks1_ind, 
			JPNREMARKS2			= :jpnremarks2:jpnremarks2_ind, 
			BIRTHPLACE			= :birthplace:birthplace_ind, 
			//RJIND				= DECODE(:rjind_ind, 0,:rjind, RJIND), // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			RESIDENTSTAT		= :residentstat:residentstat_ind, 
			PERSONSTATCODE		= :personstatcode:personstatcode_ind, 
			LASTADDCHANGEDATE	= TO_DATE(:lastaddchangedate:lastaddchangedate_ind, 'DDMMYYYY'), 
			AFISFLAG			= :afisflag:afisflag_ind, 
			//CARDLOSTCNT			= :cardlostcnt:cardlostcnt_ind, commented on 29/04/2014 to block the update
			LASTKPTISSUEDDATE	= TO_DATE(:lastcardissuedate:lastcardissuedate_ind, 'DDMMYYYY'), 
			KPTAPPLSTAT			= :kptapplstat:kptapplstat_ind,
			HSCCOLORCODE		= DECODE(:iccolorcode_ind, 0, :iccolorcode, -1, HSCCOLORCODE),
			//CURRLONGNAME		= :currlongname:currlongname_ind,
			GMPCSHORTNAME1		= :gmpcshortname1:gmpcshortname1_ind,
			GMPCSHORTNAME2		= :gmpcshortname2:gmpcshortname2_ind,
			GMPCSHORTNAME3		= :gmpcshortname3:gmpcshortname3_ind,
			ADDRESS1			= :address1:address1_ind,
			ADDRESS2			= :address2:address2_ind,
			ADDRESS3			= :address3:address3_ind,
			POSTCODE			= :postcode:postcode_ind,
			CITYCODE			= :citycode:citycode_ind,
			STATECODE			= :statecode:statecode_ind, 
			CITIZENNATIONCODE	= DECODE(CITIZENNATIONCODE, NULL,:citizennationcode , CITIZENNATIONCODE), 
			PERMITISSUEDATE		= TO_DATE(:szPermitIssueDate, 'DDMMYYYY'),
			IMMREFNO			= DECODE(:szImmRefNo_ind,0,:szImmRefNo,-1,IMMREFNO),
			IMMREFDATE			= DECODE(:szImmRefDate_ind,0,TO_DATE(:szImmRefDate, 'DDMMYYYY'),-1, IMMREFDATE),
			PASSPORTNO			= DECODE(:szPassportNo_ind,0,:szPassportNo,-1,PASSPORTNO),
			PASSPORTISSUECOUNTRY= DECODE(:szPassportIssueCountry_ind,0,:szPassportIssueCountry,-1,PASSPORTISSUECOUNTRY),
			PRDOCTYPE			= DECODE(:nPrDocType_ind,0,:nPrDocType,PRDOCTYPE), //JRS 147 
			PERMITNO			= DECODE(:szPermitNumber_ind,0,:szPermitNumber,PERMITNO),
			PERMITTYPE			= DECODE(:szPermitType_ind,0,:szPermitType,PERMITTYPE)
			//KTINDCODE           = DECODE(:ktindcode_ind, 0, :ktindcode, KTINDCODE), // CR211 3.18 25/06/2010  // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			//RESTRICRESIDCODE    = DECODE(:ktindcode_ind, 0, :ktindcode, KTINDCODE)  // CR211 3.18 25/06/2010 // commented for Rel 3.28,moved this to the bottom of the function for mileterty
			WHERE APPLID		= :hv_applid;

		userlog("put_approved_data : UPDATE APPNT_JPN_INFO, sqlca.sqlcode : %d",sqlca.sqlcode);


		if(SQLCODE != 0)
		{
			strcpy(prog_log.remarks, "put_approved_data : Service failed due to UPDATE_ERROR");
			sprintf(excep_log.error_msg, "put_approved_data : UPDATE appnt_jpn_info failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}
	}
// Added this new code on 14/05/2007, police/military id updating to ID number

        polmilidupdflag = 'Y';

// JRS 162 
// ploicemiltery fileds editable at GQD from 08/06/2009onwards
// Editable values sent through JPN_INFO buffer from GQD
	// Commented the following code on 08/06/2009

		/*
		ncount = 0;
		EXEC SQL SELECT COUNT(*) INTO :ncount FROM APPL_TXN
				WHERE APPLID = :hv_applid
				 AND TXNCODE IN ('315', '415');
				 

		if(SQLCODE != 0)	
		{
			userlog("selecting from appl_txn failed for 315/415 txncodes: %s",SQLMSG);
		}

		if(ncount > 0)
		{
			polmilidupdflag = 'N';

		}

		ncount = 0;
		EXEC SQL SELECT COUNT(*) INTO :ncount FROM PROBL_RECORD
				WHERE APPLID = :hv_applid
				 AND PROBLREASONCODE LIKE 'C%';
				 

		if(SQLCODE != 0)	
		{
			userlog("selecting from appl_txn failed for 315/415 txncodes: %s",SQLMSG);
		}

		if(ncount > 0)
		{
			polmilidupdflag = 'Y';

		}

		comment end */

	// included this check on 15/01/2010 to remove empty spaces in the variable
	if((pmretdate[0] == ' ') && (pmretdate[1] == ' '))
	{
		for(i=0;i<DATE_SIZE;i++)
		   pmretdate[i] = '\0';
	}

	// included this check on 15/01/2010 to remove empty spaces in the variable
	if((pmjdate[0] == ' ') && (pmjdate[1] == ' '))
	{
		for(i=0;i<DATE_SIZE;i++)
		   pmjdate[i] = '\0';
	}

		
		userlog("put_approved_data :Before updating APPNT_JPN_INFO pmjdate : %s",pmjdate);
		userlog("put_approved_data :Before updating APPNT_JPN_INFO pmretdate : %s",pmretdate);
		userlog("put_approved_data :Before updating APPNT_JPN_INFO APPLID =  %s",hv_applid);

		if (polmilidupdflag == 'Y')
		{

			if((policeid_ind == 0) && ( policeid[0] != '\0' && policeid[0] != ' '))
			{
			EXEC SQL UPDATE APPNT_JPN_INFO SET IDTYPE = '93', IDNO = RTRIM(:policeid),
				POLMILITARYJOINDATE = TO_DATE(:pmjdate,'DDMMYYYY'), 
				RETIREMENTDATE = TO_DATE(:pmretdate,'DDMMYYYY') // Added this code on 08/06/2009
				WHERE APPLID = :hv_applid;
			
			}
			else if((militaryid_ind == 0) && (militaryid[0] != '\0') && (militaryid[0] != ' '))
			{
			EXEC SQL UPDATE APPNT_JPN_INFO SET IDTYPE = '92', IDNO = RTRIM(:militaryid),
				POLMILITARYJOINDATE = TO_DATE(:pmjdate,'DDMMYYYY'), 
				RETIREMENTDATE = TO_DATE(:pmretdate,'DDMMYYYY')  // Added this code on 08/06/2009
				WHERE APPLID = :hv_applid;

				// Added this code for CR 211 Release 3.18 on 25/06/2010
				if(strcmp(pmretdate,"\0") == 0)
				{
					EXEC SQL UPDATE APPNT_JPN_INFO SET INVSERVICEFLAG = 'S'
					WHERE APPLID = :hv_applid;
				}
				else    // Added this else part on 1/09/2010 to make the invserviceflag null
				{
					ncount = 0;
					EXEC SQL SELECT COUNT(*) INTO :ncount FROM APPL_TXN
						WHERE APPLID = :hv_applid
							AND TXNCODE IN ('206','207','315', '415');

					if(ncount > 0)
					{
						EXEC SQL UPDATE APPNT_JPN_INFO SET INVSERVICEFLAG = 'M'
							WHERE APPLID = :hv_applid;
					}
					else
					{
						EXEC SQL UPDATE APPNT_JPN_INFO SET INVSERVICEFLAG = NULL
							WHERE APPLID = :hv_applid;
					}

					ncount = 0;


					
				}

			}

		}

// end new code


//JRS 87-  Added on 14/05/2007

	
	if(iccolorcode == 'M')
	{
		if(nCnt > 0)
		{
			//if(!strlen(szImmCitizenship))
			if((szImmCitizenship[0] != '\0') && (szImmCitizenship[0] != ' '))
			{

			EXEC SQL UPDATE APPNT_JPN_INFO A
				SET A.IDTYPE = '30', (A.IDNO, A.CITIZENNATIONCODE) = (SELECT B.PERMITNO, C.COUNTRYCODEJPN
				FROM APPNT_IMM_PR_INFO B, IMM_COUNTRY_CODE C
				WHERE B.APPLID = A.APPLID AND C.CITIZENSHIP = :szImmCitizenship)
				WHERE A.APPLID = :hv_applid;

				if(SQLCODE != 0)
				{
					strcpy(prog_log.remarks, "put_approved_data : Failed to Update APPNT_JPN_INFO. Count > 0.");
					sprintf(excep_log.error_msg, "put_approved_data : Failed to Update APPNT_JPN_INFO, Count > 0 : %s", 
						SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);

					return UPDATE_ERROR;

				}
			}
		}
		// For cardfix approval and record not exists in APPNT_IMM_PR_INFO
		// Added this on 21/07/2008
		else if(ncount > 0)
		{
			if((citizennationcode[0] != '\0') && (citizennationcode[0] != ' '))
			{
				EXEC SQL UPDATE APPNT_JPN_INFO A
					SET CITIZENNATIONCODE = :citizennationcode
					WHERE APPLID = :hv_applid;

				if(SQLCODE != 0)
				{
				strcpy(prog_log.remarks, "put_approved_data : Failed to Update APPNT_JPN_INFO for cardfix for ncount > 0.");
				sprintf(excep_log.error_msg, "put_approved_data : Failed to Update APPNT_JPN_INFO cardfix for ncount > 0 : %s", 
				SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return UPDATE_ERROR;

				}
			}
		}

        // Added for CR 262 Release 3.25 on 26/08/2013

		EXEC SQL SELECT CITIZENNATIONCODE INTO :hv_cncode FROM JPN_INFO WHERE
					KPTNO = :hv_kptno AND CITIZENNATIONCODE IS NOT NULL; 

		if(SQLCODE)	
		{
			strcpy(prog_log.remarks,"put_approved_data : Error while Selecting CITIZENNATIONCODE from JPN_INFO");
			sprintf(excep_log.error_msg,"put_approved_data : Error while Selecting CITIZENNATIONCODE from JPN_INFO: %s", SQLMSG);
			//excep_log.termination_flag = YES;
			//excep_log.severity = FATAL;
			//log_error(ctx);
			//return SELECT_ERROR;
		}


        EXEC SQL UPDATE APPNT_JPN_INFO 
			SET CITIZENNATIONCODE = DECODE(SUBSTR(CITIZENNATIONCODE,1,1),NULL,:hv_cncode,
			                          ' ',:hv_cncode, 
									  CITIZENNATIONCODE)
					WHERE APPLID = :hv_applid;

				if(SQLCODE != 0)
				{
					strcpy(prog_log.remarks, "put_approved_data : Failed to Update APPNT_JPN_INFO for CITIZENNATIONCODE.");
					sprintf(excep_log.error_msg, "put_approved_data : Failed to Update APPNT_JPN_INFO CITIZENNATIONCODE : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

			userlog("put_approved_data : After updateing CITIZENNATIONCODE: %d",sqlca.sqlcode);

			// Added this code on 14/05/2007 to fix cardfix center problem 
			// update citizen nationacode to jpn_info value
			ncount = 0;
			EXEC SQL SELECT COUNT(*) INTO :ncount FROM PROBL_RECORD
					WHERE APPLID = :hv_applid
					 AND PROBLREASONCODE LIKE 'C%';

			if(ncount > 0)
			{
				EXEC SQL UPDATE APPNT_JPN_INFO 
					SET CITIZENNATIONCODE = :hv_cncode			                        
						WHERE APPLID = :hv_applid;

				if(SQLCODE != 0)
				{
					strcpy(prog_log.remarks, "put_approved_data : Failed to Update APPNT_JPN_INFO for CITIZENNATIONCODE, cardfix center");
					sprintf(excep_log.error_msg, "put_approved_data : Failed to Update APPNT_JPN_INFO CITIZENNATIONCODE, cardfix center : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

			userlog("put_approved_data : cardfix center updateing CITIZENNATIONCODE: %d",sqlca.sqlcode);

			}


	}
//JRS 87


	// Added this code on 14/05/2007, to update citizennationcode from jpn_info
	// for all approved problamatic applications
	if(iccolorcode == 'H')
	{
		/*
		EXEC SQL UPDATE APPNT_JPN_INFO 
			SET CITIZENNATIONCODE = (SELECT CITIZENNATIONCODE FROM JPN_INFO WHERE
					KPTNO = :hv_kptno AND CITIZENNATIONCODE IS NOT NULL)
					WHERE APPLID=:hv_applid;
		*/

		// This code has been included on 07/03/2016 to break the update and select 
		// into select and update individual statements.

		EXEC SQL SELECT CITIZENNATIONCODE INTO :lcitizencode FROM JPN_INFO WHERE
					KPTNO = :hv_kptno AND CITIZENNATIONCODE IS NOT NULL;

			if(SQLCODE != 0)
				{
					strcpy(prog_log.remarks, "put_approved_data : Failed to SELECT FROM JPN_INFO for CITIZENNATIONCODE, iccolorcode == 'H'");
					sprintf(excep_log.error_msg, "put_approved_data : Failed to SELECT FROM JPN_INFO CITIZENNATIONCODE, iccolorcode == 'H' : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}
					
		userlog("put_approved_data : updateing CITIZENNATIONCODE: %d",sqlca.sqlcode);


		EXEC SQL UPDATE APPNT_JPN_INFO 
			SET CITIZENNATIONCODE = :lcitizencode
					WHERE APPLID=:hv_applid;

			if(SQLCODE != 0)
				{
					strcpy(prog_log.remarks, "put_approved_data : Failed to Update APPNT_JPN_INFO for CITIZENNATIONCODE, iccolorcode == 'H'");
					sprintf(excep_log.error_msg, "put_approved_data : Failed to Update APPNT_JPN_INFO CITIZENNATIONCODE, iccolorcode == 'H' : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

			userlog("put_approved_data : iccolorcode == 'H'  update CITIZENNATIONCODE: %d",sqlca.sqlcode);



	}


	// Added this for CR 282 Release 3.28 on 29/05/2014

	userlog("put_approved_data : Release 3.28");

	EXEC SQL UPDATE APPNT_JPN_INFO SET
		RJIND = DECODE(:rjind_ind, 0,:rjind, RJIND), 
		//Changed on 27th June,2018 by Subramaniam.P to Fix MyPoca Cardfix Problem as this field is shared by Mytentra and Mypoca
		//KTINDCODE = DECODE(:ktindcode_ind, 0, :ktindcode, KTINDCODE),
		KTINDCODE = :ktindcode,
		RESTRICRESIDCODE = DECODE(:ktindcode_ind, 0, :ktindcode, KTINDCODE) 
	WHERE APPLID = :hv_applid AND IDTYPE = '92';


	
		userlog("put_approved_data : UPDATE APPNT_JPN_INFO, sqlca.sqlcode for IDTYPE = 92 -> %s : %d ",ktindcode,sqlca.sqlcode);
	


		if(SQLCODE != 0)
		{
			userlog("put_approved_data : UPDATE APPNT_JPN_INFO failed, but Not a Mytentera case ");			
		}

	icount = 0;

	EXEC SQL SELECT COUNT(*) INTO :icount FROM APPL_TXN
			WHERE APPLID = :hv_applid
			 AND TXNCODE IN ('311', '411')
			 AND TXNCANCELCODE IS NULL;

		if(SQLCODE)	
		{
			strcpy(prog_log.remarks,"put_approved_data : Error while Selecting from APPL_TXN");
			//sprintf(excep_log.error_msg,"put_approved_data : Error while Selecting from APPL_TXN: %s", SQLMSG);
			//excep_log.termination_flag = YES;
			//excep_log.severity = FATAL;
			//log_error(ctx);
			//return SELECT_ERROR;
		}

		if(icount >= 1)
		{
			ncount = 0;
			EXEC SQL SELECT COUNT(*) INTO :ncount FROM PROBL_RECORD
					WHERE APPLID = :hv_applid
					 AND PROBLREASONCODE LIKE 'C%';
			
			if(ncount > 0)
			{
				EXEC SQL UPDATE APPNT_JPN_INFO
				SET (KTINDCODE, KTSTARTDATE,KTENDDATE,KTAREACODE,RJIND,RJSTARTDATE,RJENDDATE,APJAREACODE,RESTRICRESIDCODE) =
					(SELECT KTINDCODE, KTSTARTDATE,KTENDDATE,KTAREACODE,RJIND,RJSTARTDATE,RJENDDATE,APJAREACODE,KTINDCODE
					FROM JPN_INFO WHERE KPTNO = :hv_kptno)
				WHERE APPLID = :hv_applid AND IDTYPE NOT IN ('92','93');
			}

			

		}
		else
		{
		   EXEC SQL UPDATE APPNT_JPN_INFO
				SET (KTINDCODE, KTSTARTDATE,KTENDDATE,KTAREACODE,RJIND,RJSTARTDATE,RJENDDATE,APJAREACODE,INVSERVICEFLAG, RESTRICRESIDCODE) =
					(SELECT KTINDCODE, KTSTARTDATE,KTENDDATE,KTAREACODE,RJIND,RJSTARTDATE,RJENDDATE,APJAREACODE,NULL,KTINDCODE
					FROM JPN_INFO WHERE KPTNO = :hv_kptno)
				WHERE APPLID = :hv_applid AND IDTYPE NOT IN ('92','93');
		}

		
		if(iccolorcode == 'B')
			isflag = 'B';
		else if((iccolorcode == 'M') || (iccolorcode == 'P'))
			isflag = 'M';
		else if((iccolorcode == 'H') || (iccolorcode == 'C'))
			isflag = 'H';


		EXEC SQL UPDATE APPNT_JPN_INFO 
			SET INVSERVICEFLAG = :isflag
		WHERE APPLID = :hv_applid AND ((KTINDCODE = 'KT') OR (RJIND = 'RJ'));


	// This code added on 15/11/2010 to update NULL values to ktindcode,rj_ind,restricresidcode

	//EXEC SQL UPDATE APPNT_JPN_INFO SET RJIND=NULL,KTINDCODE=NULL,RESTRICRESIDCODE=NULL
	//	WHERE APPLID = :hv_applid
	//	AND IDTYPE = '92'
	//	AND (INVSERVICEFLAG != 'S' OR INVSERVICEFLAG IS NULL);


		//Below Code modified by Subramaniam.P on 27th June, 2018 not set KTINDCODE to Null due to MyPoca implementation
		//and this field shared by MyTentra and MyPoca.

		EXEC SQL UPDATE APPNT_JPN_INFO SET RJIND=NULL,RESTRICRESIDCODE=NULL
		WHERE APPLID = :hv_applid
		AND IDTYPE = '92'
		AND (INVSERVICEFLAG != 'S' OR INVSERVICEFLAG IS NULL);

	
		


return GMPC_GOOD;
}

/****************************************************************************/
/* Function name: set_appl_in_progress										*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int set_appl_in_progress(HEADER_T header, char reprint_flag,char trans_code[TRANSACTION_CODE_SIZE],void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char txn_issue[TRANSACTION_CODE_SIZE];
//	char exists;
	char afis_flag;
	int card_status = 0;
	char kptno[KPT_SIZE];
	int txn_type = 0;
	varchar userid[USER_ID_SIZE]={0};
	varchar wsid[WS_ID_SIZE]={0};

	char branch_code[BRANCH_CODE_SIZE] = {0};
	
	char txn_12YO_green[TRANSACTION_CODE_SIZE] = {0};
	char txn_ft_green[TRANSACTION_CODE_SIZE] = {0};
	char txn_conv_green[TRANSACTION_CODE_SIZE] = {0};
	char txn_repl_green[TRANSACTION_CODE_SIZE] = {0};

	int txncount = 0;
	short application_id_ind = 0;
	short transaction_code_ind = 0;
	short exists_ind = 0;
	short afis_flag_ind = 0;
	short txn_type_ind = 0;
	short card_status_ind = 0;
	short kptno_ind = 0;
	int count_issuance = 0;
	int version_no = 0;//Added for IJPN
	int card_stat = 0; //Added for IJPN
	short branch_code_ind = 0;
	short wsid_ind = -1;
	short userid_ind = -1;
	int sent_pc_by_gqd = SENT_PC_BY_GQD;
	char iccolorcode;
	short int iccolorcode_ind = -1;

	char citizennationcode[CITIZEN_CODE_SIZE] = {0};
	char immexpdate[DATE_SIZE] = {0};

	short int citizennationcode_ind = -1;
	short int immexpdate_ind = -1;

	char transaction_code[TRANSACTION_CODE_SIZE]={0};

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;
	
	int ret = 0;
	char appl_status='\0';
	int referred_during_application = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	
//	char status;

	_itoa(TXN_ISSUANCE,txn_issue,10);
	_itoa(TXN_12YO_GREEN, txn_12YO_green, 10);
	_itoa(TXN_FT_GREEN, txn_ft_green, 10);
	_itoa(TXN_CON_GREEN, txn_conv_green, 10);
	_itoa(TXN_REPL_GREEN, txn_repl_green, 10);

	if(0 != header.application_id)
	{
		strcpy(application_id, header.application_id);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}
	if(header.user_id[0] != '\0')
	{
		strcpy((char *)userid.arr, header.user_id);
		setlen(userid);
		userid_ind = 0;
	}
	if(header.workstation_id[0] != '\0')
	{
		strcpy((char *)wsid.arr, header.workstation_id);
		setlen(wsid);
		wsid_ind = 0;
	}
	if(0 != header.branch_code)
	{
		strcpy(branch_code, header.branch_code);
	}
	else
	{
		strcpy(branch_code, "");
		branch_code_ind = -1;
	}

	strcpy(transaction_code,trans_code);


	EXEC SQL SELECT COUNT(*) INTO :count_issuance FROM APPL_TXN
			WHERE APPLID = :application_id:application_id_ind 
			 AND TXNCODE = :txn_issue
			 AND TXNCANCELCODE IS NULL;

	if(SQLCODE)	
	{
		strcpy(prog_log.remarks,"set_appl_in_progress : Error while Selecting from APPL_TXN");
		sprintf(excep_log.error_msg,"set_appl_in_progress : Error while Selecting from APPL_TXN: %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

		EXEC SQL
			SELECT CARDSTAT, KPTNO INTO :card_status:card_status_ind,
			:kptno:kptno_ind
			FROM CARD_STATUS A
			WHERE KPTNO = (SELECT KPTNO FROM APPLICATION 
							WHERE APPLID = :application_id:application_id_ind)
			AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
								FROM CARD_STATUS B WHERE B.KPTNO = A.KPTNO);

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"set_appl_in_progress : Error while Selecting CARDSTAT from CARD_STATUS");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Error while Selecting CARDSTAT from CARD_STATUS : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}
		
/*		if (card_status_ind == -1)
		{
			strcpy(prog_log.remarks,"set_appl_in_progress : card_status not found");
			sprintf(excep_log.error_msg,"set_appl_in_progress : card_status not found ");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_CARD_STAT;
		}
*/
		if (kptno_ind == -1)
		{
			strcpy(prog_log.remarks,"set_appl_in_progress : kptno not found");
			sprintf(excep_log.error_msg,"set_appl_in_progress : kptno not found ");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_KPTNO;
		}

		if(reprint_flag == 'Y')
		{
			if(card_status == ACTIVE)
			{
				strcpy(prog_log.remarks,"set_appl_in_progress : Card is issued cannot be reprinted");
				sprintf(excep_log.error_msg,"set_appl_in_progress : Card is issued cannot be reprinted");
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return INVALID_CARD_STAT;
			}
			else if(card_status == RECEIVED_GQD || card_status == REJECTED_PC)
			{
				if(GMPC_GOOD != (ret = insert_into_card_history(header, kptno, header.application_id, card_status,ctx)))
				{
					return ret;
				}

				EXEC SQL 
					UPDATE CARD_STATUS SET 
					CARDSTAT = 7,
					USERID = :userid,
					TIMESTAMP = SYSDATE,
					GQDBRANCHCODE = :branch_code:branch_code_ind
					WHERE KPTNO = (SELECT KPTNO FROM APPLICATION WHERE 
					APPLID = :application_id:application_id_ind)
					AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
					FROM CARD_STATUS WHERE KPTNO = 
					(SELECT KPTNO FROM APPLICATION WHERE 
					APPLID = :application_id:application_id_ind));

				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"set_appl_in_progress : Error while Selecting txn type from APPL_TXN, TXN_CODE");
					sprintf(excep_log.error_msg,"set_appl_in_progress : Error while Selecting from APPL_TXN : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

				if(GMPC_GOOD != (ret = ins_card_status(header, kptno, 0,ctx)))
				{
					return ret;
				}
				appl_status = READY_PROD;
				/* need to insert for clms status update*/
				/* Code added for IJPN */
				EXEC SQL 
					SELECT MAX(CARDVERSIONNO) into :version_no
					FROM CARD_STATUS 
					WHERE  KPTNO = :kptno;
				      
						card_stat  = 0;
					
						EXEC SQL DELETE FROM CLMS_CARD_STAT_UPD WHERE (KPTNO  = :kptno AND  CARDVERSIONNO = :version_no AND CARDSTATUS = :card_stat);
		
						EXEC SQL INSERT INTO CLMS_CARD_STAT_UPD (KPTNO, CARDVERSIONNO, CARDSTATUS,UPDFLAG,USERID,WSID,
							TIMESTAMP)
							VALUES (:kptno,:version_no,:card_stat,'N',:userid:userid_ind,:wsid:wsid_ind,to_date(to_char(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'));

							
				/* End IJPN */



			}
		}
		else if(reprint_flag == 'N')
		{
			if(card_status == RECEIVED_GQD || card_status == ACTIVE)
			{

				if(count_issuance <= 0)
				{

					if(GMPC_GOOD != (ret = insert_into_card_history(header, kptno, header.application_id, card_status,ctx)))
					{
						return ret;
					}

					EXEC SQL 
						UPDATE CARD_STATUS SET 
						CARDSTAT = :sent_pc_by_gqd,
						USERID = :userid,
						TIMESTAMP = SYSDATE//,  //Changed on 18-10-2002		  
//						GQDBRANCHCODE = :branch_code:branch_code_ind
						WHERE KPTNO = (SELECT KPTNO FROM APPLICATION WHERE 
						APPLID = :application_id:application_id_ind)
						AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
						FROM CARD_STATUS WHERE KPTNO = 
						(SELECT KPTNO FROM APPLICATION WHERE 
						APPLID = :application_id:application_id_ind));

					if(SQLCODE)
					{
						strcpy(prog_log.remarks,"set_appl_in_progress : Error while updating card_status");
						sprintf(excep_log.error_msg,"set_appl_in_progress : Error while updating card_status : %s", SQLMSG);
						excep_log.termination_flag = YES;
						excep_log.severity = FATAL;
						log_error(ctx);
						return UPDATE_ERROR;
					}

					appl_status = PRODUCED;
				}
				else
				{

					if(GMPC_GOOD != (ret = insert_into_card_history(header, kptno, header.application_id, card_status,ctx)))
					{
						return ret;
					}

					EXEC SQL 
						UPDATE CARD_STATUS SET 
						CARDSTAT = 16,
						USERID = :userid,
						TIMESTAMP = SYSDATE//, //Changed on 18-10-2002					  
//						GQDBRANCHCODE = :branch_code:branch_code_ind
						WHERE KPTNO = (SELECT KPTNO FROM APPLICATION WHERE 
						APPLID = :application_id:application_id_ind)
						AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
						FROM CARD_STATUS WHERE KPTNO = 
						(SELECT KPTNO FROM APPLICATION WHERE 
						APPLID = :application_id:application_id_ind));

					if(SQLCODE)
					{
						strcpy(prog_log.remarks,"set_appl_in_progress : Error while updating card_status");
						sprintf(excep_log.error_msg,"set_appl_in_progress : Error while updating card_status : %s", SQLMSG);
						excep_log.termination_flag = YES;
						excep_log.severity = FATAL;
						log_error(ctx);
						return UPDATE_ERROR;
					}

					appl_status = ISSUED;

				}
/*				EXEC SQL
					UPDATE APPLICATION SET
					APPLSTAT = 'R' WHERE 
					APPLID = :application_id:application_id_ind;

				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"set_appl_in_progress : Error while updating card_status");
					sprintf(excep_log.error_msg,"set_appl_in_progress : Error while updating card_status : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
			}

*/			}else if(card_status == REJECTED_PC)
			{

				if(GMPC_GOOD != (ret = insert_into_card_history(header, kptno, header.application_id, card_status,ctx)))
				{
					return ret;
				}

				EXEC SQL 
					UPDATE CARD_STATUS SET 
					CARDSTAT = :sent_pc_by_gqd,
					USERID = :userid,
					TIMESTAMP = SYSDATE//,	//Changed on 18-10-2002				
//					GQDBRANCHCODE = :branch_code:branch_code_ind
					WHERE KPTNO = (SELECT KPTNO FROM APPLICATION WHERE 
					APPLID = :application_id:application_id_ind)
					AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
					FROM CARD_STATUS WHERE KPTNO = 
					(SELECT KPTNO FROM APPLICATION WHERE 
					APPLID = :application_id:application_id_ind));

				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"set_appl_in_progress : Error while updating card_status");
					sprintf(excep_log.error_msg,"set_appl_in_progress : Error while updating card_status : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

				appl_status = PRODUCED;
			}
			else
			{
				/* Referred to GQD during application case */
				referred_during_application = 1;
			}

		}
//		appl_status = ISSUED;

#ifdef DEBUG
		userlog("set_appl_in_progress : Issuance case - appl status  %c", appl_status);
#endif

	if((count_issuance <= 0) && (referred_during_application == 1))
	{
		EXEC SQL SELECT B.TXNTYPE INTO :txn_type:txn_type_ind
			FROM APPL_TXN A, TXN_CODE B
			WHERE A.APPLID = :application_id:application_id_ind
			AND A.TXNCODE = B.TXNCODE
			AND A.TXNSERNO = 1;

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"set_appl_in_progress : Error while Selecting txn type from APPL_TXN, TXN_CODE");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Error while Selecting from APPL_TXN : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}
		
		if (txn_type_ind == -1)
		{
			strcpy(prog_log.remarks,"set_appl_in_progress : Transaction type not found");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Transaction type not found : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_TXN_TYPE;
		}

#ifdef DEBUG
		userlog("JPN transaction type is %d", txn_type);
#endif
		switch(txn_type)
		{
		case TXN_12YO:
		case TXN_FT:
		case TXN_CONV:
		case TXN_REPL:
			/*	
			EXEC SQL SELECT AFISFLAG INTO :afis_flag:afis_flag_ind FROM
				 JPN_INFO WHERE KPTNO = (SELECT KPTNO FROM APPLICATION
				 WHERE APPLID = :application_id:application_id_ind);
			*/
			EXEC SQL SELECT AFISBYPASS INTO :afis_flag:afis_flag_ind 
				 FROM APPNT_JPN_INFO
				WHERE APPLID = :application_id:application_id_ind;
				
				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"set_appl_in_progress : Error selecting Afis flag from APPNT_JPN_INFO");
					sprintf(excep_log.error_msg,"set_appl_in_progress : Error selecting Afis flag from APPNT_JPN_INFO : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return SELECT_ERROR;
				}

				/*
				if ((afis_flag == AFIS_SEARCH_DONE) || (afis_flag == AFIS_VV_DONE) || (afis_flag == AFIS_VV_NOT_DONE))
				{
					appl_status = READY_PROD;
				}
				else
				{
					appl_status = PENDING_1N;
				}
				*/
			

			if(strcmp(transaction_code, "426") == 0)
			{

			    appl_status = READY_PROD;

				afis_call_flag = 'N';  // Added this on 06/09/2011, 426 transaction should not refire AFIS

				EXEC SQL 
					SELECT MAX(CARDVERSIONNO) into :version_no 
					FROM CARD_STATUS 
					WHERE  KPTNO = :kptno;
				      
						card_stat  = 0;
					
				EXEC SQL DELETE FROM CLMS_CARD_STAT_UPD WHERE 
					(KPTNO  = :kptno AND  CARDVERSIONNO = :version_no 
					AND CARDSTATUS = :card_stat);
		
				EXEC SQL INSERT INTO CLMS_CARD_STAT_UPD 
					(KPTNO, CARDVERSIONNO, CARDSTATUS,UPDFLAG,
					USERID,WSID,TIMESTAMP)
					VALUES (:kptno,:version_no,:card_stat,'N',
					:userid:userid_ind,:wsid:wsid_ind,
					to_date(to_char(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'));



			}
			else
			{
				if(afis_flag == 1)
				{
				  appl_status = READY_PROD;

				  /* need to insert for clms status update*/
				    
					EXEC SQL 
					SELECT MAX(CARDVERSIONNO) into :version_no 
					FROM CARD_STATUS 
					WHERE  KPTNO = :kptno;
				      
						card_stat  = 0;
					
					EXEC SQL DELETE FROM CLMS_CARD_STAT_UPD WHERE (KPTNO  = :kptno AND  CARDVERSIONNO = :version_no AND CARDSTATUS = :card_stat);
		
					EXEC SQL INSERT INTO CLMS_CARD_STAT_UPD (KPTNO, CARDVERSIONNO, CARDSTATUS,UPDFLAG,USERID,WSID,
							TIMESTAMP)
							VALUES (:kptno,:version_no,:card_stat,'N',:userid:userid_ind,:wsid:wsid_ind,to_date(to_char(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'));
				  if (SUCCESS != (ret = insert_into_afis_refire(application_id,ctx)))
				  {
				  #ifdef DEBUG
					userlog("CREATE_APPLNT : insert_into_afis_refire() failed with %d", ret);
				  #endif
				   return ret;
				  }

				}
				else
				appl_status = PENDING_1N; 
				afis_call_flag = 'Y';

			} /* end of checking trnasaction code for afis */
				/*
				else if ((afis_flag == AFIS_NO_REC) || (afis_flag == AFIS_REC_NO_SEARCH))
				{
					appl_status = PENDING_1N;
				}
				else
				{
					strcpy(prog_log.remarks,"set_appl_in_progress : Invalid value of AFIS flag");
					sprintf(excep_log.error_msg,"set_appl_in_progress : Invalid value of AFIS flag");
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return RET_INVAL_AFIS_FLAG;
				}
				*/

				

				break;

		case TXN_CHIP_UPD:
		case TXN_MISC:
			appl_status = FAST_LANE_COMPLETE;
			break;
		default:
			strcpy(prog_log.remarks,"set_appl_in_progress : Invalid Transaction type");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Invalid Transaction type ");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_TXN_TYPE;


		}

/*		EXEC SQL 
			SELECT COUNT(*) INTO :txncount
			FROM APPL_TXN
			WHERE TXNCODE IN (:txn_12YO_green, :txn_ft_green, 
								:txn_conv_green, :txn_repl_green)
			AND APPLID = :application_id
			AND TXNCANCELCODE IS NULL;


		if(SQLCODE != 0)
		{
			strcpy(prog_log.remarks, "set_appl_in_progress : Error selecting count of Txncode from APPL_TXN");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Error selecting count of Txncode from APPL_TXN : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

*/
		if(txn_type == TXN_CONV || txn_type == TXN_REPL || txn_type == TXN_12YO || txn_type == TXN_FT)
		{
			EXEC SQL 
				SELECT ICCOLORCODE INTO :iccolorcode:iccolorcode_ind
				FROM JPN_INFO
				WHERE KPTNO = (SELECT KPTNO FROM APPLICATION
				 WHERE APPLID = :application_id:application_id_ind);

			if(SQLCODE != 0)
			{
				strcpy(prog_log.remarks, "set_appl_in_progress : Error selecting count of Txncode from APPL_TXN");
				sprintf(excep_log.error_msg,"set_appl_in_progress : Error selecting count of Txncode from APPL_TXN : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return SELECT_ERROR;
			}
		}

		EXEC SQL 
			SELECT CITIZENNATIONCODE, TO_CHAR(IMMEXPDATE, 'YYYYMMDD') INTO :citizennationcode:citizennationcode_ind, 
			:immexpdate:immexpdate_ind
			FROM APPNT_JPN_INFO
			WHERE APPLID = :application_id:application_id_ind;

		if(SQLCODE != 0)
		{
			strcpy(prog_log.remarks, "set_appl_in_progress : Error selecting from APPNT_JPN_INFO");
			sprintf(excep_log.error_msg,"set_appl_in_progress : Error selecting from APPNT_JPN_INFO: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		/*added by brijesh on 24 sept 2002*/
		//if(!strcmp(citizennationcode, "3000") || immexpdate[0] == '\0')

		if(immexpdate_ind == -1)
		{
			immexpdate[0] = '\0';
		}


//		if(txncount > 0 || (iccolorcode == 'H' && (txn_type == TXN_CONV || txn_type == TXN_REPL)))
		if(iccolorcode == 'H')
		{
			ret = set_card_expiry_date(kptno, application_id, txn_type, immexpdate,ctx);
			if(ret != GMPC_GOOD)
			{
				return ret;
			}
		}
	}

/*	if(txncount > 0 || (iccolorcode == 'H' && (txn_type == TXN_CONV || txn_type == TXN_REPL)))
	{
		ret = set_card_expiry_date(kptno, application_id, txn_type, immexpdate,ctx);
		if(ret != GMPC_GOOD)
		{
			return ret;
		}
	}
*/
	#ifdef DEBUG
		userlog("Before :change_appl_status");
	#endif

	ret = change_appl_status(header, appl_status, "",ctx);
	
	#ifdef DEBUG
		userlog("After :change_appl_status ret = %d",ret);
	#endif

	return ret;
}



/********************************************************************************/
/* Function name: insert_into_afis_refire													*/
/* Description	: This function Inserts record to refire AFIS during recovery   */
/* Input		: Applicant's KPTNO & APPLID									*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int insert_into_afis_refire(char appl_id[],void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char kptno[KPT_SIZE] = {0};
	char applid[APP_ID_SIZE]={0};	
	
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;


	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	/* Populate the variables	*/

	strcpy(applid,appl_id);
	

#ifdef DEBUG
	userlog("insert_into_afis_refire : applid - %s", applid);
	userlog("insert_into_afis_refire : applid - %s", applid);
#endif

	EXEC SQL SELECT KPTNO INTO :kptno 
		FROM APPLICATION WHERE APPLID = :applid;


	EXEC SQL INSERT INTO APPL_REFIRE_AFIS(APPLID, KPTNO, TIMESTAMP, REFIREFLAG, APPLSTAT)
		VALUES(:applid,:kptno,SYSDATE,'N','A');

		if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("insert_into_afis_refire : Insert into APPL_REFIRE_AFIS failed");
#endif
		strcpy(prog_log.remarks,"insert_into_afis_refire: Insert into APPL_REFIRE_AFIS failed");
		sprintf(excep_log.error_msg, "insert_into_afis_refire : Insert into APPL_REFIRE_AFIS failed for KPT %s : %s", kptno, SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return INSERT_ERROR;
	}

		return SUCCESS;
}

/****************************************************************************/
/* Function name: change_bsk_applstatus										*/
/* Description	: This function 				                            */
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int change_bsk_applstatus(HEADER_T header, NAME_ADDRESS_T *name_add, char *refbcode, char napplstat, void * ctx)
{
	struct sqlca sqlca = {0}; 
	EXEC SQL BEGIN DECLARE SECTION;

	varchar application_id[APP_ID_SIZE]= {0};
	char newapplstat = '\0';
	varchar refbranchcode[BRANCH_CODE_SIZE]= {0};
	varchar branchcode[BRANCH_CODE_SIZE]= {0};
	varchar wsid[WS_ID_SIZE] = {0};
	varchar userid[USER_ID_SIZE] = {0};
	
	short application_id_ind = -1;
	short newapplstat_ind = -1;
	short refbranchcode_ind = -1;
	short wsid_ind = -1;
	short userid_ind = -1;

	varchar gmpcshortname1[GMPC_SNAME1_SIZE]={0};
	varchar gmpcshortname2[GMPC_SNAME2_SIZE]={0};
	varchar gmpcshortname3[GMPC_SNAME2_SIZE]={0};
	varchar currlongname[LONG_NAME_SIZE]={0};
	varchar currshortname1[SIREN_SHORT_NAME]={0};
	varchar currshortname2[SIREN_SHORT_NAME]={0};
	short int currlongname_ind = 0;
	short int currshortname1_ind = 0;
	short int currshortname2_ind = 0;
	short int gmpcshortname1_ind = 0;
	short int gmpcshortname2_ind = 0;
	short int gmpcshortname3_ind = 0;
	int pcount=0;

	sql_context pcCtx; 
	EXEC SQL END DECLARE SECTION;

	int ret = 0;

	pcCtx = ctx; 
	EXEC SQL CONTEXT USE :pcCtx;


	strcpy((char *)application_id.arr, header.application_id);
		setlen(application_id);
		if(application_id.arr[0] != '\0')
			application_id_ind = 0;

	strcpy((char *)wsid.arr, header.workstation_id);
		setlen(wsid);
		if(wsid.arr[0] != '\0')
			wsid_ind = 0;

	strcpy((char *)userid.arr, header.user_id);
		setlen(userid);
		if(userid.arr[0] != '\0')
			userid_ind = 0;

	strcpy((char *)branchcode.arr, header.branch_code);
		setlen(branchcode);

	strcpy((char *)refbranchcode.arr, refbcode);
		setlen(refbranchcode);
		if(refbranchcode.arr[0] != '\0')
			refbranchcode_ind = 0;


	newapplstat = napplstat;
		if(newapplstat != '\0')
			newapplstat_ind = 0;
		

	if(GMPC_GOOD != (ret = insert_into_appl_history(header,ctx)))
		{
			return ret;
		}


	#ifdef DEBUG
		userlog("change_bsk_applstatus :application_id :%s:", application_id.arr);
		userlog("change_bsk_applstatus :refbranchcode:%s:",refbranchcode.arr);
		userlog("change_bsk_applstatus :newapplstat:%c:",newapplstat);
		userlog("change_bsk_applstatus :branchcode:%s:",branchcode.arr);
		userlog("change_bsk_applstatus :wsid:%s:",wsid.arr);
		userlog("change_bsk_applstatus :userid:%s:",userid.arr);
	#endif


		EXEC SQL UPDATE APPLICATION
			SET APPLSTAT      = :newapplstat:newapplstat_ind,
				SSCBRANCHCODE = :refbranchcode:refbranchcode_ind,
				TIMESTAMP     =  SYSDATE,
				WSID          = :wsid:wsid_ind,
				USERID        = :userid:userid_ind
			WHERE APPLID      = :application_id;		

		#ifdef DEBUG
			userlog("change_bsk_applstatus : After update application sqlca.sqlcode : %d",sqlca.sqlcode);
		#endif

	if(sqlca.sqlcode != 0)
	{
		#ifdef DEBUG
			userlog("change_bsk_applstatus : update application failed, sqlca.sqlcode : %d",sqlca.sqlcode);
		#endif
		strcpy(prog_log.remarks,"change_bsk_applstatus : Service failed due to UPDATE_ERROR");
		sprintf(excep_log.error_msg,"change_bsk_applstatus : updating application with newapplstat failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return UPDATE_ERROR;
	}

	if(strcmp((char *)branchcode.arr,(char *)refbranchcode.arr) != 0)
	{
			#ifdef DEBUG
				userlog("change_bsk_applstatus : before delete APPNT_PROBL_DATA ");
			#endif

			EXEC SQL DELETE FROM APPNT_PROBL_DATA
			WHERE APPLID = :application_id;

			#ifdef DEBUG
				userlog("change_bsk_applstatus : After delete appnt_probl_data, sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif

		if((sqlca.sqlcode != 0) && !(NO_DATA_FOUND))
		{
			#ifdef DEBUG
				userlog("change_bsk_applstatus : delete APPNT_PROBL_DATA failed, sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif
			strcpy(prog_log.remarks,"change_bsk_applstatus : DELETE APPNT_PROBL_DATA failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_bsk_applstatus : DELETE APPNT_PROBL_DAT FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return DELETE_ERROR;
		}

			#ifdef DEBUG
				userlog("change_bsk_applstatus : before insert APPNT_PROBL_DATA ");
			#endif

		EXEC SQL INSERT INTO APPNT_PROBL_DATA(
				APPLID, SSCBRANCHCODE, SENDFLAG, TIMESTAMP)
				VALUES(:application_id:application_id_ind, :refbranchcode:refbranchcode_ind, 'N', SYSDATE);

			#ifdef DEBUG
				userlog("change_bsk_applstatus : After update appnt_probl_data, sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif

		if(sqlca.sqlcode != 0)
		{
			#ifdef DEBUG
				userlog("change_bsk_applstatus : update APPNT_PROBL_DATA failed,sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif
			strcpy(prog_log.remarks,"change_bsk_applstatus : INSERT into APPNT_PROBL_DATA failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_bsk_applstatus : INSERT into APPNT_PROBL_DATA FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INSERT_ERROR;
		}	
		
	}

	// This code added on 16/08/2016 to update name for pindan state capital partial approve

	EXEC SQL SELECT COUNT(*) INTO :pcount
		  FROM PROBL_RECORD
		  WHERE APPLID = :application_id
		  AND PROBLREASONCODE = 'D0001'
		  AND PROBLSTAT = 'C';


	    if(pcount > 0) 
		{
		    if(name_add->currlongname[0] != '\0')
			{
				strcpy((char *)currlongname.arr, name_add->currlongname);
				setlen(currlongname);
				currlongname_ind = 0;
			}
			else
			{
				currlongname_ind = -1;
			}

			if(name_add->currshortname1[0] != '\0')
			{
				strcpy((char *)currshortname1.arr, name_add->currshortname1);
				setlen(currshortname1);
				currshortname1_ind = 0;
			}
			else
			{
				currshortname1_ind = -1;
			}

			if(name_add->currshortname2[0] != '\0')
			{
				strcpy((char *)currshortname2.arr, name_add->currshortname2);
				setlen(currshortname2);
				currshortname2_ind = 0;
			}
			else
			{
				currshortname2_ind = -1;
			}
	

			if(name_add->gmpcshortname1[0] != '\0')
			{
				strcpy((char *)gmpcshortname1.arr, name_add->gmpcshortname1);
				setlen(gmpcshortname1);
			}
			else
			{
				gmpcshortname1_ind = -1;
			}

			if(name_add->gmpcshortname2[0] != '\0')
			{
				strcpy((char *)gmpcshortname2.arr, name_add->gmpcshortname2);
				setlen(gmpcshortname2);
			}
			else
			{
				gmpcshortname2_ind = -1;
			}

			if(name_add->gmpcshortname3[0] != '\0')
			{
				strcpy((char *)gmpcshortname3.arr, name_add->gmpcshortname3);
				setlen(gmpcshortname3);
			}
			else
			{
				gmpcshortname3_ind = -1;
			}


			#ifdef DEBUG
				userlog("change_bsk_applstatus : currlongname:%s:", currlongname.arr);
				userlog("change_bsk_applstatus : gmpcshortname1:%s:", gmpcshortname1.arr);
				userlog("change_bsk_applstatus : gmpcshortname2:%s:", gmpcshortname2.arr);
				userlog("change_bsk_applstatus : gmpcshortname3:%s:", gmpcshortname3.arr);			
				userlog("change_bsk_applstatus : currshortname1:%s:", currshortname1.arr);
				userlog("change_bsk_applstatus : currshortname2:%s:", currshortname2.arr);
			#endif

			EXEC SQL
				UPDATE APPNT_JPN_INFO
				SET 
				CURRLONGNAME		=  DECODE(:currlongname_ind, 0, :currlongname, -1, CURRLONGNAME),
				CURRSHORTNAME1		=  DECODE(:currshortname1_ind, 0, :currshortname1, -1, CURRSHORTNAME1),
				CURRSHORTNAME2		=  DECODE(:currshortname2_ind, 0, :currshortname2, -1, CURRSHORTNAME2),			
				GMPCSHORTNAME1		=  DECODE(:gmpcshortname1_ind,0,:gmpcshortname1,-1,GMPCSHORTNAME1),
				GMPCSHORTNAME2		=  DECODE(:gmpcshortname2_ind,0,:gmpcshortname2,-1,GMPCSHORTNAME2),
				GMPCSHORTNAME3		=  DECODE(:gmpcshortname3_ind,0,:gmpcshortname3,-1,GMPCSHORTNAME3)			
				WHERE APPLID		= :application_id;

			#ifdef DEBUG
				userlog("change_bsk_applstatus : UPDATE APPNT_JPN_INFO, sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif

			if(SQLCODE != 0)
			{
				strcpy(prog_log.remarks, "change_bsk_applstatus : Service failed due to UPDATE_ERROR");
				sprintf(excep_log.error_msg, "change_bsk_applstatus : UPDATE appnt_jpn_info failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				//return UPDATE_ERROR;
			}


			EXEC SQL
				UPDATE DISPUTED_DATA
				SET 
				CURRLONGNAME		=  DECODE(:currlongname_ind, 0, :currlongname, -1, CURRLONGNAME),						
				GMPCSHORTNAME1		=  DECODE(:gmpcshortname1_ind,0,:gmpcshortname1,-1,GMPCSHORTNAME1),
				GMPCSHORTNAME2		=  DECODE(:gmpcshortname2_ind,0,:gmpcshortname2,-1,GMPCSHORTNAME2),
				GMPCSHORTNAME3		=  DECODE(:gmpcshortname3_ind,0,:gmpcshortname3,-1,GMPCSHORTNAME3)			
				WHERE APPLID		= :application_id;

			#ifdef DEBUG
				userlog("change_bsk_applstatus : UPDATE DISPUTED_DATA, sqlca.sqlcode : %d",sqlca.sqlcode);
			#endif

			if(SQLCODE != 0)
			{
				strcpy(prog_log.remarks, "change_bsk_applstatus : Service failed due to UPDATE_ERROR");
				sprintf(excep_log.error_msg, "change_bsk_applstatus : UPDATE appnt_jpn_info failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				//return UPDATE_ERROR;
			}
		}
	
		#ifdef DEBUG
			userlog("change_bsk_applstatus : after the branchcode comparission ");
		#endif

	return GMPC_GOOD;
}

/****************************************************************************/
/* Function name: change_appl_status										*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int change_appl_status(HEADER_T header, char status, char *gqd_branch_code,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char application_status;
	varchar applremarks[REMARK_SIZE];
	char hv_gqd_branch_code[BRANCH_CODE_SIZE];
	varchar userid[USER_ID_SIZE];
	varchar wsid[WS_ID_SIZE];
	varchar hv_priority_days[20] = {0};
	int priority_days = 0;

	short application_id_ind = 0;
	short application_status_ind = 0;
	short applremarks_ind = -1;
	short hv_gqd_branch_code_ind = 0;
    short userid_ind = 0;
	short hv_priority_days_ind = 0;

	int count_appl = 0;
	int old_cardstat = 0;
	short int old_cardstat_ind = 0;
	char kptno[KPT_SIZE];
	int version = 0;
	short int version_ind = 0;
	short int kptno_ind = 0;

	char collcenter[BRANCH_CODE_SIZE];
	char iccolor;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int ret = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	

	if('\0' != header.application_id[0])
	{
		strcpy(application_id, header.application_id);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	if('\0' != header.user_id[0])
	{
		strcpy((char *)userid.arr, header.user_id);
		setlen(userid);
		userid_ind = 0;
	}
	else
	{
		strcpy((char *)userid.arr, "");
		userid_ind = -1;
	}

	strcpy((char *)wsid.arr, header.workstation_id);
	setlen(wsid);

	strcpy(hv_gqd_branch_code, gqd_branch_code);
	if(hv_gqd_branch_code[0] == '\0')
		hv_gqd_branch_code_ind = -1;

	switch(status)
	{
		case TERMINATED_GSC:
			//strcpy((char *)applremarks.arr,"Application is terminated at GSC");
			strcpy((char *)applremarks.arr,"Permohonan dibatalkan di Cawangan");
			setlen(applremarks);
			applremarks_ind = -1;

			EXEC SQL 
				SELECT COUNT(*) INTO :count_appl 
				FROM APPL_HISTORY WHERE 
				APPLID = :application_id:application_id_ind 
				AND APPLSTAT IN ('D', 'S', 'P', 'R');

			if(SQLCODE)
			{
				strcpy(prog_log.remarks,"change_appl_status : Service failed due to SELECT ERROR FROM APPL_HISTORY");
				sprintf(excep_log.error_msg,"change_appl_status : Service failed due to SELECT ERROR FROM APPL_HISTORY : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return SELECT_ERROR;
			}

			if(count_appl >= 1)
			{
				EXEC SQL
					SELECT CARDSTAT, KPTNO, CARDVERSIONNO INTO :old_cardstat:old_cardstat_ind,
					:kptno:kptno_ind, :version:version_ind
					FROM CARD_STATUS WHERE
					KPTNO = (SELECT DISTINCT KPTNO FROM CARD_STATUS WHERE 
					APPLID = :application_id:application_id_ind) 
					AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) 
					FROM CARD_STATUS WHERE 
					APPLID = :application_id:application_id_ind);
					 
				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"change_appl_status : SELECT CARDSTAT FROM CARD_STATUS failed");
					sprintf(excep_log.error_msg,"change_appl_status : SELECT CARDSTAT FROM CARD_STATUS failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return SELECT_ERROR;
				}

				if(GMPC_GOOD != (ret = insert_into_card_history(header, kptno, header.application_id, old_cardstat,ctx)))
				{
					return ret;
				}

				EXEC SQL
					UPDATE CARD_STATUS SET CARDSTAT = 7,
					USERID = :userid, 
					WSID = :wsid,
					TIMESTAMP = SYSDATE
					WHERE KPTNO = :kptno:kptno_ind
					AND CARDVERSIONNO = :version:version_ind;

				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"change_appl_status : UPDATE CARD_STATUS failed");
					sprintf(excep_log.error_msg,"change_appl_status : UPDATE CARD_STATUS failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}
			}
			break;
		case REFFERED_GQD:
			//strcpy((char *)applremarks.arr,"Application is reffered to GQD");
			strcpy((char *)applremarks.arr,"Permohonan tangguh ke GQD");
			setlen(applremarks);
			applremarks_ind = 0;
			break;
		default:
			//strcpy((char *)applremarks.arr,"Application status changed by SSC/GQD");
			strcpy((char *)applremarks.arr,"Status permohonan telah dikemaskini oleh SSC/GQD");
			setlen(applremarks);
			applremarks_ind = 0;
/*			strcpy(prog_log.remarks,"change_appl_status : Service failed due wrong applstat");
			sprintf(excep_log.error_msg,"change_appl_status : wrong applstat");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_APPL_STAT;
*/			break;
	}

	
/*	EXEC SQL SELECT APPLSTAT INTO :application_status:application_status_ind
			 FROM APPLICATION
			 WHERE APPLID = :application_id:application_id_ind;

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"change_appl_status : Service failed due to ORA_ERROR");
		sprintf(excep_log.error_msg,"change_appl_status : change_appl_status : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

*/	/*if(application_status != REFFERED_GQD)
	{*/
		if(GMPC_GOOD != (ret = insert_into_appl_history(header,ctx)))
		{
			return ret;
		}



		/* Set the application status	*/
		application_status = status;
		application_status_ind = 0;
#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :application_id :%s:", application_id);
	userlog("SET_APPL_STAT_L3 :userid :%s:", userid.arr);
	userlog("SET_APPL_STAT_L3 :wsid :%s:", wsid.arr);
	userlog("SET_APPL_STAT_L3 :application_status:%c:",application_status);
	userlog("SET_APPL_STAT_L3 :gqd_branch_code:%s:",gqd_branch_code);
	userlog("SET_APPL_STAT_L3 :hv_gqd_branch_code:%s:",hv_gqd_branch_code);
	userlog("SET_APPL_STAT_L3 :hv_gqd_branch_code_ind:%d:",hv_gqd_branch_code_ind);
#endif


	EXEC SQL
		SELECT PARMVAL INTO :hv_priority_days:hv_priority_days_ind
		FROM SYS_CONFIG_PARMS
		WHERE PARMNAME = 'PRIORITY'
		AND ROWNUM < 2;

	userlog("sqlca.sqlcode near SELECT PARMVAL:%d",sqlca.sqlcode);

	if(NO_DATA_FOUND)
	{
		hv_priority_days_ind = -1;
	}

	if(!(NO_DATA_FOUND) && (SQLCODE != 0))
	{
		strcpy(prog_log.remarks, "change_appl_status : Service failed due to SELECT_ERROR");
		sprintf(excep_log.error_msg, "change_appl_status : change_appl_status : selecting days for priority from SYS_CONFIG_PARAMS failed %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	userlog("sqlca.sqlcode:%d",sqlca.sqlcode);
	if(hv_priority_days_ind == -1)
		priority_days = 1;
	else
	{
		setnull(hv_priority_days);
		priority_days = atoi((char *)hv_priority_days.arr);
	}

		EXEC SQL UPDATE APPLICATION 
				 SET APPLSTAT = :application_status:application_status_ind,
				 APPLREMARKS = NVL(:applremarks:applremarks_ind, APPLREMARKS),
				 SSCBRANCHCODE = DECODE(:hv_gqd_branch_code_ind, -1, SSCBRANCHCODE, :hv_gqd_branch_code:hv_gqd_branch_code_ind),
				 TIMESTAMP = SYSDATE,
				 USERID = :userid:userid_ind,
				 WSID = :wsid
				// APPLPRIORITY = 1,  // Commented on 31/01/2007 for express card.
				// CARDCOLLDATE = (SYSDATE + :priority_days)  // commented on 07/09/2007
				 WHERE APPLID = :application_id:application_id_ind;

		userlog("near UPDATE APPLICATION sqlca.sqlcode:%d",sqlca.sqlcode);

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"change_appl_status : Service failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status : change_appl_status : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);

			return UPDATE_ERROR;
		}
	/*}*/

    // This code is added on 10/07/2017 for CR 327 Release 3.35
	// Need to update applpriority to 2 for those applications whose collcenter is putrajaya
	// and those applications approved by GQD

		// do this only for applstat in pending 1:n(A) or ready for production(D)
		if((status == 'A') || (status == 'D'))
		{
			EXEC SQL SELECT COLLCENTER INTO :collcenter FROM APPLICATION
				WHERE APPLID = :application_id:application_id_ind;

			if(SQLCODE)
			{
				strcpy(prog_log.remarks,"change_appl_status : SELECT COLLCENTER FROM APPLICATION failed");
				sprintf(excep_log.error_msg,"change_appl_status : SELECT COLLCENTER FROM APPLICATION failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return SELECT_ERROR;
			}

			userlog("change_appl_status : SELECT COLLCENTER FROM APPLICATION sqlca.sqlcode:%d",sqlca.sqlcode);
			userlog("change_appl_status : collcenter : %s",collcenter);

			EXEC SQL SELECT ICCOLORCODE INTO :iccolor FROM JPN_INFO
				WHERE KPTNO = (SELECT KPTNO FROM APPLICATION WHERE APPLID = :application_id:application_id_ind);

			if(SQLCODE)
			{
				strcpy(prog_log.remarks,"change_appl_status : SELECT ICCOLORCODE FROM JPN_INFO failed");
				sprintf(excep_log.error_msg,"change_appl_status : SELECT ICCOLORCODE FROM JPN_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return SELECT_ERROR;
			}

			userlog("change_appl_status : SELECT ICCOLORCODE FROM JPN_INFO sqlca.sqlcode:%d",sqlca.sqlcode);
			userlog("change_appl_status : ICCOLORCODE : %c",iccolor);

			if((strcmp(collcenter,"101002") == 0) && (iccolor == 'B'))
			{
				EXEC SQL UPDATE APPLICATION
					SET APPLPRIORITY = 2
					WHERE APPLID = :application_id:application_id_ind
					AND COLLCENTER = '101002'
					AND APPLSTAT IN ('A','D');

				if(SQLCODE)
				{
					strcpy(prog_log.remarks,"change_appl_status : UPDATE APPLICATION (APPLPRIORITY) failed");
					sprintf(excep_log.error_msg,"change_appl_status : UPDATE APPLICATION (APPLPRIORITY) failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;
					log_error(ctx);
					return UPDATE_ERROR;
				}

				userlog("change_appl_status : UPDATE APPLICATION (APPLPRIORITY) sqlca.sqlcode:%d",sqlca.sqlcode);
				userlog("change_appl_status : Applpriority updated to 2 successfully for collcenter 101002 for applid : %s",application_id);
			}
		} 
	// code end for CR 327 Release 3.35


	if(hv_gqd_branch_code[0] != '\0')
	{
		EXEC SQL UPDATE PROBL_RECORD 
				 SET ENQFLAG = 'N'
				 WHERE APPLID = :application_id:application_id_ind
				 AND PROBLSTAT = 'O';
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			strcpy(prog_log.remarks,"change_appl_status : UPDATE PROBL_RECORD failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status : UPDATE PROBL_RECORD FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}


		EXEC SQL DELETE FROM APPNT_PROBL_DATA
			WHERE APPLID = :application_id;

		if(SQLCODE && !(NO_DATA_FOUND))
		{
			strcpy(prog_log.remarks,"change_appl_status : DELETE APPNT_PROBL_DATA failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status : DELETE APPNT_PROBL_DAT FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return DELETE_ERROR;
		}

		EXEC SQL INSERT INTO APPNT_PROBL_DATA(
			APPLID, SSCBRANCHCODE, SENDFLAG, TIMESTAMP)
			VALUES(:application_id,:hv_gqd_branch_code,'N',SYSDATE);

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"change_appl_status : INSERT into APPNT_PROBL_DATA failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status : INSERT into APPNT_PROBL_DATA FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INSERT_ERROR;
		}

	}

		userlog("before return");

	return GMPC_GOOD;

}



/****************************************************************************/
/* Function name: update_bsk_inv    										*/
/* Description	: This function 			                            	*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int update_bsk_inv(HEADER_T header, char *bskremarks, void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	
	char remarks[NOTE_SIZE] = {0};
	varchar actremarks[NOTE_SIZE] = {0};	

	short application_id_ind = 0;	
	short actremarks_ind = 0;	

	
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int ret = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	

	if('\0' != header.application_id[0])
	{
		strcpy(application_id, header.application_id);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	strcpy(remarks,bskremarks);

	#ifdef DEBUG	
		userlog("SET_APPL_STAT_L3 (update_bsk_inv) bskremarks:%s:",bskremarks);
		userlog("SET_APPL_STAT_L3 (update_bsk_inv) remarks:%s:",remarks);
	#endif

	
	strcpy((char*)actremarks.arr, bskremarks);
	setlen(actremarks);
	setnull(actremarks);
	//actremarks.arr[actremarks.len] = '\0';

	
	#ifdef DEBUG
		userlog("SET_APPL_STAT_L3 (update_bsk_inv) application_id :%s:", application_id);	
		userlog("SET_APPL_STAT_L3 (update_bsk_inv) actremarks:%s:",actremarks.arr);
	#endif



		EXEC SQL UPDATE PROBL_RECORD
				 SET BSKRECD = 'I',
				 ACTREMARKS = :actremarks				 
				 WHERE APPLID = :application_id:application_id_ind
				 and PROBLREASONCODE = 'E0001';

		userlog("near UPDATE PROBL_RECORD sqlca.sqlcode:%d",sqlca.sqlcode);

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"update_bsk_inv : Service failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"update_bsk_inv : bsk flag : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);

			return UPDATE_ERROR;
		}
	
		userlog("before return");

	return GMPC_GOOD;

}



/*  IJPN */

/****************************************************************************/
/* Function name: change_appl_status_gqdssc									*/
/* Description	: This function 											*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int change_appl_status_gqdssc(HEADER_T header, char status, char *gqd_branch_code,PROB_RESULT_T *prob,int probno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char application_status='\0';
	varchar applremarks[REMARK_SIZE];
	char hv_gqd_branch_code[BRANCH_CODE_SIZE];
	varchar userid[USER_ID_SIZE];
	varchar wsid[WS_ID_SIZE];
	varchar hv_priority_days[20] = {0};
	int priority_days = 0;

	short application_id_ind = 0;
	short application_status_ind = 0;
	short applremarks_ind = -1;
	short hv_gqd_branch_code_ind = 0;
    short userid_ind = 0;
	short hv_priority_days_ind = 0;

	int count_appl = 0;
	int old_cardstat = 0;
	short int old_cardstat_ind = 0;
	//char kptno[KPT_SIZE];
	int version = 0;
	short int version_ind = 0;
	short int kptno_ind = 0;
	char  hvsscind='\0';
	short hvsscind_ind = 0;
	char  pre_appl_status='\0';

	char problem_status='\0';
	char problem_note[NOTE_SIZE];	
	int problem_no=0;
	
	short problem_status_ind = 0;
	short problem_note_ind = 0;
	short problem_no_ind = 0;
	char  hvbskrecd='\0';
	short hvbskrecd_ind = 0;

	
	//Added by Salmi Date:12th May, 2020  CRAPPL-  SKP002/CR/2020
	char gUser1[USER_ID_SIZE];
	varchar gUser1TimeStamp[DATE_TIME_SIZE];
	char gUser2[USER_ID_SIZE];
	varchar gUser2TimeStamp[DATE_TIME_SIZE];

	short gUser1_ind = -1;
	short gUser1TimeStamp_ind = -1;
	short gUser2_ind = -1;
	short gUser2TimeStamp_ind = -1;
	//Added by Salmi Date:12th May, 2020  CRAPPL-  SKP002/CR/2020-End

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;
	
	int ret = 0,i=0;
	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	

	if('\0' != header.application_id[0])
	{
		strcpy(application_id, header.application_id);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	if('\0' != header.user_id[0])
	{
		strcpy((char *)userid.arr, header.user_id);
		setlen(userid);
		userid_ind = 0;
	}
	else
	{
		strcpy((char *)userid.arr, "");
		userid_ind = -1;
	}

	strcpy((char *)wsid.arr, header.workstation_id);
	setlen(wsid);

	strcpy(hv_gqd_branch_code, gqd_branch_code);
	if(hv_gqd_branch_code[0] == '\0')
		hv_gqd_branch_code_ind = -1;	
	
	//strcpy((char *)applremarks.arr,"Application is reffered to GQD");
	strcpy((char *)applremarks.arr,"Permohonan tangguh ke GQD");
	setlen(applremarks);
	applremarks_ind = 0;
		

		/* Set the application status	*/
		application_status = status;
		application_status_ind = 0;
		
		EXEC SQL SELECT SSCIND INTO :hvsscind:hvsscind_ind
			FROM BRANCH_INFO
			WHERE BRANCHCODE = :hv_gqd_branch_code;


		if(hvsscind != '2')
			application_status = REFFERED_SSC;

		EXEC SQL SELECT  APPLSTAT INTO :pre_appl_status
			FROM APPLICATION 
			WHERE APPLID = :application_id;

		if(pre_appl_status != application_status)
		{
			if(GMPC_GOOD != (ret = insert_into_appl_history(header,ctx)))
			{
				return ret;
			}
		}

#ifdef DEBUG
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) application_id :%s:", application_id);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) userid :%s:", userid.arr);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) wsid :%s:", wsid.arr);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) application_status:%c:",application_status);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) gqd_branch_code:%s:",gqd_branch_code);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) hv_gqd_branch_code:%s:",hv_gqd_branch_code);
	userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) hv_gqd_branch_code_ind:%d:",hv_gqd_branch_code_ind);
#endif


	EXEC SQL UPDATE APPLICATION 
		 SET APPLSTAT = :application_status:application_status_ind,
		 APPLREMARKS = NVL(:applremarks:applremarks_ind, APPLREMARKS),
		 SSCBRANCHCODE = DECODE(:hv_gqd_branch_code_ind, -1, SSCBRANCHCODE, :hv_gqd_branch_code:hv_gqd_branch_code_ind),
		 TIMESTAMP = SYSDATE,
		 USERID = :userid:userid_ind,
		 WSID = :wsid				 
		 WHERE APPLID = :application_id:application_id_ind;

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"change_appl_status_gqdssc : Service failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status_gqdssc : change_appl_status : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}

		EXEC SQL DELETE FROM APPNT_PROBL_DATA
			WHERE APPLID = :application_id;

		if(SQLCODE)
		{
			userlog("change_appl_status_gqdssc : DELETE APPNT_PROBL_DATA failed due to ORA_ERROR : %s", SQLMSG);

			/* commenetd the following code on 16/09/05, since it shouldn't stop if there is no record to delete */
		//	strcpy(prog_log.remarks,"change_appl_status_gqdssc : DELETE APPNT_PROBL_DATA failed due to ORA_ERROR");
		//	sprintf(excep_log.error_msg,"change_appl_status_gqdssc : DELETE APPNT_PROBL_DAT FAILED : %s", SQLMSG);
		//	excep_log.termination_flag = YES;
		//	excep_log.severity = FATAL;
		//	log_error(ctx);
		//	return DELETE_ERROR;
		}
		userlog("Record deleted from APPNT_PROBL_DATA, and a record will be inserted now for %s",application_id);

		EXEC SQL INSERT INTO APPNT_PROBL_DATA(
			APPLID, SSCBRANCHCODE, SENDFLAG, TIMESTAMP)
			VALUES(:application_id,:hv_gqd_branch_code,'N',SYSDATE);
		
		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"change_appl_status_gqdssc : INSERT into APPNT_PROBL_DATA failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status_gqdssc : INSERT into APPNT_PROBL_DATA FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INSERT_ERROR;
		}

		hvbskrecd = prob->bskrecd;
			/* otherwise parse the buffer and close selected problems	*/
		for(i = 0; i < probno; i++)
		{
			problem_no = prob->problem_number;
			strcpy(problem_note,prob->note);

			problem_status = prob->prob_stat;
			//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020

			if (prob->gUser1 == '\0')
			{
				gUser1_ind = -1;
			}
			else
			{
				gUser1_ind = 0;
				strcpy(gUser1,prob->gUser1);
			}
			if(prob->gUser1TimeStamp[0] !='\0')
			{
				strcpy((char *)gUser1TimeStamp.arr, prob->gUser1TimeStamp);
				setlen(gUser1TimeStamp);
				gUser1TimeStamp_ind = 0;
			}
			else
			{
				strcpy((char *)gUser1TimeStamp.arr, "");
				gUser1TimeStamp_ind = -1;
			}
			if (prob->gUser2 == '\0')
			{
				gUser2_ind = -1;
			}
			else
			{
				gUser2_ind = 0;
				strcpy(gUser2,prob->gUser2);
			}
			if(prob->gUser2TimeStamp[0] !='\0')
			{
				strcpy((char *)gUser2TimeStamp.arr, prob->gUser2TimeStamp);
				setlen(gUser2TimeStamp);
				gUser2TimeStamp_ind = 0;
			}
			else
			{
				strcpy((char *)gUser2TimeStamp.arr, "");
				gUser2TimeStamp_ind = -1;
			}
			//Added by Salmi Date:12th May, 2020 New field for PROB_RESULT_T struct. CRAPPL-  SKP002/CR/2020-End

		#ifdef DEBUG
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) problem_status:%c:", problem_status);
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) prob->prob_stat:%c:", prob->prob_stat);
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) prob notes:%s:", problem_note);

			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) gUser1:%s:", gUser1);
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) gUser1TimeStamp:%s:", gUser1TimeStamp.arr);
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) gUser2:%s:", gUser2);
			userlog("SET_APPL_STAT_L3 :(change_appl_status_gqdssc) gUser2TimeStamp:%s:", gUser2TimeStamp.arr);
		#endif

			if (problem_note[0] == '\0')
			{
				problem_note_ind = -1;
			}
			else
			{
				problem_note_ind = 0;
			}

			if (problem_status == '\0')
			{
				problem_status_ind = -1;
			}
			else
			{
				problem_status_ind = 0;
			}
			

			EXEC SQL UPDATE PROBL_RECORD 
			 SET PROBLSTAT = :problem_status:problem_status_ind,
			 ACTREMARKS = :problem_note:problem_note_ind,
			 ACTDATETIME = SYSDATE,
			 ACTUSERID = :userid:userid_ind,
			 PROBLSOLVEDATE = SYSDATE,
			 BSKRECD = :hvbskrecd:hvbskrecd_ind,
			 ENQFLAG = 'N',
			 GUSER1 = :gUser1:gUser1_ind,
			 GUSER1TIMESTAMP = TO_DATE(:gUser1TimeStamp:gUser1TimeStamp_ind, 'DDMMYYYY HH24MISS'),
			 GUSER2 = :gUser2:gUser2_ind,
			 GUSER2TIMESTAMP = TO_DATE(:gUser2TimeStamp:gUser2TimeStamp_ind, 'DDMMYYYY HH24MISS')
			 WHERE APPLID = :application_id:application_id_ind
			 AND PROBLNO = :problem_no:problem_no_ind;
					 

			if(SQLCODE && !(NO_DATA_FOUND))
			{
				strcpy(prog_log.remarks,"change_appl_status_gqdssc : Service failed due to ORA_ERROR");
				sprintf(excep_log.error_msg,"change_appl_status_gqdssc : Service failed due to ORA_ERROR : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return UPDATE_ERROR;
			}

			/* Advance problem pointer	*/
			prob++;
		}


		if(SQLCODE && !(NO_DATA_FOUND))
		{
			strcpy(prog_log.remarks,"change_appl_status_gqdssc : UPDATE PROBL_RECORD failed due to ORA_ERROR");
			sprintf(excep_log.error_msg,"change_appl_status_gqdssc : UPDATE PROBL_RECORD FAILED : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return UPDATE_ERROR;
		}


	return GMPC_GOOD;
}


/* end IJPN */



/****************************************************************************/
/* Function name: fill_get_jpn_data_request_buffer							*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
/*int fill_get_jpn_data_request_buffer(GET_JPN_DATA_REQ_T *rq)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char kptno[KPT_SIZE];
	char idtype[ID_TYPE_SIZE];
	varchar idno[ID_SIZE];
	char sponsoridtype[ID_TYPE_SIZE];
	varchar sponsoridno[ID_SIZE];
	char applid[APP_ID_SIZE];
	int txntype = 0;

	short kptno_ind = 0;
	short idtype_ind = 0;
	short idno_ind = 0;
	short sponsoridtype_ind = 0;
	short sponsoridno_ind = 0;
	short applid_ind = 0;
	short txntype_ind = -1;

	int txntype1 = TXN_12YO, txntype2 = TXN_FT, txntype3 = TXN_CONV, txntype4 = TXN_REPL, txntype5 = TXN_CHIP_UPD;
	int txntype_issuance = TXN_ISSUE;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if(0 != rq->header.application_id)
	{
		strcpy(applid, rq->header.application_id);
		applid_ind = 0;
	}
	else
	{
		strcpy(applid, "");
		applid_ind = -1;
	}

	EXEC SQL
		SELECT B.TXNTYPE INTO :txntype:txntype_ind 
			FROM APPL_TXN A, TXN_CODE B
			WHERE A.APPLID = :applid AND A.TXNCODE = B.TXNCODE 
			AND B.TXNTYPE = :txntype_issuance  AND ROWNUM = 1 
			AND TXNCANCELCODE IS NULL;;

	//if(SQLCODE && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
		strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Failed to select txncode");
		sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer :Failed to select txncode: %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}
	else if(!NO_DATA_FOUND) 
	{
		if(txntype_ind != -1)
		{
			itoa(txntype, (char *)rq->trans_type, 10);
		}
		else
		{
			strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Failed to select txncode");
			sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer :Failed to select txncode: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_TXN_TYPE;
		}
	}
	else
	{
		EXEC SQL
			SELECT B.TXNTYPE INTO :txntype:txntype_ind 
			FROM APPL_TXN A, TXN_CODE B
			WHERE A.APPLID = :applid AND A.TXNCODE = B.TXNCODE 
			AND B.TXNTYPE IN (:txntype1, :txntype2, :txntype3, :txntype4, :txntype5)  AND ROWNUM = 1 
			AND TXNCANCELCODE IS NULL;

		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Failed to select txncode");
			sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer :Failed to select txncode: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}
		if(txntype_ind != -1)
		{
			itoa(txntype, (char *)rq->trans_type, 10);
		}
		else
		{
			strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Failed to select txncode");
			sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer :Failed to select txncode: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_TXN_TYPE;
		}

	}

	EXEC SQL SELECT KPTNO, IDTYPE, IDNO, SPONSORIDTYPE, SPONSORIDNO
			 INTO :kptno:kptno_ind, :idtype:idtype_ind, :idno:idno_ind,
			 :sponsoridtype:sponsoridtype_ind, :sponsoridno:sponsoridno_ind
			 FROM APPLICATION
			 WHERE APPLID = :applid:applid_ind;
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Service failed due to ORA_ERROR");
		sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer : fill_get_jpn_data_request_buffer : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	setnull(idno);
	setnull(sponsoridno);

	if(sponsoridtype_ind != -1)
	{
		strcpy(rq->data.sponsor_id, (char *)sponsoridno.arr);
		rq->data.sponsor_id_type = atoi(sponsoridtype);
	}

	if(0 == kptno_ind)
	{
		strcpy(rq->data.applicant_id, kptno);
		rq->data.applicant_id_type = ID_TYPE_KPT;
		return GMPC_GOOD;
	}
	else if(idtype_ind != -1)
	{
		if((atoi(idtype) == ID_TYPE_KPT) || (atoi(idtype) == ID_TYPE_TEMP)
			|| (atoi(idtype) == ID_TYPE_GMPC))
		{
			strcpy(rq->data.applicant_id, (char *)idno.arr);
			rq->data.applicant_id_type = atoi(idtype);
			return GMPC_GOOD;
		}
		else 
		{
			strcpy(prog_log.remarks,"fill_get_jpn_data_request_buffer : Invalid Id Type");
			sprintf(excep_log.error_msg,"fill_get_jpn_data_request_buffer : Invalid Id Type : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);

			return INVALID_ID_TYPE;
		}
	}

	return KPT_NO_NULL;
}
*/

/************************************************************************/
/* Function Name:insert_into_legacy_request		 						*/
/* Description	:inserts into legacy_request on jpn_update tpacall fails*/
/* Input		:CARD_ISSUANCE_REQ_T, new_applid,update_flag			*/   
/* Return Values:SUCCESS OR FAILURE										*/
/************************************************************************/
int insert_into_legacy_request(char flag, HEADER_T *header, char agency, int reqstat, int txnserno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06	
	EXEC SQL BEGIN DECLARE SECTION;
		int legreqstat;                 
//		char legreqdatetime[DATE_TIME_SIZE];
		char legreqflag;                    
		char checkagency;                   
		char serviceid[SERVICE_ID_SIZE];     
		char applid[APP_ID_SIZE];           
		varchar userid[USER_ID_SIZE];
		char branchcode[BRANCH_CODE_SIZE];
		int txn_ser_no = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if(reqstat != 0)
	{
		legreqstat = reqstat;
	}
	else
	{
		legreqstat = REQ_NOT_SENT;
	}

//	strcpy(legreqdatetime,get_date_time());
	legreqflag = flag;
	checkagency = agency;
	txn_ser_no = txnserno;

	if (agency == JPN_ID)
		_itoa(JPN_UPDATE_ID, serviceid, 10);
	else if (agency == JPJ_ID)
		_itoa(JPJ_UPDATE_ID, serviceid, 10);
	else if (agency == JIM_ID)
		_itoa(IMM_UPDATE_ID, serviceid, 10);
	else if (agency == PDRM_ID)
		_itoa(PDRM_UPDATE_ID, serviceid, 10);
	else if (agency == AFIS_ID)
		_itoa(AFIS_UPDATE_ID, serviceid, 10);


	strcpy(applid, header->application_id);

	strcpy((char *)userid.arr, header->user_id);
	setlen(userid);
	strcpy(branchcode, header->branch_code);
	

#ifdef DEBUG
		userlog("insert_into_legacy_request:applid :%s", applid);
		userlog("insert_into_legacy_request:gscno :%s", branchcode);
		userlog("insert_into_legacy_request:userid :%s", userid.arr);
		userlog("insert_into_legacy_request:requeststat :%d", legreqstat);
//		userlog("insert_into_legacy_request:requestdate :%s", legreqdatetime);
		userlog("insert_into_legacy_request:checkagency :%c", checkagency);
		userlog("insert_into_legacy_request:requestflag :%c", legreqflag);
		userlog("insert_into_legacy_request:serviceid :%s", serviceid);
		userlog("insert_into_legacy_request:txnserno :%d", txn_ser_no);
#endif


	
	SQLCODE = 0; /* resetting any previous error code */
	EXEC SQL 
		INSERT INTO IJPN_LEGACY_REQUEST(LEGREQMSGID, LEGREQSTAT,
		LEGREQDATETIME, LEGREQFLAG,CHECKAGENCY, SERVICEID, APPLID,
		USERID, BRANCHCODE, TXNSERNO)
		VALUES(MESSAGEID.NEXTVAL,:legreqstat,
		SYSDATE, :legreqflag, :checkagency, :serviceid, :applid,
		:userid, :branchcode, :txn_ser_no);

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);
	if(SQLCODE)
	{

		strcpy(prog_log.remarks,"insert_into_legacy_request : insert_into_legacy_request failed");
		sprintf(excep_log.error_msg,"insert_into_legacy_request : insert_into_legacy_request failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return INSERT_ERROR;
	}
	else
	{
		return GMPC_GOOD;
	}

}


/*******************************************************************************/
/* Function Name:check_jpj_info			 							   	   */
/* Description	:Checks if the record is already present in JPJ_INFO table*/
/* Input		:new_applid													   */   
/* Return Values:SUCCESS/EXISTS/SELECT_ERROR							   */
/*******************************************************************************/
int check_jpj_info(char *kpt_no, char *appl_id, int *jpj_info_flag,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char kptno[KPT_SIZE];
		char applid[APP_ID_SIZE];
		varchar agencyonchip[AGENCY_ON_CHIP_SIZE];
		short int agencyonchip_ind = -1;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(kptno, kpt_no);
	strcpy(applid, appl_id);

	EXEC SQL
		SELECT AGENCYONCHIP INTO :agencyonchip:agencyonchip_ind 
		FROM CARD_STATUS
		WHERE KPTNO = :kptno AND 
		APPLID = :applid AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO)
		FROM CARD_STATUS WHERE KPTNO =:kptno AND 
		APPLID = :applid);
	
	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);
	
	if(NO_DATA_FOUND)
	{
		return GMPC_GOOD;
	}
	else if(SQLCODE)
	{
		strcpy(prog_log.remarks,"check_jpj_info :check_jpj_info failed ");
		sprintf(excep_log.error_msg,"check_jpj_info :check_jpj_info failed: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return SELECT_ERROR;
	}

	if(agencyonchip_ind == -1)
		return GMPC_GOOD;
	else
	{
		setnull(agencyonchip);
		
		if(agencyonchip.arr[JPJ_ID - '0'] == '1')
			*jpj_info_flag = 1;
	}
	
	return GMPC_GOOD;
}

/*******************************************************************************/
/* Function Name:check_imm_info		 							   	   */
/* Description	:Checks if the record is already present in IMM_INFO table*/
/* Input		:new_applid													   */   
/* Return Values:GMPC_GOOD / GMPC_BAD 							   */
/*******************************************************************************/
int check_imm_info(char *kpt_no, char *appl_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char kptno[KPT_SIZE];
		char applid[APP_ID_SIZE];
		varchar agencyonchip[AGENCY_ON_CHIP_SIZE];
		short int agencyonchip_ind = -1;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(kptno, kpt_no);
	strcpy(applid, appl_id);

	EXEC SQL
		SELECT AGENCYONCHIP INTO :agencyonchip:agencyonchip_ind 
		FROM CARD_STATUS
		WHERE KPTNO = :kptno AND 
		APPLID = :applid AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO)
		FROM CARD_STATUS WHERE KPTNO =:kptno AND 
		APPLID = :applid);
	
	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"check_imm_info :check_imm_info failed ");
		sprintf(excep_log.error_msg,"check_imm_info :check_imm_info failed: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return SELECT_ERROR;
	}

	if(agencyonchip_ind == -1)
		return SUCCESS;
	else
		setnull(agencyonchip);
		if(agencyonchip.arr[JIM_ID - '0'] == '1')
			return EXISTS;
		else
			return SUCCESS;
}

/*******************************************************************************/
/* Function Name:check_pdrm_info		 							   	   */
/* Description	:Checks if the record is already present in PDRM_INFO table*/
/* Input		:new_applid													   */   
/* Return Values:GMPC_GOOD / GMPC_BAD 							   */
/*******************************************************************************/
int check_pdrm_info(char *kpt_no, char *appl_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char kptno[KPT_SIZE];
		char applid[APP_ID_SIZE];
		varchar agencyonchip[AGENCY_ON_CHIP_SIZE];
		short int agencyonchip_ind = -1;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(kptno, kpt_no);
	strcpy(applid, appl_id);

	EXEC SQL
		SELECT AGENCYONCHIP INTO :agencyonchip:agencyonchip_ind 
		FROM CARD_STATUS
		WHERE KPTNO = :kptno AND 
		APPLID = :applid AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO)
		FROM CARD_STATUS WHERE KPTNO =:kptno AND 
		APPLID = :applid);
	
	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"check_pdrm_info :check_pdrm_info failed ");
		sprintf(excep_log.error_msg,"check_pdrm_info :check_pdrm_info failed: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return SELECT_ERROR;
	}

	if(agencyonchip_ind == -1)
		return SUCCESS;
	else
		setnull(agencyonchip);
		if(agencyonchip.arr[PDRM_ID - '0'] == '1')
			return EXISTS;
		else
			return SUCCESS;
}


/*********************************************************/
/* Function Name:get_kpt_no		 						 */
/* Description	:Gets KPT no for the given application ID*/
/* Input		:applid	, address of kptno				 */   
/* Return Values:GMPC_GOOD / GMPC_BAD /		 */
/*********************************************************/
int get_kpt_no(char appl_id[APP_ID_SIZE], char *kptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char kpt_no[KPT_SIZE];
		short int kpt_no_ind = -1;
		char applid[APP_ID_SIZE];
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
#ifdef DEBUG
	userlog("get_kpt_no :application_id :%s:", appl_id);
#endif

	strcpy(applid,appl_id); 

		//EXEC SQL
		//SELECT KPTNO INTO :kpt_no:kpt_no_ind FROM APPLICATION // commented on 10/05/2007
		EXEC SQL
		SELECT DECODE(IDTYPE,'90',IDNO,'95',IDNO,KPTNO) INTO :kpt_no:kpt_no_ind FROM APPLICATION
		WHERE APPLID = :applid;
		

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE)
	{

		strcpy(prog_log.remarks,"get_kpt_no : get_kpt_no failed");
		sprintf(excep_log.error_msg,"get_kpt_no : get_kpt_no failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return SELECT_ERROR;
	}

	if(kpt_no_ind == -1)
	{
		kpt_no[0] = '\0';
		strcpy(kptno, kpt_no);
#ifdef DEBUG
	userlog("get_kpt_no: failed as null:kptno :%s:", kptno);
#endif

		return SELECT_ERROR;
	}
	else
	{
#ifdef DEBUG
	userlog("get_kpt_no: success:kptno :%s:", kpt_no);
#endif
		strcpy(kptno, kpt_no);
		return GMPC_GOOD;
	}

}


/****************************************************************************/
/* Function name: insert_into_appl_history									*/
/* Description	: This function 											*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int insert_into_appl_history(HEADER_T header,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char applid[APP_ID_SIZE];
	char applstat; 
	char kptno[KPT_SIZE];
	char branchcode[GSC_SIZE]; 
	varchar userid[USER_ID_SIZE]; 
	varchar wsid[WS_ID_SIZE]; 
	char timestamp[DATE_TIME_SIZE]; 
	char appldate[DATE_TIME_SIZE];
	int procserno;

	short int applid_ind = 0;
	short int applstat_ind = 0; 
	short int kptno_ind = 0; 
	short int branchcode_ind = 0; 
	short int userid_ind = 0; 
	short int wsid_ind = 0; 
	short int timestamp_ind = 0; 
	short int appldate_ind = 0; 
	short int procserno_ind = 0; 

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int ret_val = 0;
	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	

	if(header.application_id[0] == '\0')	
	{	
		applid_ind = -1;	
	}	
	else 	
	{	
		strcpy(applid, header.application_id);	
	}
	
	EXEC SQL 
		SELECT APPLSTAT, TO_CHAR(APPLDATE, 'DDMMYYYY HH24MISS'), 
		PROCSERNO, USERID, TO_CHAR(TIMESTAMP,'DDMMYYYY HH24MISS'), WSID
		INTO 
		:applstat:applstat_ind, :appldate:appldate_ind,
		:procserno:procserno_ind, :userid:userid_ind, :timestamp:timestamp_ind,
		:wsid:wsid_ind
		FROM APPLICATION WHERE 
		APPLID = :applid:applid_ind;
	
	if(SQLCODE != 0)
	{
		strcpy(prog_log.remarks,"insert_into_appl_history : failed to select from APPLICATION table");
		sprintf(excep_log.error_msg,"insert_into_appl_history : failed to select from APPLICATION table: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return SELECT_ERROR;
	}
	
	
	if((ret_val = get_kpt_no(header.application_id, kptno,ctx)) != GMPC_GOOD)
	{
		return ret_val;
	}

	if(kptno[0] == '\0')	
	{	
		kptno_ind = -1;	
	}	

	if(header.branch_code[0] == '\0')	
	{	
		branchcode_ind = -1;	
	}	
	else 	
	{	
		strcpy(branchcode, header.branch_code);	
	}	
	 
/*  Commented this code on 19/11/2008 to insert values from application into appl_history
for Release 3.15

	if(header.user_id[0] == '\0')	
	{	
		userid_ind = -1;	
	}	
	else 	
	{	
		strcpy((char *)userid.arr, header.user_id);	
		setlen(userid);
	}	
	 
	if(header.workstation_id[0] == '\0')	
	{	
		wsid_ind = -1;	
	}	
	else 	
	{	
		strcpy((char *)wsid.arr, header.workstation_id);	
		setlen(wsid);
	}
*/	

	if(userid_ind == 0)	
	{	
		userid.arr[userid.len] = '\0';
	}	

	if(wsid_ind == 0)	
	{	
		wsid.arr[wsid.len] = '\0';
	}

	#ifdef DEBUG
		userlog("insert_into_appl_history, before insert into appl_history");		
		userlog("insert_into_appl_history, userid:%s:",userid.arr);
		userlog("insert_into_appl_history, wsid:%s:",wsid.arr);
	#endif

	EXEC SQL 
		INSERT INTO APPL_HISTORY(APPLID, PROCSERNO, APPLDATE, APPLSTAT,
		KPTNO, BRANCHCODE, USERID, WSID, TIMESTAMP)
		VALUES(:applid:applid_ind, 
		:procserno:procserno_ind,
		TO_DATE(:appldate:appldate_ind, 'DDMMYYYY HH24MISS'),
		:applstat:applstat_ind, 
		:kptno:kptno_ind, 
		:branchcode:branchcode_ind, 
		:userid:userid_ind,
		:wsid:wsid_ind, 
		DECODE(:timestamp_ind,-1,SYSDATE,0,TO_DATE(:timestamp,'DDMMYYYY HH24MISS')
		));

	if(SQLCODE != 0)
	{
		strcpy(prog_log.remarks,"insert_into_appl_history : failed to insert into appl_history table");
		sprintf(excep_log.error_msg,"insert_into_appl_history : failed to insert into appl_history table: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return INSERT_ERROR;
	}

	return GMPC_GOOD;

}


/****************************************************************************/
/* Function name: get_previous_appl_status										*/
/* Description	: This function											*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int get_previous_appl_status(char *appl_id, char *status,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char applid[APP_ID_SIZE];
	char applstat='\0'; 
	char timestamp[DATE_TIME_SIZE];
//	char timestamp1[DATE_TIME_SIZE];

	short int applid_ind = 0;
	short int applstat_ind = 0; 
	short int timestamp_ind = 0; 
//	short int timestamp1_ind = 0; 
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(applid, appl_id);


	EXEC SQL 
		SELECT DISTINCT APPLSTAT, TO_CHAR(TIMESTAMP,'DDMMYYYY HH24MISS')
		INTO :applstat:applstat_ind, :timestamp:timestamp_ind
		FROM APPL_HISTORY
		WHERE APPLID = :applid 
		AND TIMESTAMP = (SELECT MAX(TIMESTAMP)
						 FROM APPL_HISTORY
						 WHERE APPLID = :applid
						 AND APPLSTAT IN ('A', 'D', 'M', 'X', 'Q'))
		AND	APPLSTAT IN ('A', 'D', 'M', 'X', 'Q')
						 /* applstat check added on 12/11/2001		*/																					
						 /* bcz there could be difference in clocks	*/																						
						 /* at GSC and GSCB. In such case wrong prev */																						
						 /* status might be fetched. Expected values */																						
						 /* of prev stat - 'A', 'D', 'M', 'X' and 'Q'*/ 
		AND ROWNUM = 1;

	if(SQLCODE != 0)
	{
		strcpy(prog_log.remarks,"get_previous_appl_status : failed to select applstat from appl_history table");
		sprintf(excep_log.error_msg,"get_previous_appl_status : failed to select applstat appl_history table: %s",SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
	
		return SELECT_ERROR;
	}
#ifdef DEBUG
	userlog("get_previous_appl_status :applstat :%c:", applstat);
#endif


	*status = applstat;

	return SUCCESS;
}


/****************************************************************************/
/* Function name: update_appl_table										*/
/* Description	: This function											*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int update_appl_table(char *application_id, char *kptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char kpt_no[KPT_SIZE] = {0};
		char old_kptno[KPT_SIZE] = {0};
		short int kpt_no_ind = 0;
		short int old_kptno_ind = -1;
		char applid[APP_ID_SIZE];
		int kpt_count=0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(applid,application_id); 
	strcpy(kpt_no,kptno); 

//
/*	EXEC SQL
		SELECT KPTNO INTO :old_kptno:old_kptno_ind FROM APPLICATION
		WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		sqlmsg[0] = '\0';
	
	strcpy(sqlmsg, SQLMSG);
	if(SQLCODE&& !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table : update application failed");
		sprintf(excep_log.error_msg,"update_appl_table : update application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return SELECT_ERROR;
	}
*/


// FOR GENKPT SERVICE TO UPDATE DUMMAY KPT TO OLDKPT IN APPLICATION TABLE

		EXEC SQL
		SELECT KPTNO INTO :old_kptno:old_kptno_ind FROM APPNT_JPN_INFO
		WHERE APPLID = :applid AND (KPTNO LIKE 'D%');

	sqlmsg[0] = '\0';	
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE&& !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table : update application failed");
		sprintf(excep_log.error_msg,"update_appl_table : update application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return SELECT_ERROR;
	}


/*commented on 09/04/2003 dead lock problem*/
	if(old_kptno_ind != -1)
	{
		
	/* here to check for no record solution duplicate application for same kpt number */
    /* requirement from vasanth changed on 01/042004 by shiva.p */
		EXEC SQL
		SELECT COUNT(*) INTO :kpt_count FROM APPLICATION
		WHERE KPTNO = :kpt_no AND APPLSTAT NOT IN('T','H','G','Q');

		if(kpt_count >0 )
		{
			strcpy(prog_log.remarks,"update_appl_table : kptno exists for different application");
			sprintf(excep_log.error_msg,"update_appl_table : kptno exists for different application");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);

   			return DUPLICATE_KPTNO_EXISTS;

		}

		if(SQLCODE)
		{

			strcpy(prog_log.remarks,"update_appl_table : Error while selecting count from application");
			sprintf(excep_log.error_msg,"update_appl_table : Error while selecting count from application : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);

   			return SELECT_ERROR;
		}

		EXEC SQL
			UPDATE APPL_DOC_SERNO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPL_DOC_SERNO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPL_DOC_SERNO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPL_HISTORY SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPL_HISTORY failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPL_HISTORY failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPL_MISSED_OPEX SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPL_MISSED_OPEX failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPL_MISSED_OPEX failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPNT_IMM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_IMM_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_IMM_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPNT_JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_JPJ_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPNT_JPN_IMG SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_JPN_IMG failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_JPN_IMG failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPNT_JPN_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_JPN_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_JPN_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		
		EXEC SQL
			UPDATE APPNT_PDRM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_PDRM_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_PDRM_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE APPNT_PDRM_SUMMONS SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update APPNT_PDRM_SUMMONS failed");
			sprintf(excep_log.error_msg,"update_appl_table : update APPNT_PDRM_SUMMONS failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		

		EXEC SQL
			UPDATE CARD_STATUS SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND) && !(RECORD_EXISTS))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update CARD_STATUS failed");
			sprintf(excep_log.error_msg,"update_appl_table : update CARD_STATUS failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		} else if(RECORD_EXISTS)
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update CARD_STATUS failed");
			sprintf(excep_log.error_msg,"update_appl_table : update CARD_STATUS failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return KPT_EXISTS;
			
		}
		
		EXEC SQL
			UPDATE CARD_HISTORY SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update CARD_HISTORY failed");
			sprintf(excep_log.error_msg,"update_appl_table : update CARD_HISTORY failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		/*EXEC SQL
			UPDATE DEBTOR_LIST SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update DEBTOR_LIST failed");
			sprintf(excep_log.error_msg,"update_appl_table : update DEBTOR_LIST failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE DISPUTED_JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update DISPUTED_JPJ_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update DISPUTED_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}*/
		
		EXEC SQL
			UPDATE IMM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update IMM_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update IMM_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_BLACKLIST SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_BLACKLIST failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_BLACKLIST failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_CANCEL SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_CANCEL failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_CANCEL failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_ENDORSE SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_ENDORSE failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_ENDORSE failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_REVOKE SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_REVOKE failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_REVOKE failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_SUSPENS SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_SUSPENS failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_SUSPENS failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		EXEC SQL
			UPDATE JPJ_LIC_TEST_INFO SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update JPJ_LIC_TEST_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPJ_LIC_TEST_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		
		userlog("---kpt_no : %s",kpt_no);
		userlog("---old_kptno : %s",old_kptno);


		EXEC SQL DELETE FROM JPN_INFO WHERE KPTNO = :old_kptno:old_kptno_ind;

/*		//EXEC SQL
		//	UPDATE JPN_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		//	WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			EXEC SQL DELETE FROM JPN_INFO WHERE KPTNO = :old_kptno:old_kptno_ind;

			strcpy(prog_log.remarks,"update_appl_table : update JPN_INFO failed");
			sprintf(excep_log.error_msg,"update_appl_table : update JPN_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			
			//return UPDATE_ERROR;
		}
*/		
		/*commented on 09/04/2003 dead lock problem */
		
		/*
		EXEC SQL
		UPDATE PDRM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno:old_kptno_ind;
		
		  sqlmsg[0] = '\0';
		  strcpy(sqlmsg, SQLMSG);
		  
			if(SQLCODE && !(NO_DATA_FOUND))
			{
			
			  strcpy(prog_log.remarks,"update_appl_table : update PDRM_INFO failed");
			  sprintf(excep_log.error_msg,"update_appl_table : update PDRM_INFO failed : %s", SQLMSG);
			  excep_log.termination_flag = YES;
			  excep_log.severity = FATAL;
			  log_error(ctx);
			  
				return UPDATE_ERROR;
				}
		*/
		
		EXEC SQL
			UPDATE APPLICATION SET KPTNO = :kpt_no:kpt_no_ind 
			WHERE APPLID = :applid AND (KPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update application failed");
			sprintf(excep_log.error_msg,"update_appl_table : update application failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}
		EXEC SQL
			UPDATE APPLICATION SET OLDKPTNO = ''
			WHERE APPLID = :applid AND (OLDKPTNO LIKE 'D%');
		
		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND))
		{
			
			strcpy(prog_log.remarks,"update_appl_table : update application failed");
			sprintf(excep_log.error_msg,"update_appl_table : update application failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}

	}

	return GMPC_GOOD;
}

/****************************************************************************/
/* Function name: update_cancelcode										*/
/* Description	: This function 				*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int update_cancelcode(char *applid, char *cancel_code,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE];
	char appl_cancelcode[CANCEL_CODE_SIZE];

	short application_id_ind = 0;
	short appl_cancelcode_ind = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if('\0' != applid[0])
	{
		strcpy(application_id, applid);
		application_id_ind = 0;
	}
	else
	{
		strcpy(application_id, "");
		application_id_ind = -1;
	}

	if('\0' != cancel_code[0])
	{
		strcpy(appl_cancelcode, cancel_code);
		appl_cancelcode_ind = 0;
	}
	else
	{
		strcpy(appl_cancelcode, "");
		appl_cancelcode_ind = -1;
	}

#ifdef DEBUG
	userlog("update_cancelcode :application_id :%s:", application_id);
	userlog("update_cancelcode :appl_cancelcode:%s:",appl_cancelcode);
#endif

	EXEC SQL UPDATE APPLICATION 
		SET APPLCANCELCODE = :appl_cancelcode:appl_cancelcode_ind
			 WHERE APPLID = :application_id:application_id_ind;
	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"update_cancelcode : Service failed due to UPDATE_ERROR");
		sprintf(excep_log.error_msg,"update_cancelcode : change_appl_status : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return UPDATE_ERROR;
	}

	userlog("update_cancelcode finish"); //added by samsuri on 23 mar 2022
	return GMPC_GOOD;
}

int update_application(char *applid, char *aprvldoc,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE]={0};
	char aprvldocno[APPROV_DOC_NO_SIZE]={0};
	
	short application_id_ind = 0;
	short aprvldocno_ind = 0;
	
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN


	#ifdef DEBUG
		userlog("update_application :applid :%s:", applid);
		userlog("update_application :aprvldoc:%s:",aprvldoc);
	#endif

	strcpy(application_id,applid);
	strcpy(aprvldocno,aprvldoc);

	#ifdef DEBUG
		userlog("update_application :application_id :%s:", application_id);
		userlog("update_application :aprvldocno:%s:",aprvldocno);
	#endif

	EXEC SQL UPDATE APPLICATION 
		SET   APRVLDOCNO  = :aprvldocno:aprvldocno_ind,
		      NAMEREGDATE = SYSDATE
		WHERE APPLID = :application_id:application_id_ind;

	userlog("update_application : sqlca.sqlcode & sqlmsg : %d, %s",sqlca.sqlcode,SQLMSG);

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"update_application : Service failed due to UPDATE_ERROR");
		sprintf(excep_log.error_msg,"update_application : updating application with aprvldocno failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return UPDATE_ERROR;
	}

	return GMPC_GOOD;


}

/********************************************************************/
/* Function name: check_appl_status									*/
/* Description	: This function 									*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/
int check_appl_status(char *applid, int appl_stat_flag,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char application_id[APP_ID_SIZE];
		char applstat;
		//char enqflag; commented for IJPN 
		short application_id_ind = 0;
		short applstat_ind = 0;
		//short enqflag_ind = 0; commented for IJPN
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	if('\0' != applid[0])
	{
		strcpy(application_id, applid);
		application_id_ind = 0;
	}
	else
	{
		strcpy(prog_log.remarks,"check_appl_status : Applid is NULL");
		sprintf(excep_log.error_msg,"check_appl_status : Applid is NULL");
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return APP_ID_NULL;
	}

	EXEC SQL 
		SELECT APPLSTAT INTO :applstat:applstat_ind FROM APPLICATION 
		WHERE APPLID = :application_id;

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"check_appl_status : Service failed due to UPDATE_ERROR");
		sprintf(excep_log.error_msg,"check_appl_status : check_appl_status failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	if(appl_stat_flag == INITIAL_CHK)
	{

		// applstat = '9' means Express send 
		// applstat is added by kasi on 29/01/2007  for Express Card
		// applstat = '9' has been removed on 26/08/2013 for CR 209
		if(applstat == REFFERED_GQD || applstat == REFFERED_SSC || applstat == PENDING_CANCEL ||
			applstat == READY_PROD || applstat == PENDING_1N || applstat == FAST_LANE_COMPLETE)
		{
			return VALID_APPLSTAT;
		}
		else
		{
			return GMPC_GOOD;
		}
	}
	else //if(appl_stat_flag == TO_BE_CAN_CHK)
	{
		if(applstat == SENT_PROD || applstat == PRODUCED || 
			applstat == ACTIVE || applstat == TERMINATED_GSC ||
			applstat == TERMINATED_GSCB)
		{
			strcpy(prog_log.remarks,"check_appl_status : Invalid Applstat");
			sprintf(excep_log.error_msg,"check_appl_status : Invalid Applstat: %c", applstat);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INVALID_APPL_STAT;
		}
/*	commented for IJPN on 25th Mar 2005 for IJPN 
		as this check is not required now

		else if(applstat == REFFERED_GQD)
		{
			/* Changed by Sushil on 30/04/2003 to return only 1 row from the table 
			EXEC SQL SELECT  'X' INTO :enqflag:enqflag_ind FROM PROBL_RECORD WHERE APPLID = :application_id
				AND ENQFLAG = 'Y' AND ROWNUM = 1;
			

			EXEC SQL SELECT  'X' INTO :enqflag:enqflag_ind FROM PROBL_RECORD WHERE APPLID = :application_id
				AND ENQFLAG = 'Y' AND ROWNUM = 1;

			if(sqlca.sqlcode == 1403)
			{
				return GMPC_GOOD;
			}
			else if(SQLCODE)
			{
				strcpy(prog_log.remarks,"check_appl_status : Service failed due to SELECT_ERROR");
				sprintf(excep_log.error_msg,"check_appl_status : check_appl_status failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return SELECT_ERROR;				
			}
			else
			{
				strcpy(prog_log.remarks,"check_appl_status : Invalid Applstat");
				sprintf(excep_log.error_msg,"check_appl_status : Invalid Applstat with enqflag: %", applstat);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return INVALID_APPL_STAT;
			}
		}
end IJPN */
		else
		{
			return GMPC_GOOD;
		}
	}

}




/********************************************************************/
/* Function name: check_disputed_data								*/
/* Description	: This function 									*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/
int check_disputed_data(char *applid, int * disputed_flag,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char application_id[APP_ID_SIZE];
		int disp_count = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(application_id, applid);

	EXEC SQL
		SELECT COUNT(*) INTO :disp_count FROM DISPUTED_DATA 
		WHERE APPLID = :application_id;

	//if(SQLCODE && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
		strcpy(prog_log.remarks,"check_disputed_data : check_disputed_data failed");
		sprintf(excep_log.error_msg,"check_disputed_data : check_disputed_data failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	if(disp_count == 0)
	{
		*disputed_flag = 0;
	}else
	{
		*disputed_flag = 1;
	}

#ifdef DEBUG
	userlog("check_disputed_data :disputed_flag %d", *disputed_flag);
#endif


	return GMPC_GOOD;
}

/********************************************************************/
/* Function name: delete_card_status								*/
/* Description	: This function deletes the entry from the			*/
/*				  card_status and card_history table				*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/

int delete_card_status(char *application_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char applid[APP_ID_SIZE];
	char kptno[KPT_SIZE];
	int cardversion;
	int cardstat = 0;
	int cardstat_active = ACTIVE;
	int cardstat_lost = LOST;
	 
	char txncode[TRANSACTION_CODE_SIZE];
	char exists = 0;
	short int applid_ind = 0;
	short int kptno_ind = 0; 
	short int cardversion_ind = 0; 
	short int cardstat_ind = 0;

	//Added by Salmi Date: 29th May,2020 For R20 problem
	char appl_id[APP_ID_SIZE];
	int cardstat_retained_repl = RETAINED_REPLACE;  
	char applstat_active = ISSUED;  
	short int appl_id_ind = 0; 
	short int applstat_ind = 0;

	int lost_flag = 0;
	//Added by Salmi Date: 29th May,2020 For R20 problem-End

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(applid, application_id);

	EXEC SQL SELECT KPTNO, CARDVERSIONNO, CARDSTAT
			 INTO :kptno:kptno_ind, :cardversion:cardversion_ind, :cardstat:cardstat_ind
			 FROM CARD_STATUS
			 WHERE APPLID = :applid
			 AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS WHERE APPLID = :applid);

	if(SQLCODE)
	{
	#ifdef DEBUG
			userlog("delete_card_status : select from card_status failed sqlmsg %s", SQLMSG);
	#endif
			
/*		sprintf(excep_log.error_msg,"delete_card_status : select from card_status failed sqlmsg %s", SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;
		log_error(ctx);
*/		return GMPC_GOOD;

	}
	#ifdef DEBUG
			userlog("delete_card_status : kptno from card_status %s", kptno);
			userlog("delete_card_status : cardversionno from card_status %d", cardversion);
			userlog("delete_card_status : cardstat from card_status %d", cardstat);
			userlog("delete_card_status : cardstat_ind %d", cardstat_ind);
	#endif

	//remarked by samsuri on 01 mar 2022 SKP005/PM/2021
	//if((cardstat_ind == -1) || (cardstat == PRODUCTION ) || (cardstat == PERSONALISED) || (cardstat == SENT_GSC))
	//added by samsuri on 01 mar 2022 SKP005/PM/2021
	if((cardstat_ind == -1) || (cardstat == PRODUCTION ) || (cardstat == PERSONALISED) || (cardstat == SENT_GSC) || 
	(cardstat == REJECTED_PC) || (cardstat == DEFECT_CHIP))
	{

		EXEC SQL DELETE 
				 FROM CARD_STATUS
				 WHERE APPLID = :applid
				 AND KPTNO = :kptno:kptno_ind
				 AND CARDVERSIONNO = :cardversion:cardversion_ind;
		
		if(SQLCODE)
		{
	#ifdef DEBUG
			userlog("delete_card_status : delete from card_status failed sqlmsg %s", SQLMSG);
	#endif
/*			sprintf(excep_log.error_msg,"delete_card_status : delete from card_status failed sqlmsg %s", SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;
			log_error(ctx);
*/			
			return GMPC_GOOD;

		}
		else
		{

			//Added by Salmi, Date : 10 Sept 2020, add flag for Lost transaction
			_itoa(TXN_REPL_LOSS,txncode,10);

			EXEC SQL SELECT 'X' INTO :exists
			   	FROM APPL_TXN
			    WHERE APPLID = :applid
		        AND TXNCODE = :txncode
		    	AND TXNCANCELCODE IS NULL;

			#ifdef DEBUG
				userlog("delete_card_status : SQLCODE [%d]", SQLCODE);
			#endif
			if(SQLCODE)
			{	
				lost_flag = 0; 
			}
			else
			{
				lost_flag = 1;
			}
	#ifdef DEBUG
			userlog("delete_card_status : Applid %s successfully deleted from card_status table, Loss flag[%d]", applid, lost_flag);
			userlog("delete_card_status : Applid %s   kptno[%s] cardversion[%d]", applid , kptno ,cardversion);
	#endif
			if(lost_flag == 0)
			{
			//Added by Salmi, Date : 10 Sept 2020, add flag for Lost transaction

			EXEC SQL DELETE 
					 FROM CARD_HISTORY
					 WHERE KPTNO = :kptno:kptno_ind
					 AND CARDVERSIONNO = :cardversion:cardversion_ind;
			if((SQLCODE) && !(NO_DATA_FOUND))
			{
		#ifdef DEBUG
				userlog("delete_card_status : delete from CARD_HISTORY failed sqlmsg %s", SQLMSG);
		#endif
/*				sprintf(excep_log.error_msg,"delete_card_status : delete from CARD_HISTORY failed sqlmsg %s", SQLMSG);
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
				
*/				return GMPC_GOOD;    

			}
			else
			{
		#ifdef DEBUG
				userlog("delete_card_status : Applid %s successfully deleted from CARD_HISTORY table", applid);
		#endif
			}

//Added by Salmi Date: 29th May,2020  To update previous KPT to R20
	#ifdef DEBUG
			userlog("delete_card_status : Applid %s select previous active card kptno %s applstat_active %c ", applid, kptno, applstat_active );
	#endif
			//select records from application table where max applid from application
			EXEC SQL select max(applid)
			 INTO :appl_id:appl_id_ind
			 FROM APPLICATION
			 WHERE kptno = :kptno:kptno_ind and applstat = :applstat_active:applstat_ind;
			 
			 if((SQLCODE) && !(NO_DATA_FOUND))
			{
		#ifdef DEBUG
			/*	userlog("delete_card_status : select from CARD_STATUS failed sqlmsg %s", SQLMSG);
				sprintf(excep_log.error_msg,"delete_card_status : select from CARD_STATUS failed sqlmsg %s", SQLMSG);
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);*/
			#ifdef DEBUG
				userlog("delete_card_status : Applid %s select previous active card failed", appl_id);
			#endif
				return GMPC_GOOD;
		#endif
			}
	#ifdef DEBUG
			userlog("delete_card_status : Applid %s update card status back to 16", appl_id);
	#endif
			EXEC SQL UPDATE CARD_STATUS
					 set cardstat =: cardstat_active
					 WHERE KPTNO = :kptno:kptno_ind
					 AND APPLID = :appl_id:appl_id_ind;
			if((SQLCODE) && !(NO_DATA_FOUND))
			{
		#ifdef DEBUG
/*				userlog("delete_card_status : Update CARD_STATUS failed sqlmsg %s", SQLMSG);
				sprintf(excep_log.error_msg,"delete_card_status : Update CARD_STATUS failed sqlmsg %s", SQLMSG);
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
	*/			
			#ifdef DEBUG
				userlog("delete_card_status : Applid %s update card_status failed", appl_id);
			#endif
				return GMPC_GOOD;
		#endif
			} 

			}
		}
//Added by Salmi Date: 29th May,2020  To update previous KPT to R20

	}

	/* Check if this is 'Replacement due to Loss' application.						*/

	/*

	_itoa(TXN_REPL_LOSS,txncode,10);

	EXEC SQL SELECT 'X' INTO :exists
			 FROM APPL_TXN
			 WHERE APPLID = :applid
			 AND TXNCODE = :txncode
			 AND TXNCANCELCODE IS NULL;

	#ifdef DEBUG
		userlog("delete_card_status : SQLCODE [%d]", SQLCODE);
	#endif
	if(SQLCODE)
	{
	Salmi Remark, Date 11 Sept 2020, move this checking earlier*/

	if(lost_flag == 0)
	{
		#ifdef DEBUG
				userlog("delete_card_status : Not a 'replacement due to loss' application!!");
		#endif
			///---
			//Added in Release 3.39 Bug-fix for Pelupusan application cancellation.
			#ifdef DEBUG
					userlog("Release 3.39: delete_card_status : Revert Card Status to from 'cardstat_retained_repl'(20) to 'Active'(16)-Start");
			#endif

			EXEC SQL SELECT CARDVERSIONNO, CARDSTAT 
				 INTO :cardversion:cardversion_ind, :cardstat:cardstat_ind
				 FROM CARD_STATUS
				 WHERE KPTNO= :kptno
				 AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS WHERE KPTNO= :kptno);

			if(SQLCODE)
			{
			#ifdef DEBUG
					userlog("delete_card_status : select from card_status failed sqlmsg %s", SQLMSG);
			#endif
					
		/*		sprintf(excep_log.error_msg,"delete_card_status : select from card_status failed sqlmsg %s", SQLMSG);
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
		*/		return GMPC_GOOD;

			}
			#ifdef DEBUG
					userlog("delete_card_status : kptno from PREV card_status %s", kptno);
					userlog("delete_card_status : cardversionno PREV from card_status %d", cardversion);
					userlog("delete_card_status : cardstat from PREV card_status %d", cardstat);
			#endif


			//added by samsuri on 01 mar 2022 SKP005/PM/2021 - START
			if(cardstat == REJECTED_PC || cardstat == DEFECT_CHIP)
			{
				userlog("delete_card_status : Restoring prev card status to R16 because REJECTED_PC");

				 EXEC SQL UPDATE CARD_STATUS
					SET CARDSTAT = :cardstat_active
					WHERE KPTNO = :kptno:kptno_ind
					AND CARDVERSIONNO = 
					(SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS WHERE KPTNO= :kptno AND CARDSTAT IN (14,17,20)); 
			}
			if(SQLCODE)
			{
				#ifdef DEBUG
						userlog("delete_card_status : Restoring prev card status to R16 because REJECTED_PC failed sqlmsg %s", SQLMSG);
				#endif
				sprintf(excep_log.error_msg,"delete_card_status : Restoring prev card status to R16 because REJECTED_PC failed sqlmsg %s", SQLMSG);
				excep_log.termination_flag = NO;
				excep_log.severity = NON_FATAL;
				log_error(ctx);
				
				return UPDATE_ERROR;
			}
			//added by samsuri on 01 mar 2022 SKP005/PM/2021 - FINISH


			if((cardstat_ind == -1) || (cardstat == RETAINED_REPLACE))
			{

				/* If yes, revert back the Card status of the previous version card to Active	*/
				/* EXEC SQL UPDATE CARD_STATUS
					SET CARDSTAT = :cardstat_active
					WHERE KPTNO = :kptno:kptno_ind
					AND CARDVERSIONNO = :cardversion:cardversion_ind; */ 

				{
				  struct sqlexd sqlstm;
				  sqlstm.sqlvsn = 12;
				  sqlstm.arrsiz = 52;
				  sqlstm.sqladtp = &sqladt;
				  sqlstm.sqltdsp = &sqltds;
				  sqlstm.stmt = "update CARD_STATUS  set CARDSTAT=:b0 where (KPTNO=:b1:b2 an\
				d CARDVERSIONNO=:b3:b4)";
				  sqlstm.iters = (unsigned int  )1;
				  sqlstm.offset = (unsigned int  )4419;
				  sqlstm.cud = sqlcud0;
				  sqlstm.sqlest = (unsigned char  *)&sqlca;
				  sqlstm.sqlety = (unsigned short)256;
				  sqlstm.occurs = (unsigned int  )0;
				  sqlstm.sqhstv[0] = (         void  *)&cardstat_active;
				  sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
				  sqlstm.sqhsts[0] = (         int  )0;
				  sqlstm.sqindv[0] = (         void  *)0;
				  sqlstm.sqinds[0] = (         int  )0;
				  sqlstm.sqharm[0] = (unsigned int  )0;
				  sqlstm.sqadto[0] = (unsigned short )0;
				  sqlstm.sqtdso[0] = (unsigned short )0;
				  sqlstm.sqhstv[1] = (         void  *)kptno;
				  sqlstm.sqhstl[1] = (unsigned int  )13;
				  sqlstm.sqhsts[1] = (         int  )0;
				  sqlstm.sqindv[1] = (         void  *)&kptno_ind;
				  sqlstm.sqinds[1] = (         int  )0;
				  sqlstm.sqharm[1] = (unsigned int  )0;
				  sqlstm.sqadto[1] = (unsigned short )0;
				  sqlstm.sqtdso[1] = (unsigned short )0;
				  sqlstm.sqhstv[2] = (         void  *)&cardversion;
				  sqlstm.sqhstl[2] = (unsigned int  )sizeof(int);
				  sqlstm.sqhsts[2] = (         int  )0;
				  sqlstm.sqindv[2] = (         void  *)&cardversion_ind;
				  sqlstm.sqinds[2] = (         int  )0;
				  sqlstm.sqharm[2] = (unsigned int  )0;
				  sqlstm.sqadto[2] = (unsigned short )0;
				  sqlstm.sqtdso[2] = (unsigned short )0;
				  sqlstm.sqphsv = sqlstm.sqhstv;
				  sqlstm.sqphsl = sqlstm.sqhstl;
				  sqlstm.sqphss = sqlstm.sqhsts;
				  sqlstm.sqpind = sqlstm.sqindv;
				  sqlstm.sqpins = sqlstm.sqinds;
				  sqlstm.sqparm = sqlstm.sqharm;
				  sqlstm.sqparc = sqlstm.sqharc;
				  sqlstm.sqpadto = sqlstm.sqadto;
				  sqlstm.sqptdso = sqlstm.sqtdso;
				  sqlcxt(&pcCtx, &sqlctx, &sqlstm, &sqlfpn);
				}
				if(SQLCODE)
				{
					#ifdef DEBUG
							userlog("delete_card_status : Restoring card status from 'cardstat_retained_repl' for 'replacement' to 'Active' failed sqlmsg %s", SQLMSG);
					#endif
					sprintf(excep_log.error_msg,"delete_card_status : Restoring card status from 'cardstat_retained_repl' for 'replacement' to 'Active' failed sqlmsg %s", SQLMSG);
					excep_log.termination_flag = NO;
					excep_log.severity = NON_FATAL;
					log_error(ctx);
					
					return UPDATE_ERROR;
				}

				/* Also, delete the entry from Card History	*/
				/* EXEC SQL DELETE FROM CARD_HISTORY
						 WHERE KPTNO = :kptno:kptno_ind
						 AND CARDVERSIONNO = :cardversion:cardversion_ind
						 AND CARDSTAT = :cardstat_active; */ 

				{
				  struct sqlexd sqlstm;
				  sqlstm.sqlvsn = 12;
				  sqlstm.arrsiz = 52;
				  sqlstm.sqladtp = &sqladt;
				  sqlstm.sqltdsp = &sqltds;
				  sqlstm.stmt = "delete  from CARD_HISTORY  where ((KPTNO=:b0:b1 and CARDVER\
				SIONNO=:b2:b3) and CARDSTAT=:b4)";
				  sqlstm.iters = (unsigned int  )1;
				  sqlstm.offset = (unsigned int  )4446;
				  sqlstm.cud = sqlcud0;
				  sqlstm.sqlest = (unsigned char  *)&sqlca;
				  sqlstm.sqlety = (unsigned short)256;
				  sqlstm.occurs = (unsigned int  )0;
				  sqlstm.sqhstv[0] = (         void  *)kptno;
				  sqlstm.sqhstl[0] = (unsigned int  )13;
				  sqlstm.sqhsts[0] = (         int  )0;
				  sqlstm.sqindv[0] = (         void  *)&kptno_ind;
				  sqlstm.sqinds[0] = (         int  )0;
				  sqlstm.sqharm[0] = (unsigned int  )0;
				  sqlstm.sqadto[0] = (unsigned short )0;
				  sqlstm.sqtdso[0] = (unsigned short )0;
				  sqlstm.sqhstv[1] = (         void  *)&cardversion;
				  sqlstm.sqhstl[1] = (unsigned int  )sizeof(int);
				  sqlstm.sqhsts[1] = (         int  )0;
				  sqlstm.sqindv[1] = (         void  *)&cardversion_ind;
				  sqlstm.sqinds[1] = (         int  )0;
				  sqlstm.sqharm[1] = (unsigned int  )0;
				  sqlstm.sqadto[1] = (unsigned short )0;
				  sqlstm.sqtdso[1] = (unsigned short )0;
				  sqlstm.sqhstv[2] = (         void  *)&cardstat_active;
				  sqlstm.sqhstl[2] = (unsigned int  )sizeof(int);
				  sqlstm.sqhsts[2] = (         int  )0;
				  sqlstm.sqindv[2] = (         void  *)0;
				  sqlstm.sqinds[2] = (         int  )0;
				  sqlstm.sqharm[2] = (unsigned int  )0;
				  sqlstm.sqadto[2] = (unsigned short )0;
				  sqlstm.sqtdso[2] = (unsigned short )0;
				  sqlstm.sqphsv = sqlstm.sqhstv;
				  sqlstm.sqphsl = sqlstm.sqhstl;
				  sqlstm.sqphss = sqlstm.sqhsts;
				  sqlstm.sqpind = sqlstm.sqindv;
				  sqlstm.sqpins = sqlstm.sqinds;
				  sqlstm.sqparm = sqlstm.sqharm;
				  sqlstm.sqparc = sqlstm.sqharc;
				  sqlstm.sqpadto = sqlstm.sqadto;
				  sqlstm.sqptdso = sqlstm.sqtdso;
				  sqlcxt(&pcCtx, &sqlctx, &sqlstm, &sqlfpn);
				}
				if((SQLCODE) && !(NO_DATA_FOUND))
				{
					#ifdef DEBUG
							userlog("delete_card_status : Delete from CARD_HISTORY failed, 'cardstat_retained_repl' for 'replacement' application sqlmsg %s", SQLMSG);
					#endif
					sprintf(excep_log.error_msg,"delete_card_status : Delete from CARD_HISTORY failed, 'cardstat_retained_repl' for 'replacement' application!! sqlmsg %s", SQLMSG);
					excep_log.termination_flag = NO;
					excep_log.severity = NON_FATAL;
					log_error(ctx);
					
					return DELETE_ERROR;
				}

			#ifdef DEBUG
					userlog("Release 3.39: delete_card_status : Revert Card Status to from 'cardstat_retained_repl'(20) to 'Active'(16)- End");
			#endif
			//End of Releasee 3.39 Bugfix for Pelupusan application cancellation
			}
			else
			{
				#ifdef DEBUG
						userlog("Release 3.39: delete_card_status : Revert Card Status with 'cardstat_retained_repl'(20) Not found End");
				#endif
			}
			///---
		return GMPC_GOOD;
	}
	else
	{
		/* Select max cardversion for which card status is 'Lost'	*/ 
		cardversion = 0;
		EXEC SQL SELECT MAX(CARDVERSIONNO) 
				 INTO :cardversion:cardversion_ind
				 FROM CARD_STATUS 
				 WHERE KPTNO = :kptno:kptno_ind;
				 //AND CARDSTAT = :cardstat_lost;  //Remark by Salmi, date 11 Sept 2020

		if(SQLCODE)
		{
			#ifdef DEBUG
					userlog("delete_card_status : No CARD with status 'Lost' for 'replacement due to loss' application!!");
			#endif
			return GMPC_GOOD;
		}

		#ifdef DEBUG
			userlog("delete_card_status : cardversion [%d]\n!!", cardversion);
		#endif

		/* If yes, revert back the Card status of the previous version card to Active	*/
		EXEC SQL UPDATE CARD_STATUS
			SET CARDSTAT = :cardstat_active
			WHERE KPTNO = :kptno:kptno_ind
			AND CARDVERSIONNO = :cardversion:cardversion_ind;

		if(SQLCODE)
		{
			#ifdef DEBUG
					userlog("delete_card_status : Restoring card status from 'Lost' to 'Active' failed sqlmsg %s", SQLMSG);
			#endif
			sprintf(excep_log.error_msg,"delete_card_status : Restoring card status from 'Lost' to 'Active' failed sqlmsg %s", SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;
			log_error(ctx);
			
			return UPDATE_ERROR;
		}

		/* Also, delete the entry from Card History	*/
		EXEC SQL DELETE FROM CARD_HISTORY
				 WHERE KPTNO = :kptno:kptno_ind
				 AND CARDVERSIONNO = :cardversion:cardversion_ind
				 AND CARDSTAT = :cardstat_active;
		if((SQLCODE) && !(NO_DATA_FOUND))
		{
			#ifdef DEBUG
					userlog("delete_card_status : Delete from CARD_HISTORY failed, 'replacement due to loss' application sqlmsg %s", SQLMSG);
			#endif
			sprintf(excep_log.error_msg,"delete_card_status : Delete from CARD_HISTORY failed, 'replacement due to loss' application!! sqlmsg %s", SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;
			log_error(ctx);
			
			return DELETE_ERROR;
		}

		/* Also, delete the entry from Card Blacklist	*/
		EXEC SQL DELETE FROM CARD_BLACKLIST
				 WHERE KPTNO = :kptno:kptno_ind
				 AND CARDVERSIONNO = :cardversion:cardversion_ind;
		if((SQLCODE) && !(NO_DATA_FOUND))
		{
			#ifdef DEBUG
					userlog("delete_card_status : Delete from card blacklist failed, 'replacement due to loss' application sqlmsg %s", SQLMSG);
			#endif
			sprintf(excep_log.error_msg,"delete_card_status : Delete from card blacklist failed, 'replacement due to loss' application!! sqlmsg %s", SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;
			log_error(ctx);
			
			return DELETE_ERROR;
		}

	}			 

	return GMPC_GOOD;

}

/************************************************************************************/
/* Function Name:	ins_card_status()												*/
/* Description	:	This function inserts a record in CARD_STATUS table for given	*/
/*					given KPT no and Application id.								*/
/* Input		:	GMPC Id (KPT), Application id, Card status						*/
/* Return Values:   GMPC_GOOD for success/ Specific Error code for failure			*/
/* Limitations	:   None															*/
/************************************************************************************/	

int ins_card_status(HEADER_T header, char *gmpc_id, int card_stat,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char applid[APP_ID_SIZE] = {0};
		int cardstatus = 0;
		int cardverno = 0;
		short cardverno_ind = -1;
		char gmpcid[KPT_SIZE] = {0};
		char branchcode[BRANCH_CODE_SIZE] = {0};
		varchar userid[USER_ID_SIZE] = {0};
		varchar ag_on_chip[AGENCY_ON_CHIP_SIZE] = {0};
		short ag_on_chip_ind = -1;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	int ret_val = 0;

	strcpy(applid, header.application_id);
	strcpy(gmpcid, gmpc_id);
	
#ifdef DEBUG
	userlog("ins_card_status : Application id - %s", applid);
	userlog("ins_card_status : GMPC id - %s", gmpc_id);
	userlog("ins_card_status : Card status - %d", card_stat);
#endif
	
	EXEC SQL SELECT CARDVERSIONNO, AGENCYONCHIP
			INTO :cardverno:cardverno_ind, :ag_on_chip:ag_on_chip_ind
		FROM CARD_STATUS WHERE KPTNO = :gmpcid
		AND APPLID = :applid
		AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS 
									WHERE KPTNO = :gmpcid
									AND APPLID = :applid) ;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("ins_card_status : Selecting Card version number from CARD_STATUS failed for Card id - %s : %s", gmpc_id, SQLMSG);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"ins_card_status :Selecting Card version number from CARD_STATUS failed for Card id - %s : %s", gmpc_id, SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return SELECT_ERROR;
	}

	if (cardverno_ind != 0)
	{
#ifdef DEBUG
		userlog("ins_card_status : Card version number in CARD_STATUS is invalid for Card id - %s ", gmpc_id);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"ins_card_status : Card version number in CARD_STATUS is invalid for Card id - %s ", gmpc_id);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return CARD_VERSION_NULL;

	}

	if (ag_on_chip_ind == 0)
		setnull(ag_on_chip);

#ifdef DEBUG
	userlog("ins_card_status : Maximum card version no - %d", cardverno);
	userlog("ins_card_status : Agency on chip - %s", ag_on_chip.arr);
#endif


	/* Insert record with this card version no in CARD_BLACKLIST */
	/* if the card is Missing at GSC or Unlocated				 */
	
/*	if (card_stat == MISSING_GSC
		|| card_stat == UNLOCATED)
	{
		if((ret_val = ins_card_blacklist(applid, gmpc_id, cardverno)) != GMPC_GOOD)
		{

#ifdef DEBUG
			userlog("ins_card_status : Return value from ins_card_blacklist - %d for Card id - %s", ret_val, gmpc_id);
#endif
			return ret_val;
		}
	}
*/
	/* Increment the Card version no by 1 */
	cardverno = cardverno + 1;

	cardstatus = SENT_REPRODUCTION;
	strcpy(branchcode, header.branch_code);
	strcpy((char *)userid.arr, header.user_id);
	setlen(userid);
	
	EXEC SQL INSERT INTO CARD_STATUS ( KPTNO, CARDVERSIONNO, APPLID, CARDSTAT,
							 USERID, TIMESTAMP, BRANCHCODE, AGENCYONCHIP)
			VALUES ( :gmpcid, :cardverno:cardverno_ind, :applid,
			         :cardstatus, :userid,	SYSDATE, :branchcode,
					 :ag_on_chip:ag_on_chip_ind);

	
	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("ins_card_status :Insert into CARD_STATUS failed for Card id %s : %s", gmpc_id, SQLMSG);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"ins_card_status :Insert into CARD_STATUS failed for Card id %s : %s", gmpc_id, SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return INSERT_ERROR;
	}

	// The following upadte is included on 28/09/05 for IJPN
	// Here CFC Reprint data need to update to host
	// So updating APPL_TXN legupdflag to 'N' which will enable to fire jpn_update

	EXEC SQL UPDATE APPL_TXN
		SET LEGUPDFLAG = 'N'
		WHERE APPLID = :applid;

	if (SQLCODE != 0)
	{
	#ifdef DEBUG
		userlog("ins_card_status : UPDATE APPL_TXN failed for applid - %s : %s", applid, SQLMSG);
	#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"ins_card_status :UPDATE APPL_TXN failed for applid - %s : %s", applid, SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return UPDATE_ERROR;
	}

	userlog("ins_card_status : APPL_TXN legupdflag updated to N");

#ifdef DEBUG
	userlog("ins_card_status : Inserted into CARD_STATUS successfully.");
#endif

	return GMPC_GOOD;
}


/************************************************************************************/
/* Function Name:	check_appl_card_status()												*/
/* Description	:	This function inserts a record in CARD_STATUS table for given	*/
/*					given KPT no and Application id.								*/
/* Input		:	GMPC Id (KPT), Application id, Card status						*/
/* Return Values:   GMPC_GOOD for success/ Specific Error code for failure			*/
/* Limitations	:   None															*/
/************************************************************************************/	
int check_appl_card_status(HEADER_T header, char *gmpc_id, int *applstat_flag, int *name_flag, int *add_flag, int *images_flag, NAME_ADDRESS_T *name_add, long lr_photo_size, long hr_photo_size,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char applid[APP_ID_SIZE] = {0};
		int cardstatus = 0;
		int cardverno = 0;
		short cardverno_ind = -1;
		char gmpcid[KPT_SIZE] = {0};
		char appl_stat = '\0';
		short appl_stat_ind = 0;
		char hist_appl_stat = '\0';
		short hist_appl_stat_ind = 0;
		char branchcode[BRANCH_CODE_SIZE] = {0};
		varchar userid[USER_ID_SIZE] = {0};
		varchar ag_on_chip[AGENCY_ON_CHIP_SIZE] = {0};
		short ag_on_chip_ind = -1;
		int cardstat = 0;
		short int cardstat_ind = 0;

		varchar gmpcshortname1[GMPC_SNAME1_SIZE] = {0};
		varchar gmpcshortname2[GMPC_SNAME2_SIZE] = {0};
		varchar gmpcshortname3[GMPC_SNAME3_SIZE] = {0};
		varchar address1[ADDRESS_SIZE] = {0};
		varchar address2[ADDRESS_SIZE] = {0};
		varchar address3[ADDRESS_SIZE] = {0};
		varchar postcode[POST_CODE_SIZE] = {0};
		int citycode = 0;
		char statecode[STATE_CODE_SIZE] = {0};

		short int gmpcshortname1_ind = 0;
		short int gmpcshortname2_ind = 0;
		short int gmpcshortname3_ind = 0;
		short int address1_ind = 0;
		short int address2_ind = 0;
		short int address3_ind = 0;
		short int postcode_ind = 0;
		short int citycode_ind = 0;
		short int statecode_ind = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	int ret_val = 0;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	

	strcpy(applid, header.application_id);
	strcpy(gmpcid, gmpc_id);
	
#ifdef DEBUG
	userlog("ins_card_status : Application id - %s", applid);
	userlog("ins_card_status : GMPC id - %s", gmpc_id);
#endif
	
	EXEC SQL SELECT APPLSTAT INTO :appl_stat:appl_stat_ind
		FROM APPLICATION WHERE APPLID = :applid;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("check_appl_status : Selecting appl_stat from APPLICATION failed for Card id - %s : %s", gmpc_id, SQLMSG);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"check_appl_status :Selecting appl_stat from APPLICATION failed for Card id - %s : %s", gmpc_id, SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return SELECT_ERROR;
	}

	#ifdef DEBUG
		userlog("check_appl_status : appl_stat in application is - %c ", appl_stat);
	#endif

	if (appl_stat_ind != 0)
	{
#ifdef DEBUG
		userlog("check_appl_status : appl_stat in application is invalid for Card id - %s ", gmpc_id);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"check_appl_status : appl_stat in application is invalid for Card id - %s ", gmpc_id);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return SELECT_ERROR;

	}

	EXEC SQL SELECT APPLSTAT INTO :hist_appl_stat:hist_appl_stat_ind
		FROM APPL_HISTORY WHERE APPLID = :applid AND APPLSTAT = 'S'
		AND ROWNUM = 1;

	if (SQLCODE != 0 && !(NO_DATA_FOUND))
	{
#ifdef DEBUG
		userlog("check_appl_status : Selecting appl_stat from APPL_HISTORY failed for Card id - %s : %s", gmpc_id, SQLMSG);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"check_appl_status :Selecting appl_stat from APPL_HISTORY failed for Card id - %s : %s", gmpc_id, SQLMSG);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return SELECT_ERROR;
	}else if(NO_DATA_FOUND)
	{
		hist_appl_stat = '\0';
	}

	if (hist_appl_stat_ind != 0)
	{
#ifdef DEBUG
		userlog("check_appl_status : appl_stat in APPL_HISTORY is invalid for Card id - %s ", gmpc_id);
#endif
		/* Log the error in Application exception log */
		sprintf(excep_log.error_msg,"check_appl_status : appl_stat in APPL_HISTORY is invalid for Card id - %s ", gmpc_id);
		excep_log.termination_flag = NO;
		excep_log.severity = NON_FATAL;

		log_error(ctx);

		return SELECT_ERROR;

	}

	if(appl_stat == 'S' || hist_appl_stat == 'S')
	{
		*applstat_flag = NO_UPDATE;	/* Initialized, may change later */
	}
	else
	{
		*applstat_flag = ALL_UPDATES; /* Card not produced yet - send usual update messages	*/
	}

	if(*applstat_flag == NO_UPDATE)
	{
		EXEC SQL SELECT CARDSTAT INTO :cardstat:cardstat_ind
			FROM CARD_STATUS WHERE KPTNO = :gmpcid
			AND APPLID = :applid
			AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS 
										WHERE KPTNO = :gmpcid
										AND APPLID = :applid);

		if (SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog("check_appl_status : Selecting cardstat number from CARD_STATUS failed for Card id - %s : %s", gmpc_id, SQLMSG);
	#endif
			/* Log the error in Application exception log */
			sprintf(excep_log.error_msg,"check_appl_status :Selecting cardstat number from CARD_STATUS failed for Card id - %s : %s", gmpc_id, SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;

			log_error(ctx);

			return SELECT_ERROR;
		}

		EXEC SQL
			SELECT GMPCSHORTNAME1, GMPCSHORTNAME2, GMPCSHORTNAME3, ADDRESS1, ADDRESS2, ADDRESS3, 
			POSTCODE, CITYCODE, STATECODE INTO :gmpcshortname1:gmpcshortname1_ind,
			:gmpcshortname2:gmpcshortname2_ind,
			:gmpcshortname3:gmpcshortname3_ind, :address1:address1_ind,
			:address2:address2_ind, :address3:address3_ind, :postcode:postcode_ind,
			:citycode:citycode_ind,
			:statecode:statecode_ind
			FROM JPN_INFO WHERE 
			KPTNO = :gmpcid;

		if (SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog("check_appl_status : Selecting from APPNT_JPN_INFO failed for Card id - %s : %s", gmpc_id, SQLMSG);
	#endif
			/* Log the error in Application exception log */
			sprintf(excep_log.error_msg,"check_appl_status :Selecting from APPNT_JPN_INFO failed for Card id - %s : %s", gmpc_id, SQLMSG);
			excep_log.termination_flag = NO;
			excep_log.severity = NON_FATAL;

			log_error(ctx);

			return SELECT_ERROR;
		}

		setnull(gmpcshortname1);
		setnull(gmpcshortname2);
		setnull(gmpcshortname3);
		setnull(address1);
		setnull(address2);
		setnull(address3);
		setnull(postcode);

		if((strcmp((char *)gmpcshortname1.arr, name_add->gmpcshortname1)) || 
			(strcmp((char *)gmpcshortname2.arr, name_add->gmpcshortname2)) ||
			(strcmp((char *)gmpcshortname3.arr, name_add->gmpcshortname3)))
		{
			*name_flag = 1;
		}

		if(((strcmp((char *)address1.arr, name_add->address.address1)) || 
			(strcmp((char *)address2.arr, name_add->address.address2)) || 
			(strcmp((char *)address3.arr, name_add->address.address3)) || 
			(strcmp((char *)postcode.arr, name_add->address.post_code)) || 
			(strcmp((char *)statecode, name_add->address.state_code)) ||
			(citycode != name_add->address.city_code)))
		{
			*add_flag = 1;
		}


		if ((lr_photo_size > 0) || (hr_photo_size > 0))
			*images_flag = 1;

		if(cardstat == 16)
		{
			*applstat_flag = ALL_UPDATES; /* Card has been issued -  send issuance messages */
		}
		else if((*name_flag) || (*add_flag) || (*images_flag))
		{
			//if(cardstat != 16) // changed on 28/09/05 to avoid call to jpn_update
			if((cardstat != 16) && (cardstat != 25))
			{
				*applstat_flag = SELECTIVE_UPDATES; /* Card not issued yet but name/addr/images have changed */
			}
		}
		else
		{
			*applstat_flag = NO_UPDATE; /* Card not issued yet and name/addr/images have not changed */
		}
	}

	return GMPC_GOOD;

}
	

/************************************************************************/
/* Function Name:update_legacy_request		 						*/
/* Description	:inserts into legacy_request on jpn_update tpacall fails*/
/* Input		:CARD_ISSUANCE_REQ_T, new_applid,update_flag			*/   
/* Return Values:SUCCESS OR FAILURE										*/
/************************************************************************/
int update_legacy_request(HEADER_T *header, char flag, char agency, int reqstat,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06	
	EXEC SQL BEGIN DECLARE SECTION;
		int legreqstat;                 
//		char legreqdatetime[DATE_TIME_SIZE];
		char legreqflag;                    
		char checkagency;                   
		char serviceid[SERVICE_ID_SIZE];     
		char applid[APP_ID_SIZE];           
		varchar userid[USER_ID_SIZE];
		char branchcode[BRANCH_CODE_SIZE];
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	legreqstat = reqstat;
//	strcpy(legreqdatetime,get_date_time());
	legreqflag = flag;
	checkagency = agency;

	if (agency == JPN_ID)
		_itoa(JPN_UPDATE_ID, serviceid, 10);
	else if (agency == JPJ_ID)
		_itoa(JPJ_UPDATE_ID, serviceid, 10);
	else if (agency == JIM_ID)
		_itoa(IMM_UPDATE_ID, serviceid, 10);
	else if (agency == PDRM_ID)
		_itoa(PDRM_UPDATE_ID, serviceid, 10);

	strcpy(applid, header->application_id);

	strcpy((char *)userid.arr, header->user_id);
	setlen(userid);
	strcpy(branchcode, header->branch_code);
	

#ifdef DEBUG
		userlog("update_legacy_request:applid :%s", applid);
		userlog("update_legacy_request:gscno :%s", branchcode);
		userlog("update_legacy_request:userid :%s", userid.arr);
		userlog("update_legacy_request:requeststat :%d", legreqstat);
//		userlog("update_legacy_request:requestdate :%s", legreqdatetime);
		userlog("update_legacy_request:checkagency :%c", checkagency);
		userlog("update_legacy_request:requestflag :%c", legreqflag);
		userlog("update_legacy_request:serviceid :%s", serviceid);
#endif


	
	SQLCODE = 0; /* resetting any previous error code */
	EXEC SQL 
		UPDATE IJPN_LEGACY_REQUEST SET 
		LEGREQSTAT = :legreqstat
		WHERE 
		APPLID = :applid
		AND CHECKAGENCY = :checkagency
		AND LEGREQFLAG = :legreqflag
		AND SERVICEID = :serviceid;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);
	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_legacy_request : update_legacy_request failed");
		sprintf(excep_log.error_msg,"update_legacy_request : update_legacy_request failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return INSERT_ERROR;
	}
	else if(NO_DATA_FOUND)
	{
		return NO_DATA1;
	}
	else
	{
		return GMPC_GOOD;
	}

}


/************************************************************/
/* Function Name:insert_into_card_history  					*/
/* Description	:inserts into card_history table			*/
/* Input		:appl_id,CARD_ISSUANCE_REQ_T structure		*/
/* Return Values:SUCCESS OR FAILURE							*/
/************************************************************/
int insert_into_card_history(HEADER_T header,char *kptnumber, char *appl_id, int old_cardstat,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06	
	EXEC SQL BEGIN DECLARE SECTION;
		char applid[APP_ID_SIZE];
		char collection_center[BRANCH_CODE_SIZE];
//		char card_collect_date[DATE_TIME_SIZE];
		char branch_code[BRANCH_CODE_SIZE];
		varchar user_id[USER_ID_SIZE];
		varchar wsid[WS_ID_SIZE];
		int  card_stat;
		char personalized_date[DATE_TIME_SIZE];
		char kpt_number[KPT_SIZE];
		int card_version;
		varchar agency_on_chip[AGENCY_ON_CHIP_SIZE];
		char timestamp[DATE_TIME_SIZE];


		short int collection_center_ind = -1;
		short int personalized_date_ind = -1;
		short int card_version_ind = -1;
		short int agency_on_chip_ind = -1;
		short int card_stat_ind = -1;
		short int timestamp_ind = -1;
		short int user_id_ind = -1;
		short int wsid_ind = -1;
		short int branch_code_ind = -1;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	collection_center[0] = '\0';
	strcpy(kpt_number, kptnumber);
	strcpy(applid, appl_id);

	if(old_cardstat != 0)
	{
		card_stat = old_cardstat;
		card_stat_ind = 0;
	}
	else
	{
		strcpy(prog_log.remarks,"insert_into_card_history : Card stat is null");
		sprintf(excep_log.error_msg,"insert_into_card_history :Card stat is null");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);
		return CARD_STATUS_NULL;
	}

	EXEC SQL 
		SELECT CARDVERSIONNO, TO_CHAR(CARDPERSONALDATE, 'DDMMYYYY HH24MISS'),
		AGENCYONCHIP, TO_CHAR(TIMESTAMP,'DDMMYYYY HH24MISS'), USERID, WSID
		INTO :card_version:card_version_ind, 
			 :personalized_date:personalized_date_ind, 
			 :agency_on_chip:agency_on_chip_ind,
			 :timestamp:timestamp_ind,
			 :user_id:user_id_ind,
			 :wsid:wsid_ind
		FROM CARD_STATUS 
		WHERE KPTNO =:kpt_number AND 
		APPLID = :applid AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM
		CARD_STATUS WHERE KPTNO =:kpt_number AND 
		APPLID = :applid);

		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"insert_into_card_history : SELECT CARDVERSION, CARDPERSONALDATE, AGENCYONCHIP  failed");
			sprintf(excep_log.error_msg,"insert_into_card_history : SELECT CARDVERSION, CARDPERSONALDATE, AGENCYONCHIP  failed: %s", SQLMSG);
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		if(card_version_ind == -1)
		{
			strcpy(prog_log.remarks,"insert_into_card_history : CARDVERSION Null");
			sprintf(excep_log.error_msg,"insert_into_card_history : CARDVERSION Null: %s", SQLMSG);
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			log_error(ctx);
			return CARD_VERSION_NULL;

		}

		if(agency_on_chip_ind == -1)
		{
			agency_on_chip.arr[0] = '\0';
			agency_on_chip.len = 0;
		}
		else
		{
			setnull(agency_on_chip);
		}

		if(user_id_ind == -1)
		{
			user_id.arr[0] = '\0';
			user_id.len = 0;
		}
		else
		{
			setnull(user_id);
		}

		if(wsid_ind == -1)
		{
			wsid.arr[0] = '\0';
			wsid.len = 0;
		}
		else
		{
			setnull(wsid);
		}

		if(personalized_date_ind == -1)
		{
			personalized_date[0] = '\0';
		}
		else
		{
			personalized_date_ind = 0;
		}


	EXEC SQL 
		SELECT COLLCENTER, BRANCHCODE INTO :collection_center:collection_center_ind,
		:branch_code:branch_code_ind
		FROM APPLICATION WHERE
		APPLID = :applid;

		sqlmsg[0] = '\0';
		strcpy(sqlmsg, SQLMSG);
		if(SQLCODE)
		{
			strcpy(prog_log.remarks,"insert_into_card_history : SELECT COLLCENTER  failed");
			sprintf(excep_log.error_msg,"insert_into_card_history : SELECT COLLCENTER  failed: %s", SQLMSG);
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			log_error(ctx);
			return SELECT_ERROR;
		}

		if(collection_center_ind == -1)
		{
			collection_center[0] = '\0';
		}
		else
		{
			collection_center_ind = 0;
		}

		if(branch_code_ind == -1)
		{
			branch_code[0] = '\0';
		}
		else
		{
			branch_code_ind = 0;
		}
	
/*	strcpy(branch_code, header.branch_code);
	strcpy((char *)user_id.arr, header.user_id);
	setlen(user_id);
	strcpy((char *)wsid.arr, header.workstation_id);
	setlen(wsid);
*/
//	strcpy(timestamp, get_date_time());

#ifdef DEBUG
	if (timestamp_ind == 0)
		userlog("timestamp is %s", timestamp);
	userlog("kpt_number is %s", kpt_number);
	userlog("card_version is %d", card_version);
	userlog("card_stat is %d", card_stat);
	userlog("collection_center is %s", collection_center);
	userlog("personalized_date is %s", personalized_date);
	userlog("user_id is %s", user_id.arr);
	userlog("wsid is %s", wsid.arr);
	userlog("branch_code is %s", branch_code);
	userlog("agency_on_chip is %s", agency_on_chip.arr);
#endif
	EXEC SQL INSERT INTO CARD_HISTORY 
		(KPTNO, CARDVERSIONNO, CARDSTAT, COLLCENTER, 
		CARDCOLLDATE, CARDPERSONALDATE, USERID, WSID, 
		TIMESTAMP, BRANCHCODE, AGENCYONCHIP)
		VALUES (:kpt_number, :card_version:card_version_ind,
		:card_stat, :collection_center:collection_center_ind, SYSDATE, 
		TO_DATE(:personalized_date:personalized_date_ind, 'DDMMYYYY HH24MISS'), 
		:user_id:user_id_ind,:wsid:wsid_ind, 
		TO_DATE(:timestamp:timestamp_ind, 'DDMMYYYY HH24MISS'), 
		:branch_code:branch_code_ind, :agency_on_chip:agency_on_chip_ind);
	

	if (SQLCODE != 0)
	{
		strcpy(prog_log.remarks,"insert_into_card_history : Failed to insert into CARD_HISTORY");
		sprintf(excep_log.error_msg,"insert_into_card_history : Failed to insert into CARD_HISTORY: %s", SQLMSG);
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		log_error(ctx);
		return INSERT_ERROR;
	}

	return GMPC_GOOD;
}


/********************************************************************/
/* Function name: check_jpj_data									*/
/* Description	: This function 									*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/
int check_jpj_data(char *applid, int * jpj_flag,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char application_id[APP_ID_SIZE];
		int jpj_count = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(application_id, applid);

	EXEC SQL
		SELECT COUNT(*) INTO :jpj_count FROM PROBL_RECORD 
		WHERE APPLID = :application_id AND 
		(PROBLREASONCODE LIKE 'J%' OR PROBLREASONCODE LIKE '214%');

	//if(SQLCODE && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
		strcpy(prog_log.remarks,"check_jpj_data : check_jpj_data failed");
		sprintf(excep_log.error_msg,"check_jpj_data : check_jpj_data failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	if(jpj_count == 0)
	{
		*jpj_flag = 0;
	}else
	{
		/* Changed by Sushil 23/04/2003 to include owner category in the selection criteria 
		EXEC SQL SELECT COUNT(*) INTO :jpj_count FROM JPJ_INFO 
				WHERE KPTNO = (SELECT KPTNO FROM APPLICATION 
							WHERE APPLID = :application_id) AND 
							LICIDNO = (SELECT LICIDNO FROM APPLICATION 
							WHERE APPLID = :application_id);
		*/

		EXEC SQL SELECT COUNT(*) INTO :jpj_count FROM JPJ_INFO 
			WHERE (KPTNO,LICIDNO,OWNERCAT) = (SELECT KPTNO,LICIDNO,OWNERCAT FROM APPLICATION 
										WHERE APPLID = :application_id);

		
		//if (SQLCODE != 0 && !NO_DATA_FOUND)
		if((SQLCODE) != 0 && (SQLCODE != 1403))
		{
	#ifdef DEBUG
			userlog("check_jpj_data : Select from JPJ_INFO failed :%s:", SQLMSG);
	#endif
			strcpy(prog_log.remarks,"check_jpj_data: Select from JPJ_INFO failed ");
			sprintf(excep_log.error_msg, "check_jpj_data: Select from JPJ_INFO failed: %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

		if(jpj_count == 0)
		{
			*jpj_flag = 0;
		}
		else
		{
			*jpj_flag = 1;
		}

	}

#ifdef DEBUG
	userlog("check_jpj_data :jpj_flag %d", *jpj_flag);
#endif


	return GMPC_GOOD;
}


/********************************************************************/
/* Function name: put_jpj_data										*/
/* Description	: This function 									*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/
int put_jpj_data(char *applid, char *kptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
//		char application_id[APP_ID_SIZE];
		int jpj_count = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	int retval = 0;

	retval = delete_jpj_info(applid, kptno,ctx);

	if(retval != GMPC_GOOD)
	{
		return retval;
	}

	retval = 0;
	retval = insert_into_appnt_jpj_info(applid, kptno,ctx);

	if(retval != SUCCESS)
	{
		return retval;
	}

	retval = 0;
	retval = insert_into_appnt_jpj_lic_info(applid, kptno,ctx);

	if(retval != SUCCESS)
	{
		return retval;
	}

	retval = 0;
	retval = fetch_txncode(applid,ctx);
	if(retval != SUCCESS)
	{
		return retval;
	}

	retval = 0;
	retval = perform_common_jpj_checks(applid, kptno,ctx);

	if(retval != SUCCESS)
	{
		return retval;
	}
	return GMPC_GOOD;
}

/********************************************************************************/
/* Function name: delete_jpj_info									*/
/* Description	: This function inserts the Applicant's JPJ(License)info into   */          
/*                APPNT_JPJ_INFO table											*/
/* Input		: Request buffer												*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int delete_jpj_info(char applid[APP_ID_SIZE], char kptno[KPT_SIZE],void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char kpt_no[KPT_SIZE] = {0};
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(appl_id, applid);

	EXEC SQL
		DELETE FROM APPNT_LIC_INFO
		WHERE APPLID = :appl_id;

	if(SQLCODE && !(NO_DATA_FOUND))
	{
		strcpy(prog_log.remarks,"delete_jpj_info : delete from APPNT_LIC_INFO failed");
		sprintf(excep_log.error_msg,"delete_jpj_info : delete from APPNT_LIC_INFO application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	EXEC SQL
		DELETE FROM APPNT_JPJ_INFO
		WHERE APPLID = :appl_id;

	if(SQLCODE && !(NO_DATA_FOUND))
	{
		strcpy(prog_log.remarks,"delete_jpj_info : delete from APPNT_JPJ_INFO failed");
		sprintf(excep_log.error_msg,"delete_jpj_info : delete from APPNT_JPJ_INFO application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	return GMPC_GOOD;
}

/********************************************************************************/
/* Function name: insert_into_appnt_jpj_info									*/
/* Description	: This function inserts the Applicant's JPJ(License)info into   */          
/*                APPNT_JPJ_INFO table											*/
/* Input		: Request buffer												*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int insert_into_appnt_jpj_info(char applid[APP_ID_SIZE], char kptno[KPT_SIZE],void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char kpt_no[KPT_SIZE] = {0};

	char lic_id_type[ID_TYPE_SIZE] = {0};
	varchar lic_id[LIC_ID_SIZE] = {0};
	char owner_cat = 0;
	char new_owner_cat = 0;
	int susp_gen_no = 0;
	int kejara_points = 0;
	char last_kejara_upd_date[DATE_SIZE] = {0};
	char print_mdl = 0;
	char bl_flag = 0;
	varchar veh_reg_no[VEHICLE_REGISTRATION_NUMBER_SIZE] = {0};

	short kpt_no_ind = -1 ;
	short lic_id_type_ind = -1 ;
	short lic_id_ind = -1 ;
	short owner_cat_ind = -1 ;
	short new_owner_cat_ind = -1 ;
	short susp_gen_no_ind = -1 ;
	short kejara_points_ind = -1 ;
	short last_kejara_upd_date_ind = -1 ;
	short print_mdl_ind = -1 ;
	short bl_flag_ind = -1 ;
	short veh_reg_no_ind = -1 ;
	
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	/* Populate the variables	*/

	strcpy(appl_id, applid);
	strcpy(kpt_no, kptno);
	kpt_no_ind = 0;


	EXEC SQL 
		SELECT LICIDNO, OWNERCAT, NVL(NEWOWNERCAT, OWNERCAT) INTO :lic_id:lic_id_ind, :owner_cat:owner_cat_ind, :new_owner_cat:new_owner_cat_ind
		FROM APPLICATION WHERE 
		APPLID = :applid;

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_info : Select from application failed");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_info : Select from application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	if ( lic_id_ind == -1)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_info : Select from application failed, Lic ID NULL");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_info : Select from application failed, Lic ID NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return LIC_ID_NULL;

	}
	else
	{
		setnull(lic_id);
		lic_id_ind = 0;
	}

	if ( owner_cat_ind == -1)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_info : Select from application failed, owner_cat NULL");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_info : Select from application failed, owner_cat NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return OWNER_CAT_NULL;

	}
	else
	{
		owner_cat_ind = 0;
	}

#ifdef DEBUG
	userlog("insert_into_appnt_jpj_info : Appl id - %s", appl_id);
	userlog("insert_into_appnt_jpj_info : License id - %s", lic_id.arr);
	userlog("insert_into_appnt_jpj_info : Owner cat - %c", owner_cat);
	userlog("insert_into_appnt_jpj_info : KPT No - %s", kpt_no);
#endif

	EXEC SQL SELECT LICIDTYPE, SUSPGENNO, KEJARAPOINTS, 
				TO_CHAR(LASTKEJARAPOINTUPDDATE, 'DDMMYYYY'), BLFLAG, VEHREGNO
			INTO :lic_id_type:lic_id_type_ind, :susp_gen_no:susp_gen_no_ind, 
				 :kejara_points:kejara_points_ind,
				 :last_kejara_upd_date:last_kejara_upd_date_ind,  
				 :bl_flag:bl_flag_ind, :veh_reg_no:veh_reg_no_ind
			FROM JPJ_INFO 
			WHERE LICIDNO = :lic_id:lic_id_ind
			AND   OWNERCAT = :owner_cat:owner_cat_ind;

	if (SQLCODE != 0 )
	{
#ifdef DEBUG
		userlog("insert_into_appnt_jpj_info : Select from JPJ_INFO failed for KPT %s: %s", kpt_no, SQLMSG);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_info: Select from JPJ_INFO failed ");
		sprintf(excep_log.error_msg, "insert_into_appnt_jpj_info: Select from JPJ_INFO failed for KPT %s : %s", kpt_no, SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

	if (0 == veh_reg_no_ind)
		setnull(veh_reg_no);

	print_mdl = YES;	/* Set Print MDL flag to YES by default */
	print_mdl_ind = 0;

#ifdef DEBUG
	userlog("insert_into_appnt_jpj_info : Data selected from JPJ_INFO");
	userlog("insert_into_appnt_jpj_info : Lic id - %s", lic_id.arr);
	userlog("insert_into_appnt_jpj_info : Vehicle reg no - %s", veh_reg_no.arr);
	userlog("insert_into_appnt_jpj_info : Lic id type - %s", lic_id_type);
	userlog("insert_into_appnt_jpj_info : Last kejara upd date - %s", last_kejara_upd_date);
	userlog("insert_into_appnt_jpj_info : Suspension gen no - %d", susp_gen_no);
	userlog("insert_into_appnt_jpj_info : Kejara points - %d", kejara_points);
	userlog("insert_into_appnt_jpj_info : Print MDL flag - %c", print_mdl);
	userlog("insert_into_appnt_jpj_info : BL flag - %c", bl_flag);
	userlog("insert_into_appnt_jpj_info : Owner category - %c", owner_cat);
#endif
	

	EXEC SQL SELECT LICIDTYPE INTO :lic_id_type:lic_id_type_ind
		FROM APPLICATION 
		WHERE applid = :appl_id;

	if (SQLCODE != 0 )
	{
#ifdef DEBUG
		userlog("insert_into_appnt_jpj_info : Select from APPLICATION failed for KPT %s: %s", kpt_no, SQLMSG);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_info: Select from APPLICATION failed ");
		sprintf(excep_log.error_msg, "insert_into_appnt_jpj_info: Select from APPLICATION failed for KPT %s : %s", kpt_no, SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

#ifdef DEBUG
	userlog("insert_into_appnt_jpj_info : Lic id type - %s", lic_id_type);
	userlog("insert_into_appnt_jpj_info : Lic id type ind- %d", lic_id_type_ind);
#endif


	EXEC SQL INSERT INTO APPNT_JPJ_INFO (APPLID, KPTNO, LICIDTYPE, LICIDNO, 
									OWNERCAT, SUSPGENNO, KEJARAPOINTS,
									LASTKEJARAPOINTUPDDATE, PRINTMDL, BLFLAG, VEHREGNO)
		VALUES (:appl_id, :kpt_no:kpt_no_ind, :lic_id_type:lic_id_type_ind, :lic_id:lic_id_ind,
				:new_owner_cat:new_owner_cat_ind, :susp_gen_no:susp_gen_no_ind, :kejara_points:kejara_points_ind,
				TO_DATE(:last_kejara_upd_date:last_kejara_upd_date_ind, 'DDMMYYYY'), :print_mdl:print_mdl_ind,
				:bl_flag:bl_flag_ind, :veh_reg_no:veh_reg_no_ind);


		if(SQLCODE != 0 && SQLCODE != -1)
		{
#ifdef DEBUG
			userlog(" insert_into_appnt_jpj_info : Insert into APPNT_JPJ_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"insert_into_appnt_jpj_info: Insert into APPNT_JPJ_INFO failed");
			sprintf(excep_log.error_msg, "insert_into_appnt_jpj_info: Insert into APPNT_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return INSERT_ERROR;
		}

#ifdef DEBUG
		userlog("insert_into_appnt_jpj_info : Record inserted successfully");
#endif

	return SUCCESS;

}



/********************************************************************************/
/* Function name: insert_into_appnt_jpj_lic_info								*/
/* Description	: This function inserts the Applicant's JPJ(License)info into   */          
/*                APPNT_LIC_INFO table											*/
/* Input		: Application id, KPT no										*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int insert_into_appnt_jpj_lic_info(char *application_id, char *kptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char license_type[LIC_TYPE_SIZE] = {0};
	char license_class[LIC_CLS_SIZE] = {0};
	char licenseclass_usage[LIC_USAGE_SIZE] = {0};
	char validstart_date[DATE_SIZE] = {0};
	char validend_date[DATE_SIZE] = {0};
	char blacklist = 0;
	char handicap_regno[REG_NO_SIZE] = {0};
	char load_chip_flag = 0;
	char verified_stat = 0;
	char physical_rest_code = 0;
	varchar lic_id[LIC_ID_SIZE] = {0};
	char owner_cat = 0;
	int record_srno = 0;
	
	short license_type_ind = -1;
	short license_class_ind = -1;
	short licenseclass_usage_ind = -1;
	short validstart_date_ind = -1;
	short validend_date_ind = -1;
	short blacklist_ind = -1;
	short handicap_regno_ind = -1;
	short load_chip_flag_ind  = -1;
	short verified_stat_ind  = -1;
	short physical_rest_code_ind = -1;
	short lic_id_ind = -1;
	short owner_cat_ind = -1;
	short record_srno_ind = -1;

sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	/* Populate the variables	*/

	strcpy(appl_id, application_id);

	EXEC SQL 
		SELECT LICIDNO, OWNERCAT INTO :lic_id:lic_id_ind, :owner_cat:owner_cat_ind
		FROM APPLICATION WHERE 
		APPLID = :appl_id;

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info : Select from application failed");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_lic_info : Select from application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	if ( lic_id_ind == -1)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info : Select from application failed, Lic ID NULL");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_lic_info : Select from application failed, Lic ID NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return LIC_ID_NULL;

	}
	else
	{
		setnull(lic_id);
		lic_id_ind = 0;
	}

	if ( owner_cat_ind == -1)
	{
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info : Select from application failed, owner_cat NULL");
		sprintf(excep_log.error_msg,"insert_into_appnt_jpj_lic_info : Select from application failed, owner_cat NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return OWNER_CAT_NULL;

	}
	else
	{
		owner_cat_ind = 0;
	}

#ifdef DEBUG
	userlog("insert_into_appnt_jpj_lic_info : Appl id - %s", appl_id);
	userlog("insert_into_appnt_jpj_lic_info : Lic Id - %s", lic_id.arr);
	userlog("insert_into_appnt_jpj_lic_info : Owner cat - %c", owner_cat);
#endif

	
	EXEC SQL DECLARE  license_details CURSOR FOR
		 SELECT	LICTYPE,LICCLASS,LICUSAGECODE,
				TO_CHAR(LICVALIDSTARTDATE, 'DDMMYYYY'),
				TO_CHAR(LICVALIDENDDATE,'DDMMYYYY'),
				BLFLAG, HANDICVEHREGNO, VERIFIEDSTATUS, PHYRESTRICTCODE,
				RECORDSERNO
		 FROM JPJ_LIC_INFO 
			WHERE LICIDNO = :lic_id:lic_id_ind
			AND   OWNERCAT = :owner_cat:owner_cat_ind;


	EXEC SQL OPEN license_details;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" insert_into_appnt_jpj_lic_info : Unable to open cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Unable to open cursor for fetching data from JPJ_LIC_INFO");
		sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info : Unable to open cursor for fetching data from JPJ_LIC_INFO: %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return CURSOR_OPEN_ERROR;
	}

#ifdef DEBUG
		userlog(" insert_into_appnt_jpj_lic_info : Open cursor successfull");
#endif


	while (1)
	{
			EXEC SQL FETCH license_details
				INTO :license_type:license_type_ind, :license_class:license_class_ind,
					 :licenseclass_usage:licenseclass_usage_ind, 
					 :validstart_date:validstart_date_ind, :validend_date:validend_date_ind, 
					 :blacklist:blacklist_ind ,	:handicap_regno:handicap_regno_ind,
					 :verified_stat:verified_stat_ind, :physical_rest_code:physical_rest_code_ind,
					 :record_srno:record_srno_ind;

			if (NO_DATA_FOUND)
			{
				break;
			}
			else if (SQLCODE != 0)
			{
				EXEC SQL CLOSE license_details;

				if (SQLCODE != 0)
				{
#ifdef DEBUG
					userlog(" insert_into_appnt_jpj_lic_info : Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
#endif
					strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO");
					sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;

					log_error(ctx);
					
					return CURSOR_CLOSE_ERROR;
				}

#ifdef DEBUG
				userlog(" insert_into_appnt_jpj_lic_info : Unable to fetch data from JPJ_LIC_INFO : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Unable to fetch data from JPJ_LIC_INFO");
				sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info: Unable to fetch data from JPJ_LIC_INFO : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return CURSOR_FETCH_ERROR;
			}

#ifdef DEBUG
			userlog(" insert_into_appnt_jpj_lic_info : Fetch cursor successfull");
#endif
		load_chip_flag = YES;	/* Set Load on chip indicator to YES by default */
		load_chip_flag_ind = 0;

#ifdef DEBUG
		userlog("insert_into_appnt_jpj_lic_info :License Type  - %s ",license_type);
		userlog("insert_into_appnt_jpj_lic_info :License Class - %s ",license_class);
		userlog("insert_into_appnt_jpj_lic_info :License Class Usage - %s ",licenseclass_usage);
		userlog("insert_into_appnt_jpj_lic_info :Validity Start Date - %s ",validstart_date);
		userlog("insert_into_appnt_jpj_lic_info :Validity End Date - %s ",validend_date);
		userlog("insert_into_appnt_jpj_lic_info :BlackList - %c",blacklist);
		userlog("insert_into_appnt_jpj_lic_info :Handicapped Registration No - %s ",handicap_regno);
		userlog("insert_into_appnt_jpj_lic_info :Load on chip indiactor - %c ",load_chip_flag);
		userlog("insert_into_appnt_jpj_lic_info :Verified stat - %c ",verified_stat);
		userlog("insert_into_appnt_jpj_lic_info :Physical restrict code - %c ",physical_rest_code);
		userlog("insert_into_appnt_jpj_lic_info :Record Serial Number - %d ",record_srno);
		
#endif
	
			
	EXEC SQL INSERT INTO APPNT_LIC_INFO (APPLID, LICTYPE, LICCLASS, LICUSAGECODE, 
									LICVALIDSTARTDATE, LICVALIDENDDATE, BLFLAG,
									HANDICVEHREGNO, LOADONCHIPIND, VERIFIEDSTATUS,
									PHYRESTRICTCODE, RECORDSERNO)
			 VALUES (:appl_id, :license_type:license_type_ind, :license_class:license_class_ind,
					 :licenseclass_usage:licenseclass_usage_ind , 
					 TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY'), 
					 TO_DATE(:validend_date:validend_date_ind, 'DDMMYYYY'), :blacklist:blacklist_ind,
					 :handicap_regno:handicap_regno_ind, :load_chip_flag:load_chip_flag_ind,
					 :verified_stat:verified_stat_ind, :physical_rest_code:physical_rest_code_ind,
					 :record_srno:record_srno_ind);

		
		if(SQLCODE != 0 && SQLCODE != -1)
		{
			EXEC SQL CLOSE license_details;

			if (SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" insert_into_appnt_jpj_lic_info : Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO");
				sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return CURSOR_CLOSE_ERROR;
			}

#ifdef DEBUG
			userlog(" insert_into_appnt_jpj_lic_info : Insert into APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Insert into APPNT_LIC_INFO failed");
			sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info: Insert into APPNT_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return INSERT_ERROR;
		}

	}

	EXEC SQL CLOSE license_details;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" insert_into_appnt_jpj_lic_info : Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO");
		sprintf(excep_log.error_msg, "insert_into_appnt_jpj_lic_info: Unable to close cursor for fetching data from JPJ_LIC_INFO : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return CURSOR_CLOSE_ERROR;
	}
#ifdef DEBUG
		userlog("insert_into_appnt_jpj_lic_info : Records inserted successfully");
#endif
	
	return SUCCESS;

}

/********************************************************************************/
/* Function name: perform_common_jpj_checks										*/
/* Description	: This function decides whether the license info is to be loaded*/
/*				  on the chip or not											*/
/* Input		: Application id, KPT no, JPN trasnaction type					*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int perform_common_jpj_checks(char *application_id, char *kptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char appl_date[DATE_SIZE] = {0};
	char kpt_no[KPT_SIZE] = {0};
	char appl_stat = 0;
	char lic_type[LIC_TYPE_SIZE] = {0};
	int status = 0;
	varchar error_msg[ERROR_MSG_SIZE] = {0};
	char prb_lic[LIC_TYPE_SIZE] = {0};
	varchar lic_id[LIC_ID_SIZE] = {0};
	char owner_cat = 0;
	int card_stat_active = 0;
	int card_stat_lost = 0;
	varchar prev_ag_on_chip[AGENCY_ON_CHIP_SIZE] = {0};
	char pdl_renew_type = 0;

	short appl_stat_ind = -1;
	char validstart_date[DATE_SIZE] = {0};
	char validend_date[DATE_SIZE] = {0};
	char suspstart_date[DATE_SIZE] = {0};
	char suspend_date[DATE_SIZE] = {0};
	char revokstart_date[DATE_SIZE] = {0};
	char revokend_date[DATE_SIZE] = {0};

	float expiry_period = 0;
	float susp_period = 0;
	float revok_period = 0;
	float susp_valid_period = 0;
	char print_mdl_flag = 0;
	char load_on_chip = 0;
	int lic_count = 0;
	char pdl_lic[LIC_TYPE_SIZE] = {0};
	char psv_lic[LIC_TYPE_SIZE] = {0};
	char gdl_lic[LIC_TYPE_SIZE] = {0};
	int lic_type_count = 0;
	int txn_type = 0;
	varchar agencyonchip[AGENCY_ON_CHIP_SIZE] = {0};
	char verified_stat = 0;

	char load_dl_flag = 0;
		
	short lic_id_ind = -1;
	short owner_cat_ind = -1;
	short kpt_no_ind = -1;
	short appl_date_ind = -1;
	short validstart_date_ind  = -1;
	short validend_date_ind  = -1;
	short suspstart_date_ind  = -1;
	short suspend_date_ind  = -1;
	short revokstart_date_ind  = -1;
	short revokend_date_ind  = -1;
	short error_msg_ind  = -1;
	short txn_type_ind  = -1;
	short agencyonchip_ind  = -1;
	short verified_stat_ind = -1;
	short prev_ag_on_chip_ind = -1;
	short pdl_renew_type_ind = -1;
	
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	int count = 0 ;
	int ret_code  = 0;
	char check_cdl_verified = NO;

	LICENSE_DATE_INFO_T lic;

	char cdl_update = YES;
	char prb_update = YES;
	
	/* Populate the host variables	*/

	strcpy(appl_id, application_id);

	if (0 != strcmp(kptno, ""))
	{
		strcpy(kpt_no, kptno);
		kpt_no_ind = 0;
	}

	print_mdl_flag = YES;	/* Default value */

#ifdef DEBUG
	userlog("perform_common_jpj_checks : Appl id - %s", appl_id);
	userlog("perform_common_jpj_checks : KPT no - %s", kpt_no);
#endif

	/* Get application date from APPLICATION */

	EXEC SQL SELECT TO_CHAR(APPLDATE, 'DDMMYYYY'), LOADDL, LICIDNO, OWNERCAT, PDLRENEWTYPE
		INTO :appl_date:appl_date_ind, :load_dl_flag, :lic_id:lic_id_ind, :owner_cat:owner_cat_ind,
			  :pdl_renew_type:pdl_renew_type_ind
		FROM APPLICATION WHERE APPLID = :appl_id;

	if(SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" perform_common_jpj_checks :Selecting Application date from APPLICATION failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"perform_common_jpj_checks: Selecting Application date from APPLICATION failed");
		sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selecting Application date from APPLICATION failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}
	if ( lic_id_ind == -1)
	{
		strcpy(prog_log.remarks,"perform_common_jpj_checks : Select from application failed, Lic ID NULL");
		sprintf(excep_log.error_msg,"perform_common_jpj_checks : Select from application failed, Lic ID NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return LIC_ID_NULL;

	}
	else
	{
		setnull(lic_id);
		lic_id_ind = 0;
	}

	if ( owner_cat_ind == -1)
	{
		strcpy(prog_log.remarks,"perform_common_jpj_checks : Select from application failed, owner_cat NULL");
		sprintf(excep_log.error_msg,"perform_common_jpj_checks : Select from application failed, owner_cat NULL : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return OWNER_CAT_NULL;

	}
	else
	{
		owner_cat_ind = 0;
	}

#ifdef DEBUG
	userlog("perform_common_jpj_checks : Application date - %s", appl_date);
#endif

	memset(&lic, '\0', sizeof(LICENSE_DATE_INFO_T));

	/* Check whether the applicant has the valid license */

	EXEC SQL SELECT COUNT(*) INTO :lic_count FROM APPNT_LIC_INFO
		WHERE APPLID = :appl_id;

	if(SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" perform_common_jpj_checks :Selecting from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"perform_common_jpj_checks: Selecting from APPNT_LIC_INFO failed");
		sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selecting from APPNT_LIC_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

#ifdef DEBUG
	userlog(" perform_common_jpj_checks : License count - %d", lic_count);
#endif
	
	if (lic_count == 0)
		print_mdl_flag = NO;

	if (lic_count > 0)
	{
		for (count =  0; count < 4; count++)
		{
			if (check_cdl_verified == YES)
				break;

			if (0 == count) 
				strcpy(lic_type, PRB_LIC);
			else if (1 == count) 
				strcpy(lic_type, CDL_LIC);
			else if (2 == count) 
				strcpy(lic_type, GDL_LIC);
			else if (3 == count) 
				strcpy(lic_type, PSV_LIC);

				validstart_date_ind  = -1;
				validend_date_ind  = -1;
				suspstart_date_ind  = -1;
				suspend_date_ind  = -1;
				revokstart_date_ind  = -1;
				revokend_date_ind  = -1;
	
			/* Check whether the applicant has the license with given license type */

			EXEC SQL SELECT COUNT(*) INTO :lic_type_count FROM APPNT_LIC_INFO
				WHERE APPLID  = :appl_id
				AND LICTYPE = :lic_type;

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Selecting from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Selecting from APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selecting from APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

#ifdef DEBUG
				userlog(" perform_common_jpj_checks :License type count - %d", lic_type_count);
#endif
			
			if (lic_type_count <= 0)
				continue;

			ret_code = get_license_date_info(application_id, (char *)lic_id.arr, owner_cat, lic_type, &lic,ctx);

			if(SUCCESS != ret_code)
			{
				return ret_code;
			}

			/* Populate the host varibales */

			if ('\0' != lic.validity_start_date[0])
			{
				strcpy(validstart_date, lic.validity_start_date);
				validstart_date_ind  = 0;

			}
			if ('\0' != lic.validity_end_date[0])
			{
				strcpy(validend_date, lic.validity_end_date);
				validend_date_ind  = 0;

			}

			if ('\0' != lic.susp_start_date[0])
			{
				strcpy(suspstart_date, lic.susp_start_date);
				suspstart_date_ind  = 0;

			}

			if ('\0' != lic.susp_end_date[0])
			{
				strcpy(suspend_date, lic.susp_end_date);
				suspend_date_ind  = 0;

			}

			if ('\0' != lic.revok_start_date[0])
			{
				strcpy(revokstart_date, lic.revok_start_date);
				revokstart_date_ind  = 0;

			}

			if ('\0' != lic.revok_end_date[0])
			{
				strcpy(revokend_date, lic.revok_end_date);
				revokend_date_ind  = 0;

			}

#ifdef DEBUG
		userlog("perform_common_jpj_checks : Lic type - %s", lic_type);
		userlog("perform_common_jpj_checks : Validity start date - %s", validstart_date );
		userlog("perform_common_jpj_checks : Validity end date - %s", validend_date );
		userlog("perform_common_jpj_checks : Suspension start date - %s", suspstart_date );
		userlog("perform_common_jpj_checks : Suspension end date - %s", suspend_date );
		userlog("perform_common_jpj_checks : Revocation start date - %s", revokstart_date);
		userlog("perform_common_jpj_checks : Revocation end date - %s", revokend_date);
#endif

			/*Call stored procedure to get differences of License dates with Application Date*/

			EXEC SQL EXECUTE
				BEGIN
				LIC_PERIOD_VALIDATIONS(:appl_date:appl_date_ind, :validend_date:validend_date_ind,:expiry_period,
									   :revokstart_date:revokstart_date_ind,:revokend_date:revokend_date_ind, :revok_period,
									   :suspstart_date:suspstart_date_ind, :suspend_date:suspend_date_ind, :susp_period,
									   :susp_valid_period, :status, :error_msg:error_msg_ind);
				END;
			END-EXEC;

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog("perform_common_jpj_checks : Failed to call stored procedure LIC_PERIOD_VALIDATIONS : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Failed to call stored procedure LIC_PERIOD_VALIDATIONS ");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Failed to call stored procedure LIC_PERIOD_VALIDATIONS : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return STORED_PROC_ERROR;
			}

			if( status != 0)
			{
				setnull(error_msg);
#ifdef DEBUG
				userlog(" perform_common_jpj_checks : Failed to validate license dates : %s", error_msg.arr);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Failed to validate license dates");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Failed to validate license dates : %s", error_msg.arr);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return STORED_PROC_ERROR;
			}

			if (0 == strcmp(lic_type, PRB_LIC))
			{

				if (expiry_period < -12)
				{
					print_mdl_flag = NO;
					prb_update = NO;
				}

				
				if (revok_period > 0)
				{
					print_mdl_flag = NO;
					prb_update = YES;
				}
				
			}
			else if (0 == strcmp(lic_type, CDL_LIC))
			{
				if (expiry_period < -36)
				{
					print_mdl_flag = NO;
					cdl_update = NO;
				}
				else
					print_mdl_flag = YES;

				if (susp_valid_period >= 0)
				{
					if (txn_type == TXN_REPL)
					{
						if (susp_period < -12)
						{
							print_mdl_flag = NO;
							cdl_update = NO;
						}
						else
						{
							print_mdl_flag = YES;
							cdl_update = YES;
						}
					}

				}

			}
			else if ((0 == strcmp(lic_type, GDL_LIC)) ||
						(0 == strcmp(lic_type, PSV_LIC)))
			{
				if (expiry_period < -36)
				{
					load_on_chip = NO;
				}
				else
					load_on_chip = YES;
				
			}

			if (0 == count)
				load_on_chip =	prb_update;
			else if (1 == count)
				load_on_chip =	cdl_update;

#ifdef DEBUG
			userlog(" perform_common_jpj_checks : Load on chip for %s : %c", lic_type, load_on_chip);
#endif

			/* Check verified status */
			EXEC SQL SELECT DISTINCT(VERIFIEDSTATUS) INTO 
				:verified_stat:verified_stat_ind
				FROM APPNT_LIC_INFO 
				WHERE APPLID  = :appl_id
				AND LICTYPE = :lic_type
				AND ROWNUM = 1;

		
			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Selecting Verified status from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Selecting Verified status from APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selecting Verified status from APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}
#ifdef DEBUG
			userlog("perform_common_jpj_checks : Verified status - %c", verified_stat);
#endif

			if (0 == strcmp(lic_type, CDL_LIC))
			{
				if ((verified_stat - '0') < 6)
				{
					load_on_chip = NO;
					check_cdl_verified = YES;
				}
				
			}
			else if ((0 == strcmp(lic_type, PSV_LIC)) 
			    	||(0 == strcmp(lic_type, GDL_LIC)))
			{
				if ((verified_stat - '0') < 6)
				{
					load_on_chip = NO;
				}
				
			}
			
			
			EXEC SQL UPDATE APPNT_LIC_INFO
				SET LOADONCHIPIND = :load_on_chip
				WHERE APPLID  = :appl_id
				AND LICTYPE = :lic_type;
		
			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Updation on APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Updation on APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updation on APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return UPDATE_ERROR;
			}
			else if ((strcmp(lic_type, CDL_LIC) == 0) && (cdl_update == YES))	/* If Load on chip for CDL is YES */
			{																/* the same for PRB should be NO */
				strcpy(prb_lic, PRB_LIC);

				EXEC SQL UPDATE APPNT_LIC_INFO
					SET LOADONCHIPIND = 'N'
					WHERE APPLID  = :appl_id
					AND LICTYPE = :prb_lic;
			
			//	if(SQLCODE != 0 && !NO_DATA_FOUND)
				if((SQLCODE) != 0 && (SQLCODE != 1403))
				{
#ifdef DEBUG
					userlog(" perform_common_jpj_checks :Updation on APPNT_LIC_INFO for PRB failed : %s", SQLMSG);
#endif
					strcpy(prog_log.remarks,"perform_common_jpj_checks: Updation on APPNT_LIC_INFO for PRB failed");
					sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updation on APPNT_LIC_INFO for PRB failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;

					log_error(ctx);
					
					return UPDATE_ERROR;
				}
			}
#ifdef DEBUG
			userlog("perform_common_jpj_checks : Updated Load on chip indicator in APPNT_LIC_INFO successfully for %s license", lic_type);
#endif

		}	/* End of for (count =  0; count < 4; count++) */

			
	}

#ifdef DEBUG
		userlog(" perform_common_jpj_checks :Print MDL flag : %c", print_mdl_flag);
#endif

	if (NO == print_mdl_flag)
	{
		EXEC SQL UPDATE APPNT_JPJ_INFO 
			SET PRINTMDL  = :print_mdl_flag
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
#ifdef DEBUG
			userlog(" perform_common_jpj_checks :Updation on APPNT_JPJ_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"perform_common_jpj_checks: Updation on APPNT_JPJ_INFO failed");
			sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updation on APPNT_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}
#ifdef DEBUG
		userlog("perform_common_jpj_checks : Updated Print MDL flag in APPNT_JPJ_INFO successfully");
#endif
	}
	else	/* If Print MDL = YES */
	{
		/* Check whether applicant has only PDL license */

		strcpy (pdl_lic, PDL_LIC);
		lic_count = 0;

		EXEC SQL SELECT COUNT(*) INTO :lic_count
			FROM APPNT_LIC_INFO 
		WHERE APPLID = :appl_id
		AND LICTYPE != :pdl_lic
		AND LOADONCHIPIND = 'Y';

		if(SQLCODE != 0)
		{
#ifdef DEBUG
			userlog(" perform_common_jpj_checks :Select from APPNT_JPJ_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"perform_common_jpj_checks: Select from APPNT_JPJ_INFO failed");
			sprintf(excep_log.error_msg, "perform_common_jpj_checks: Select from APPNT_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

#ifdef DEBUG
			userlog(" perform_common_jpj_checks :License count in APPNT_JPJ_INFO - %d", lic_count);
#endif
		
		if (lic_count == 0)	/* If applicant has only PDL license or any license */
		{					/* with Load on chip flag NO					    */
			print_mdl_flag = NO;

			EXEC SQL UPDATE APPNT_JPJ_INFO 
					SET PRINTMDL  = :print_mdl_flag
				WHERE APPLID = :appl_id;

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Updation on APPNT_JPJ_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Updation on APPNT_JPJ_INFO failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updation on APPNT_JPJ_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return UPDATE_ERROR;
			}
#ifdef DEBUG
			userlog("perform_common_jpj_checks : Updated Print MDL flag in APPNT_JPJ_INFO successfully");
#endif
		}

	}

	if (load_dl_flag == NO)
	{
		/* Update the Agency on chip and Print MDL flags */

		EXEC SQL UPDATE APPNT_JPJ_INFO 
			SET PRINTMDL  = 'N'
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
#ifdef DEBUG
			userlog(" perform_common_jpj_checks :Updating Print MDL flag in APPNT_JPJ_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"perform_common_jpj_checks: Updating Print MDL flag in APPNT_JPJ_INFO failed");
			sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updating Print MDL flag in APPNT_JPJ_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}

#ifdef DEBUG
		userlog("perform_common_jpj_checks : Load DL flag - %c", load_dl_flag);
#endif
		
		EXEC SQL UPDATE APPNT_LIC_INFO 
			SET LOADONCHIPIND = 'N'
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
#ifdef DEBUG
			userlog(" perform_common_jpj_checks :Updating Load on chip flag in APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"perform_common_jpj_checks: Updating Load on chip flag in APPNT_LIC_INFO failed");
			sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updating Load on chip flag in APPNT_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}

	}

	/* Check added for PDL renew - 14/12/2001 */

	card_stat_active = ACTIVE;
	card_stat_lost = LOST;

	/* check if DL info is being loaded on the chip for the first time */
	EXEC SQL SELECT AGENCYONCHIP INTO :prev_ag_on_chip:prev_ag_on_chip_ind 
		FROM CARD_STATUS
	WHERE KPTNO = :kpt_no:kpt_no_ind
	AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS 
							WHERE KPTNO = :kpt_no:kpt_no_ind
							AND CARDSTAT IN (:card_stat_active, :card_stat_lost));

	//if (SQLCODE != 0 && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
#ifdef DEBUG
		userlog(" perform_common_jpj_checks : Selecting Agency on chip from CARD_STATUS failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"perform_common_jpj_checks: Selecting Agency on chip from CARD_STATUS failed");
		sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selecting Agency on chip from CARD_STATUS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
 
     }

	if (0 == prev_ag_on_chip_ind)
	{
		setnull(prev_ag_on_chip);
		
		if (pdl_renew_type == '1' && prev_ag_on_chip.arr[3] == '0') /* If JPJ byte is '0' then this is first time DL load */
		{
			strcpy (pdl_lic, PDL_LIC);

			EXEC SQL UPDATE APPNT_LIC_INFO
					SET LOADONCHIPIND = 'N'
				WHERE APPLID = :appl_id
				  AND LICTYPE = :pdl_lic
				  AND LICCLASS NOT IN ('B ', 'B1', 'B2', 'B3', 'C ');
		}
	}

	
	lic_count = 0;

		/* Decide if the JPJ info is loaded on chip */

		EXEC SQL SELECT COUNT(*) INTO :lic_count
			FROM APPNT_LIC_INFO 
		WHERE APPLID = :appl_id
		AND LOADONCHIPIND = 'Y';

		if(SQLCODE != 0)
		{
#ifdef DEBUG
			userlog(" perform_common_jpj_checks :Selection from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"perform_common_jpj_checks: Selection from APPNT_LIC_INFO failed");
			sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selection from APPNT_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

		if (lic_count > 0)
		{
			EXEC SQL 
				SELECT AGENCYONCHIP INTO :agencyonchip:agencyonchip_ind
				FROM CARD_STATUS 
				WHERE APPLID = :appl_id
				AND KPTNO = :kpt_no 
				AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM
				CARD_STATUS WHERE APPLID = :appl_id
				AND KPTNO = :kpt_no);

			if(SQLCODE != 0)
			{
	#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Selection AGENCYONCHIP from CARD_STATUS failed : %s", SQLMSG);
	#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Selection AGENCYONCHIP from CARD_STATUS failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Selection AGENCYONCHIP from CARD_STATUS failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

			if (agencyonchip_ind == -1)
			{
				strcpy(prog_log.remarks,"perform_common_jpj_checks : AGENCYONCHIP is NULL");
				sprintf(excep_log.error_msg,"perform_common_jpj_checks : AGENCYONCHIP is NULL: %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;
				log_error(ctx);
				return INVALID_AGENCY_IND;
			}
			else
			{
				agencyonchip.arr[JPJ_ID - '0'] = '1';
				agencyonchip_ind = 0;
				setnull(agencyonchip);
			}
	

			EXEC SQL
				UPDATE CARD_STATUS
				SET AGENCYONCHIP = :agencyonchip:agencyonchip_ind
				WHERE APPLID  = :appl_id
				AND KPTNO = :kpt_no 
				AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM
				CARD_STATUS WHERE APPLID = :appl_id
				AND KPTNO = :kpt_no);
		
			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" perform_common_jpj_checks :Updation on CARD_STATUS failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"perform_common_jpj_checks: Updation on CARD_STATUS failed");
				sprintf(excep_log.error_msg, "perform_common_jpj_checks: Updation on CARD_STATUS failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return UPDATE_ERROR;
			}

		}
#ifdef DEBUG
	userlog(" perform_common_jpj_checks :agency on chip  - %s", agencyonchip.arr);
#endif

	return SUCCESS;
}

/************************************************************************************/
/* Function Name: get_license_date_info()											*/
/* Description	: This function get the JPJ Date Details from the GSCB database     */
/*				  for the Applicant.												*/
/* Input		: KPTNo, License Type,  Reference to Structure LICENSE_DATE_INFO_T  */
/* Return values: SUCCESS / Error code												*/
/* Limitations	: None																*/
/************************************************************************************/	
int get_license_date_info(char *application_id, char *licid, char ownercat, char *license_type,LICENSE_DATE_INFO_T *lic_date,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	varchar lic_id[LIC_ID_SIZE] = {0};
	char owner_cat = 0;
	char lic_type[LIC_TYPE_SIZE] = {0};
	char validstart_date[DATE_SIZE] = {0};
	char validend_date[DATE_SIZE] = {0};
	char suspstart_date[DATE_SIZE] = {0};
	char suspend_date[DATE_SIZE] = {0};
	char revocstart_date[DATE_SIZE] = {0};
	char revocend_date[DATE_SIZE] = {0};
	
	short lic_id_ind = -1;
	short owner_cat_ind = -1;
	short validstart_date_ind  = -1;
	short validend_date_ind  = -1;
	short suspstart_date_ind  = -1;
	short suspend_date_ind  = -1;
	short revocstart_date_ind  = -1;
	short revocend_date_ind  = -1;
	
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	/* Populate the host variables	*/

	strcpy(appl_id, application_id);

	if (0 != strcmp(licid, ""))
	{
		strcpy((char *)lic_id.arr, licid);
		setlen(lic_id);
		lic_id_ind = 0;
	}

	if ('\0' != ownercat)
	{
		owner_cat = ownercat;
		owner_cat_ind = 0;
	}

	
	strcpy(lic_type, license_type);

#ifdef DEBUG
	userlog("get_license_date_info : Getting dates for %s license", lic_type);
#endif

	/*Selecting the Validity Start and End date for License Type from JPJ_LIC_INFO*/

	EXEC SQL SELECT	TO_CHAR(MAX(LICVALIDSTARTDATE),'DDMMYYYY'),
					TO_CHAR(MAX(LICVALIDENDDATE),'DDMMYYYY')
				INTO :validstart_date:validstart_date_ind, 
					 :validend_date:validend_date_ind 
				FROM APPNT_LIC_INFO 
				WHERE APPLID = :appl_id
				AND LICTYPE = :lic_type;

	//if(SQLCODE != 0 && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
#ifdef DEBUG
		userlog(" get_license_date_info : Selecting dates from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"get_license_date_info: Selecting dates from APPNT_LIC_INFO failed");
		sprintf(excep_log.error_msg, "get_license_date_info: Selecting dates from APPNT_LIC_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}


		if (-1 != validstart_date_ind)
			strcpy(lic_date->validity_start_date, validstart_date);

		if (-1 != validend_date_ind)
			strcpy(lic_date->validity_end_date, validend_date);

#ifdef DEBUG
		userlog("get_license_date_info : Validity start date - %s", lic_date->validity_start_date);
		userlog("get_license_date_info : Validity end date - %s", lic_date->validity_end_date);
#endif

	/*Selecting the Suspension Start and End date for License Type from JPJ_LIC_SUSPENS */

	EXEC SQL SELECT	TO_CHAR(MAX(LICSUSPSTARTDATE),'DDMMYYYY'),
					TO_CHAR(MAX(LICSUSPENDDATE),'DDMMYYYY')
				INTO :suspstart_date:suspstart_date_ind,
					 :suspend_date:suspend_date_ind
			 FROM JPJ_LIC_SUSPENS
			 WHERE LICIDNO = :lic_id:lic_id_ind
			 AND OWNERCAT = :owner_cat:owner_cat_ind
			 AND LICTYPE = :lic_type;

	//if(SQLCODE != 0 && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
#ifdef DEBUG
		userlog(" get_license_date_info : Selecting dates from JPJ_LIC_SUSPENS failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"get_license_date_info: Selecting dates from JPJ_LIC_SUSPENS failed");
		sprintf(excep_log.error_msg, "get_license_date_info: Selecting dates from JPJ_LIC_SUSPENS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}


		if (-1 != suspstart_date_ind)
			strcpy(lic_date->susp_start_date, suspstart_date);

		if (-1 != suspend_date_ind)
			strcpy(lic_date->susp_end_date, suspend_date);

#ifdef DEBUG
		userlog("get_license_date_info : Suspension start date - %s", lic_date->susp_end_date);
		userlog("get_license_date_info : Suspension end date - %s", lic_date->susp_end_date);
#endif

	/*Selecting the Revocation Start and End date for License Type from JPJ_LIC_REVOKE*/

	EXEC SQL SELECT	TO_CHAR(MAX(LICREVOKSTARTDATE),'DDMMYYYY'),
					TO_CHAR(MAX(LICREVOKENDDATE),'DDMMYYYY')
				INTO :revocstart_date:revocstart_date_ind,
					 :revocend_date:revocend_date_ind 
				FROM JPJ_LIC_REVOKE
				WHERE LICIDNO = :lic_id:lic_id_ind
				AND OWNERCAT = :owner_cat:owner_cat_ind
				AND LICTYPE = :lic_type;

	//if(SQLCODE != 0 && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
#ifdef DEBUG
		userlog(" get_license_date_info : Selecting dates from JPJ_LIC_REVOKE failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"get_license_date_info: Selecting dates from JPJ_LIC_REVOKE failed");
		sprintf(excep_log.error_msg, "get_license_date_info: Selecting dates from JPJ_LIC_REVOKE failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

		if (-1 != revocstart_date_ind)
			strcpy(lic_date->revok_start_date, revocstart_date);

		if (-1 != revocend_date_ind)
			strcpy(lic_date->revok_end_date, revocend_date);

#ifdef DEBUG
		userlog("get_license_date_info : Revocation start date - %s", lic_date->revok_start_date);
		userlog("get_license_date_info : Revocation end date - %s", lic_date->revok_end_date);
#endif

	return SUCCESS;
}


int fetch_txncode(char *application_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	int lic_cnt = 0;
	int txn_sr_no = 0;
	char txn_code[TRANSACTION_CODE_SIZE] = {0};
	int txn_type = 0;
	char txn_date[DATE_SIZE] = {0};
	char lic_type[LIC_TYPE_SIZE] = {0};
	char lic_class[LIC_CLS_SIZE] = {0};
	char lic_usage[LIC_USAGE_SIZE] = {0};
	int lic_validity = 0;
	int pay_sr_no = 0;
	int qc_sr_no = 0;
	char qc_flag = 0;
	

	short txn_sr_no_ind = -1;
	short txn_code_ind = -1;
	short txn_type_ind = -1;
	short txn_date_ind = -1;
	short lic_type_ind = -1;
	short lic_class_ind = -1;
	short lic_usage_ind = -1;
	short lic_validity_ind = -1;
	short pay_sr_no_ind = -1;
	short qc_sr_no_ind = -1;
	short qc_flag_ind = -1;

sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	TXN_DETAILS_T *txn_details_orig;
	TXN_DETAILS_T *txn_details_temp ;
	TXN_DETAILS_T *txn_details;
	int buffer_size = 0;
	int txn_count = 0;
	int txn_code_numeric =0;
	int count = 0;
	int ret_code = 0;
    char lic_delete_flag = NO;
	/* Populate the variables	*/

	strcpy(appl_id, application_id);
	txn_type = TXN_LIC;

#ifdef DEBUG
	userlog("fetch_txncode : Appl id - %s", appl_id);
#endif

	
	EXEC SQL SELECT COUNT(*) INTO :lic_cnt 
		FROM APPL_TXN A, TXN_CODE B
	WHERE A.APPLID = :appl_id
		AND A.TXNCANCELCODE IS NULL
		AND A.TXNCODE = B.TXNCODE
		AND B.TXNTYPE = :txn_type
		AND A.LEGUPDFLAG = 'N';
		
	if (SQLCODE != 0)
	{
	#ifdef DEBUG
		userlog(" fetch_txncode : Select from APPL_TXN failed : %s", SQLMSG);
	#endif
		strcpy(prog_log.remarks,"fetch_txncode: Select from APPL_TXN failed ");
		sprintf(excep_log.error_msg, "fetch_txncode: Select from APPL_TXN failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}
	else if (0 == lic_cnt )
	{
#ifdef DEBUG
		userlog(" fetch_txncode : No transaction exists for the applicant");
#endif
		
		return GMPC_GOOD;

	}
	
#ifdef DEBUG
		userlog(" fetch_txncode : Txn count - %d", lic_cnt);
#endif

	txn_count = lic_cnt;

	buffer_size = lic_cnt*(sizeof(TXN_DETAILS_T));

	txn_details_orig = (TXN_DETAILS_T *)malloc(buffer_size);

	if (NULL == txn_details_orig)
	{
#ifdef DEBUG
		userlog("fetch_txncode : Allocation of memory for storing transaction details failed");
#endif
		strcpy(prog_log.remarks,"fetch_txncode: Allocation of memory for storing transaction details failed");
		strcpy(excep_log.error_msg, "fetch_txncode: Allocation of memory for storing transaction details failed");
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return MALLOC_ERROR;
	}

	txn_details = txn_details_orig;
	txn_details_temp = txn_details_orig;

#ifdef DEBUG
	userlog("fetch_txncode - %X", txn_details );
#endif

	/* Declare the cursor for fetching details of all the transactions */

	EXEC SQL DECLARE txn_info CURSOR FOR 
	SELECT A.TXNSERNO, A.TXNCODE, A.LICTYPE, A.LICCLASS, A.LICUSAGECODE, A.LICVALIDPERIOD, 
		   A.PAYMSERNO, A.QCSERNO, A.QCFLAG, TO_CHAR(A.TXNDATE, 'DDMMYYYY')
		FROM APPL_TXN A, TXN_CODE B
		WHERE A.APPLID = :appl_id
			AND A.TXNCANCELCODE IS NULL
			AND A.LEGUPDFLAG = 'N'
			AND B.TXNCODE = A.TXNCODE
			AND B.TXNTYPE = :txn_type;


	EXEC SQL OPEN txn_info;

	if (SQLCODE != 0)
	{
	#ifdef DEBUG
		userlog(" fetch_txncode : Unable to open cursor for fetching data from APPL_TXN : %s", SQLMSG);
	#endif
		strcpy(prog_log.remarks,"fetch_txncode: Unable to open cursor for fetching data from APPL_TXN");
		sprintf(excep_log.error_msg, "fetch_txncode: Unable to open cursor for fetching data from APPL_TXN : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return CURSOR_OPEN_ERROR;
	}

#ifdef DEBUG
		userlog(" fetch_txncode : Open cursor successfull");
#endif

	for(;; txn_details_temp++)
	{

		EXEC SQL FETCH txn_info
			INTO :txn_sr_no:txn_sr_no_ind, :txn_code:txn_code_ind, :lic_type:lic_type_ind, 
				 :lic_class:lic_class_ind, :lic_usage:lic_usage_ind, :lic_validity:lic_validity_ind,
				 :pay_sr_no:pay_sr_no_ind, :qc_sr_no:qc_sr_no_ind, :qc_flag:qc_flag_ind, 
				 :txn_date:txn_date_ind;

		
		if (NO_DATA_FOUND)
		{
			break;
		}
		else if (SQLCODE != 0)
		{
			EXEC SQL CLOSE txn_info;

			if (SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" fetch_txncode : Unable to close cursor for fetching data from APPL_TXN : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"fetch_txncode: Unable to close cursor for fetching data from APPL_TXN");
				sprintf(excep_log.error_msg, "fetch_txncode: Unable to close cursor for fetching data from APPL_TXN : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				free(txn_details_orig);
				return CURSOR_CLOSE_ERROR;
			}

#ifdef DEBUG
			userlog(" fetch_txncode : Unable to fetch data from APPL_TXN : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"fetch_txncode: Unable to fetch data from APPL_TXN");
			sprintf(excep_log.error_msg, "fetch_txncode: Unable to fetch data from APPL_TXN : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			free(txn_details_orig);
			return CURSOR_FETCH_ERROR;
		}

#ifdef DEBUG
		userlog(" fetch_txncode : Fetch cursor successfull");
#endif

		memset(txn_details_temp, '\0', sizeof(TXN_DETAILS_T));

		/* Copy the values into structure */

		if ( 0 ==  txn_sr_no_ind )
			txn_details_temp->txn_sr_no = txn_sr_no	 ;

		if ( 0 == txn_type_ind )
			txn_details_temp->txn_type = txn_type ;


		if ( 0 == lic_validity_ind )
			txn_details_temp->lic_validity = lic_validity ;

		if ( 0 == pay_sr_no_ind )
			txn_details_temp->pay_sr_no = pay_sr_no	 ;

		if ( 0 == qc_sr_no_ind )
			txn_details_temp->qc_sr_no = qc_sr_no ;

		if ( 0 == qc_flag_ind )
			txn_details_temp->qc_flag = qc_flag;

		if ( 0 == txn_code_ind )
			strcpy(txn_details_temp->txn_code, txn_code);

		if ( 0 == txn_date_ind )
			strcpy(txn_details_temp->txn_date, txn_date);

		if ( 0 == lic_type_ind )
			strcpy(txn_details_temp->lic_type, lic_type);

		if ( 0 == lic_class_ind )
			strcpy(txn_details_temp->lic_class, lic_class);

		if ( 0 == lic_usage_ind )
			strcpy(txn_details_temp->lic_usage, lic_usage);

#ifdef DEBUG
		userlog("fetch_txncode : Txn ser no - %d", txn_details_temp->txn_sr_no);
		userlog("fetch_txncode : Txn code - %s", txn_details_temp->txn_code);
		userlog("fetch_txncode : Txn type - %d", txn_details_temp->txn_type);
		userlog("fetch_txncode : Lic type - %s", txn_details_temp->lic_type);
		userlog("fetch_txncode : Lic class - %s", txn_details_temp->lic_class);
		userlog("fetch_txncode : Lic usage - %s", txn_details_temp->lic_usage);
		userlog("fetch_txncode : Lic validity - %d", txn_details_temp->lic_validity);
		userlog("fetch_txncode : Payment ser no - %d", txn_details_temp->pay_sr_no);
		userlog("fetch_txncode : QC flag - %c", txn_details_temp->qc_flag);
		userlog("fetch_txncode : QC ser no - %d", txn_details_temp->qc_sr_no);
		userlog("fetch_txncode : Txn date - %s", txn_details_temp->txn_date);
#endif

	}

	EXEC SQL CLOSE txn_info;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" fetch_txncode : Unable to close cursor for fetching data from APPL_TXN : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"fetch_txncode: Unable to close cursor for fetching data from APPL_TXN");
		sprintf(excep_log.error_msg, "fetch_txncode: Unable to close cursor for fetching data from APPL_TXN : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		free(txn_details_orig);
		return CURSOR_CLOSE_ERROR;
	}

	/* Insert the info into APPNT_LIC_INFO */

	for (count = 0; count < txn_count; count++, txn_details++)
	{
		/* Insert/Update applicant's new License data submitted at workstation into APPNT_LIC_INFO table */

		txn_code_numeric = atoi(txn_details->txn_code);

		if(txn_code_numeric == TXN_PDL_NEW || txn_code_numeric == TXN_PDL_CLASS_ADD ||
		   txn_code_numeric == TXN_PRB_NEW || txn_code_numeric == TXN_PRB_CLASS_ADD ||
		   txn_code_numeric == TXN_CDL_NEW || txn_code_numeric == TXN_CDL_CLASS_ADD ||
		   txn_code_numeric == TXN_GDL_NEW || txn_code_numeric == TXN_GDL_CLASS_ADD ||
		   txn_code_numeric == TXN_PSV_NEW || txn_code_numeric == TXN_PSV_CLASS_ADD ||
		   txn_code_numeric == TXN_PDL_RENEW || txn_code_numeric == TXN_CDL_RENEW ||
		   txn_code_numeric == TXN_GDL_RENEW || txn_code_numeric == TXN_PSV_RENEW )

		{
			if (SUCCESS != (ret_code = insert_new_lic_info(application_id, txn_details, &lic_delete_flag,ctx)))
			{
#ifdef DEBUG
				userlog("fetch_txncode : insert_new_lic_info() failed with %d", ret_code);
#endif
				free(txn_details_orig);
				return ret_code;
			}
		}
	}

	free(txn_details_orig);
	return SUCCESS;
}

int insert_new_lic_info(char *application_id, TXN_DETAILS_T *txn_details, char *lic_delete_flag,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char txn_code[TRANSACTION_CODE_SIZE] = {0};
	char license_type[LIC_TYPE_SIZE] = {0};
	char license_class[LIC_CLS_SIZE] = {0};
	char licenseclass_usage[LIC_USAGE_SIZE] = {0};
	char validstart_date[DATE_SIZE] = {0};
	char validend_date[DATE_SIZE] = {0};
	int	validity_period = 0;
	char verified_stat = 0;
	char load_chip_flag = 0;
	
	long days_diff = 0;
	int lic_cnt = 0;
	int record_srno = 0;

	short txn_code_ind = -1;
	short license_type_ind = -1;
	short license_class_ind = -1;
	short licenseclass_usage_ind = -1;
	short validstart_date_ind = -1;
	short validend_date_ind = -1;
	short validity_period_ind = -1;
	short verified_stat_ind = -1;
	short load_chip_flag_ind = -1;
	short record_srno_ind = -1;

sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	int ret_code  = 0;
	int txn_code_numeric = 0;
	int insert_flag = 0;
	char old_lic_class[LIC_CLS_SIZE] = {"\0"};
		
	/* Populate the variables	*/

	strcpy(appl_id, application_id);

#ifdef DEBUG
	userlog("insert_new_lic_info : Appl id - %s", appl_id);
	userlog("insert_new_lic_info : Insert flag - %d", insert_flag);
#endif

	if (0 != txn_details->txn_code[0] )
	{
		strcpy(txn_code, txn_details->txn_code);
		txn_code_ind = 0;
	}

	if (0 != txn_details->lic_type[0] )
	{
		strcpy(license_type, txn_details->lic_type);
		license_type_ind = 0;
	}

	if (0 != txn_details->lic_class[0] )
	{
		strcpy(license_class, txn_details->lic_class);
		license_class_ind = 0;
	}

	if (0 != txn_details->lic_usage[0] )
	{
		strcpy(licenseclass_usage, txn_details->lic_usage);
		licenseclass_usage_ind = 0;
	}

	if (0 < txn_details->lic_validity)
	{
		validity_period	= txn_details->lic_validity;
		validity_period_ind = 0;
	}

	txn_code_numeric = atoi(txn_details->txn_code);

#ifdef DEBUG
		userlog("insert_new_lic_info :Txn Code  - %s ",txn_code);
		userlog("insert_new_lic_info :License Type  - %s ",license_type);
		userlog("insert_new_lic_info :License Class - %s ",license_class);
		userlog("insert_new_lic_info :License Class Usage - %s ",licenseclass_usage);
		userlog("insert_new_lic_info :Validity period - %d",validity_period);
#endif

	/* Get the maximum record serial no from APPNT_LIC_INFO */

	EXEC SQL SELECT MAX(RECORDSERNO) INTO :record_srno:record_srno_ind
			FROM APPNT_LIC_INFO
		WHERE APPLID = :appl_id;

		//if(SQLCODE != 0 && !NO_DATA_FOUND)
		if((SQLCODE) != 0 && (SQLCODE != 1403))
		{
#ifdef DEBUG
			userlog(" insert_new_lic_info : Selecting maximum Record serial no from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"insert_new_lic_info: Selecting maximum Record serial no from APPNT_LIC_INFO failed");
			sprintf(excep_log.error_msg, "insert_new_lic_info: Selecting maximum Record serial no from APPNT_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}
		

		if (record_srno_ind != 0)
		{
			record_srno = 1;
			record_srno_ind = 0;
		}
		else
		{
			record_srno = record_srno + 1;
		}

	/* Set Validity end date for the license for */
	/* different license transactions			 */

		if(txn_code_numeric == TXN_PDL_NEW || txn_code_numeric == TXN_PRB_NEW ||
		   txn_code_numeric == TXN_CDL_NEW || txn_code_numeric == TXN_GDL_NEW ||
		   txn_code_numeric == TXN_PSV_NEW )
		{

			if (0 != txn_details->txn_date[0] )
			{
				strcpy(validstart_date, txn_details->txn_date);
				validstart_date_ind = 0;
			}

			if(0 < validity_period  && 0 != validstart_date[0])
			{
				ret_code = calculate_lic_validity_date(validity_period, validstart_date, validend_date,ctx);

				if(SUCCESS != ret_code)
				{
					return ret_code;
				}

				if (0 != validend_date[0] )
					validend_date_ind = 0;
				
			}

			verified_stat = '6';
			verified_stat_ind = 0;

			/* Delete the old record for this License type from */
			/* APPNT_LIC_INFO, if any							*/
			
			if (*lic_delete_flag == NO)
			{

				EXEC SQL DELETE FROM APPNT_LIC_INFO
					WHERE APPLID = :appl_id
					AND LICTYPE = :license_type:license_type_ind;

				//if(SQLCODE != 0 && !NO_DATA_FOUND)
				if((SQLCODE) != 0 && (SQLCODE != 1403))
				{
	#ifdef DEBUG
					userlog(" insert_new_lic_info : Deletion of old license record from APPNT_LIC_INFO failed : %s", SQLMSG);
	#endif
					strcpy(prog_log.remarks,"insert_new_lic_info: Deletion of old license record from APPNT_LIC_INFO failed");
					sprintf(excep_log.error_msg, "insert_new_lic_info: Deletion of old license record from APPNT_LIC_INFO failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;

					log_error(ctx);
					
					return DELETE_ERROR;
				}
				

				*lic_delete_flag = YES;
			}
	
			insert_flag = TRUE;

		}
		else if (txn_code_numeric == TXN_PDL_CLASS_ADD
				 || txn_code_numeric == TXN_PRB_CLASS_ADD
				 || txn_code_numeric == TXN_CDL_CLASS_ADD
				 || txn_code_numeric == TXN_GDL_CLASS_ADD
				 || txn_code_numeric == TXN_PSV_CLASS_ADD)
		{
			/* Retrieve Validity start and end dates for the given License */
			/* type from the APPNT_LIC_INFO								   */

			EXEC SQL SELECT DISTINCT TO_CHAR(LICVALIDSTARTDATE, 'DDMMYYYY'),
									 TO_CHAR(LICVALIDENDDATE , 'DDMMYYYY'),
									 VERIFIEDSTATUS
					INTO :validstart_date:validstart_date_ind, :validend_date:validend_date_ind,
						 :verified_stat:verified_stat_ind
					FROM APPNT_LIC_INFO 
				WHERE APPLID = :appl_id
				AND LICTYPE = :license_type:license_type_ind;

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" insert_new_lic_info : Selecting Validity start and end dates from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_new_lic_info: Selecting Validity start and end dates from APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "insert_new_lic_info: Selecting Validity start and end dates from APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

			insert_flag = TRUE;

		}
		else if (txn_code_numeric == TXN_PDL_RENEW 
				 || txn_code_numeric == TXN_CDL_RENEW 
				 || txn_code_numeric == TXN_GDL_RENEW 
				 || txn_code_numeric == TXN_PSV_RENEW )
		{
			if (0 != txn_details->txn_date[0] )
			{
				strcpy(validstart_date, txn_details->txn_date);
				validstart_date_ind = 0;
			}

			/* Retrieve Validity start and end dates for the given License */
			/* type from the APPNT_LIC_INFO								   */

			EXEC SQL SELECT DISTINCT (TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY') - LICVALIDENDDATE), TO_CHAR(LICVALIDENDDATE , 'DDMMYYYY')
				INTO :days_diff, :validend_date:validend_date_ind
					FROM APPNT_LIC_INFO 
				WHERE APPLID = :appl_id
				AND LICTYPE = :license_type:license_type_ind;

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" insert_new_lic_info : Selecting Validity start and end dates from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_new_lic_info: Selecting Validity start and end dates from APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "insert_new_lic_info: Selecting Validity start and end dates from APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

#ifdef DEBUG
			userlog("insert_new_lic_info : Days difference - %ld", days_diff);
#endif
			insert_flag = FALSE;
		}

	
		if(TRUE == insert_flag)
		{
#ifdef DEBUG
			userlog("insert_new_lic_info :Validity Start Date - %s",validstart_date);
			userlog("insert_new_lic_info :Validity End Date - %s",validend_date);
			userlog("insert_new_lic_info :Verified status - %c",verified_stat);
#endif

			if ( txn_code_numeric == TXN_GDL_CLASS_ADD
				 || txn_code_numeric == TXN_PSV_CLASS_ADD)
			{
				/* Check if the new class to be added already exists in APPNT_LIC_INFO */

				EXEC SQL SELECT COUNT(*) INTO :lic_cnt
						FROM APPNT_LIC_INFO
					WHERE APPLID = :appl_id
					AND LICTYPE = :license_type:license_type_ind
					AND LICCLASS = :license_class:license_class_ind;

				if(SQLCODE != 0)
				{
#ifdef DEBUG
					userlog(" insert_new_lic_info : Selecting license with given class from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
					strcpy(prog_log.remarks,"insert_new_lic_info: Selecting with given class from APPNT_LIC_INFO failed");
					sprintf(excep_log.error_msg, "insert_new_lic_info: Selecting with given class from APPNT_LIC_INFO failed : %s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;

					log_error(ctx);
					
					return SELECT_ERROR;
				}

#ifdef DEBUG
				userlog("insert_new_lic_info : License count - %d", lic_cnt);
#endif
				if (lic_cnt > 0)
				{
					/* Update the new usage for the class */

					EXEC SQL UPDATE APPNT_LIC_INFO
							SET LICUSAGECODE = :licenseclass_usage:licenseclass_usage_ind
						WHERE APPLID = :appl_id
						AND LICTYPE = :license_type:license_type_ind
						AND LICCLASS = :license_class:license_class_ind;

					if(SQLCODE != 0)
					{
#ifdef DEBUG
						userlog(" insert_new_lic_info : Updating Usage for given class in APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
						strcpy(prog_log.remarks,"insert_new_lic_info: Updating Usage for given class in APPNT_LIC_INFO failed");
						sprintf(excep_log.error_msg, "insert_new_lic_info: Updating Usage for given class in APPNT_LIC_INFO failed : %s", SQLMSG);
						excep_log.termination_flag = YES;
						excep_log.severity = FATAL;

						log_error(ctx);
						
						return UPDATE_ERROR;
					}

#ifdef DEBUG
					userlog("insert_new_lic_info : Updated Class usage successfully");
#endif
					return SUCCESS;
				}
				else
				{
					/* Get the old class for the given license type */
					
					if (SUCCESS != (ret_code = 	delete_old_class(application_id, txn_details, &record_srno,ctx)))
					{
#ifdef DEBUG
						userlog("insert_new_lic_info : delete_old_class() failed with %d", ret_code);
#endif
						return ret_code;
					}

				}

			}

#ifdef DEBUG
		userlog(" insert_new_lic_info : Record serial no - %d", record_srno);
#endif

			load_chip_flag = YES;	/* Set Load on chip indicator to YES by default */
			load_chip_flag_ind = 0;


			EXEC SQL INSERT INTO APPNT_LIC_INFO (APPLID, LICTYPE, LICCLASS, LICUSAGECODE, 
									LICVALIDSTARTDATE, LICVALIDENDDATE, VERIFIEDSTATUS,
									LOADONCHIPIND, RECORDSERNO)
			 VALUES (:appl_id, :license_type:license_type_ind, :license_class:license_class_ind,
					 :licenseclass_usage:licenseclass_usage_ind , 
					 TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY'), 
					 TO_DATE(:validend_date:validend_date_ind, 'DDMMYYYY'), 
					 :verified_stat:verified_stat_ind, :load_chip_flag:load_chip_flag_ind,
					 :record_srno:record_srno_ind);					 

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" insert_new_lic_info : Insert into APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_new_lic_info: Insert into APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "insert_new_lic_info: Insert into APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return INSERT_ERROR;
			}
#ifdef DEBUG
			userlog("insert_new_lic_info : Record inserted successfully");
#endif
		}
		else if (FALSE == insert_flag)
		{
			if (days_diff > 0)
			{
				EXEC SQL UPDATE APPNT_LIC_INFO
					SET  LICVALIDSTARTDATE = TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY'),
					LICVALIDENDDATE   = ADD_MONTHS(TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY'),
													:validity_period:validity_period_ind) - 1
					WHERE APPLID = :appl_id
					AND LICTYPE = :license_type;

			}
			else
			{
				EXEC SQL UPDATE APPNT_LIC_INFO
					SET  LICVALIDSTARTDATE = TO_DATE(:validstart_date:validstart_date_ind, 'DDMMYYYY'),
					 LICVALIDENDDATE   = ADD_MONTHS(LICVALIDENDDATE,:validity_period:validity_period_ind)
					WHERE APPLID = :appl_id
					AND LICTYPE = :license_type;
			}

			if(SQLCODE != 0)
			{
#ifdef DEBUG
				userlog(" insert_new_lic_info : Updation on APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
				strcpy(prog_log.remarks,"insert_new_lic_info: Updation on APPNT_LIC_INFO failed");
				sprintf(excep_log.error_msg, "insert_new_lic_info: Updation on APPNT_LIC_INFO failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return UPDATE_ERROR;
			}
#ifdef DEBUG
		userlog("insert_new_lic_info : Record updated successfully");
#endif
		}
		else
		{
#ifdef DEBUG
			userlog("insert_new_lic_info : Txn other than Add new and Renewal");
#endif
		}


	return SUCCESS;

}

int calculate_lic_validity_date(int validity_period, char *txndate, 
								char *validity_end_date,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	  char txn_date[DATE_SIZE] = {0};
	  char validend_date[DATE_SIZE] = {0};
	  int validityperiod = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	/* Populate the variables	*/

	validityperiod = validity_period;
	strcpy(txn_date,txndate);

#ifdef DEBUG
	userlog("calculate_lic_validity_date : Validity period - %d", validityperiod);
	userlog("calculate_lic_validity_date : Txn date - %s", txn_date);
#endif

	if(0 >= validityperiod || '\0' == txn_date[0]) 
	{
#ifdef DEBUG
		userlog(" calculate_lic_validity_date : Invalid validity period");
#endif
		strcpy(prog_log.remarks,"calculate_lic_validity_date: Invalid validity period");
		strcpy(excep_log.error_msg, "calculate_lic_validity_date: Invalid validity period");
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return INVALID_VALIDITY_PERIOD;
		
	}


	EXEC SQL SELECT TO_CHAR(ADD_MONTHS(TO_DATE(:txn_date,'DDMMYYYY'),:validityperiod) - 1,'DDMMYYYY')
				INTO :validend_date FROM DUAL;

	if(SQLCODE != 0) 
	{
#ifdef DEBUG
		userlog(" calculate_lic_validity_date : Error in calculating Validity period for the license");
#endif
		strcpy(prog_log.remarks,"calculate_lic_validity_date: Error in calculating Validity period for the license");
		sprintf(excep_log.error_msg, "calculate_lic_validity_date: Error in calculating Validity period for the license : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
		
	}

	strcpy(validity_end_date,validend_date);

#ifdef DEBUG
	userlog("calculate_lic_validity_date : Validity End Date - %s",validity_end_date);
#endif
	return SUCCESS;
}

int delete_old_class(char *application_id, TXN_DETAILS_T *txn_details, int *record_srno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char appl_id[APP_ID_SIZE] = {0};
		char license_type[LIC_TYPE_SIZE] = {0};
		char license_class[LIC_CLS_SIZE] = {0};
		char old_class[LIC_CLS_SIZE] = {0};
		int record_serial_no = 0;
						
		short license_type_ind = -1;
		short license_class_ind = -1;
		short old_class_ind = -1;
		short record_serial_no_ind = -1;
				
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(appl_id, application_id);

	if (0 != txn_details->lic_type[0] )
	{
		strcpy(license_type, txn_details->lic_type);
		license_type_ind = 0;
	}

	if (0 != txn_details->lic_class[0] )
	{
		strcpy(license_class, txn_details->lic_class);
		license_class_ind = 0;
	}

	
	EXEC SQL SELECT RECORDSERNO INTO :record_serial_no:record_serial_no_ind
				FROM APPNT_LIC_INFO
		WHERE APPLID = :appl_id
		AND LICTYPE = :license_type:license_type_ind
		AND LICCLASS IN (SELECT LICCLASS FROM PSV_GDL_CLASS_REL A
							WHERE A.LICTYPE = :license_type:license_type_ind
							CONNECT BY A.LICCLASS = PRIOR A.NEWLICCLASS
							START WITH A.LICTYPE = :license_type:license_type_ind
							AND A.NEWLICCLASS = :license_class:license_class_ind)
		AND SUBSTR(LICCLASS,1,1) <> 'D';
		
		
	//if(SQLCODE != 0 && !NO_DATA_FOUND)
	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
#ifdef DEBUG
		userlog(" delete_old_class : Selecting Record serial no from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"delete_old_class: Selecting Record serial no from APPNT_LIC_INFO failed");
		sprintf(excep_log.error_msg, "delete_old_class: Selecting Record serial no from APPNT_LIC_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

#ifdef DEBUG
	userlog(" delete_old_class : Record sr no- %d", record_serial_no);
#endif

	if (record_serial_no_ind == 0)
	{
		
		*record_srno = record_serial_no;

		/* Delete the record with old class from APPNT_LIC_INFO, if any */

		EXEC SQL DELETE FROM APPNT_LIC_INFO
			WHERE APPLID = :appl_id
			AND LICTYPE = :license_type:license_type_ind
			AND LICCLASS IN (SELECT LICCLASS FROM PSV_GDL_CLASS_REL A
							WHERE A.LICTYPE = :license_type:license_type_ind
							CONNECT BY A.LICCLASS = PRIOR A.NEWLICCLASS
							START WITH A.LICTYPE = :license_type:license_type_ind
							AND A.NEWLICCLASS = :license_class:license_class_ind)
		AND SUBSTR(LICCLASS,1,1) <> 'D';

		

		//if(SQLCODE != 0 && !NO_DATA_FOUND)	/* Ignore no data found */
		if((SQLCODE) != 0 && (SQLCODE != 1403))
		{
#ifdef DEBUG
			userlog(" delete_old_class : Deletion from APPNT_LIC_INFO failed : %s", SQLMSG);
#endif
			strcpy(prog_log.remarks,"delete_old_class: Deletion from APPNT_LIC_INFO failed ");
			sprintf(excep_log.error_msg, "delete_old_class: Deletion from APPNT_LIC_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return DELETE_ERROR;
		}

#ifdef DEBUG
		userlog(" delete_old_class : Deleted from APPNT_LIC_INFO successfully");
#endif
	}
	else
	{
#ifdef DEBUG
		userlog(" delete_old_class : Record with given class doesn't exist in PSV_GDL_CLASS_REL");
#endif

	}
	
	return SUCCESS;
}

int update_appl_remarks(char *applid, char status, char *appl_remarks, char *cancel_code, char *cancel_date,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char hv_applid[APP_ID_SIZE] = {0};
	varchar hv_remarks[NOTE_SIZE] = {0};
	short int hv_remarks_ind = 0;
//	int hv_problno = 0;
	char hv_cancel_code[CANCEL_CODE_SIZE] = {0};
	short int hv_cancel_code_ind = 0;
	char hv_cancel_date[DATE_SIZE] = {0};
	short int hv_cancel_date_ind = 0;
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	int i = 0;
	strcpy(hv_applid, applid);
	strcpy((char *)hv_remarks.arr, appl_remarks);
	setlen(hv_remarks);
	if(hv_remarks.arr[0] == '\0')
		hv_remarks_ind = -1;
	strcpy(hv_cancel_code, cancel_code);
	if(hv_cancel_code[0] == '\0')
		hv_cancel_code_ind = -1;
	strcpy(hv_cancel_date, cancel_date);
	if(hv_cancel_date[0] == '\0')
		hv_cancel_date_ind = -1;

/*	EXEC SQL
		SELECT PROBLNO INTO :hv_problno
		FROM PROBL_RECORD
		WHERE APPLID = :hv_applid
		AND PROBLSTAT = 'O'
		AND ROWNUM < 2;

	if((SQLCODE != 0) && !(NO_DATA_FOUND))
	{
#ifdef DEBUG
		userlog("update_appl_remarks : select from PROBL_RECORD failed : %d %s", SQLCODE, SQLMSG);
#endif
		strcpy(prog_log.remarks,"update_appl_remarks : select from PROBL_RECORD failed");
		sprintf(excep_log.error_msg, "update_appl_remarks : select from PROBL_RECORD failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

	if((prob_result == NULL) || (probl_no <= 0))
		return GMPC_GOOD;

	for(i = 0; i < probl_no; i++)
	{
		if(prob_result->problem_number == hv_problno)
			break;
		prob_result++;
	}

	strncpy((char *)hv_actremarks.arr, prob_result->note, 500);
	setlen(hv_actremarks);
	if(hv_actremarks.arr[0] == '\0')
	{
		hv_actremarks_ind = -1;
		return GMPC_GOOD;
	}
*/

	EXEC SQL 
		UPDATE APPLICATION A
		SET APPLREMARKS = :hv_remarks:hv_remarks_ind,
		APPLCANCELCODE = :hv_cancel_code:hv_cancel_code_ind, 
		APPLCANCELDATE = TO_DATE(:hv_cancel_date:hv_cancel_date_ind, 'DDMMYYYY')
		WHERE APPLID = :hv_applid;

	if((SQLCODE != 0) && !(NO_DATA_FOUND))
	{
#ifdef DEBUG
		userlog("update_appl_remarks : updation of APPLICATION failed : %d %s", SQLCODE, SQLMSG);
#endif
		strcpy(prog_log.remarks,"update_appl_remarks : updation of APPLICATION failed");
		sprintf(excep_log.error_msg, "update_appl_remarks : updation of APPLICATION failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return UPDATE_ERROR;
	}

	return GMPC_GOOD;
}

/********************************************************************************/
/* Function name: set_card_expiry_date											*/
/* Description	: This function sets the Card expiry date based upon the        */
/*				  Application approval date										*/
/* Input		: KPT number, Application id									*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int set_card_expiry_date(char *kpt_number, char *application_id, int txn_type, char *immexpdate,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
		char appl_id[APP_ID_SIZE] = {0};
		char kpt_no[KPT_SIZE] = {0};
		char approval_date[DATE_SIZE] = {0};
		char green_card_exp_date[DATE_SIZE] = {0};
		int day_diff = 0;
		int green_card_exp_period = 0;
		varchar green_card_exp_param[SYS_PARAM_NAME_SIZE] = {0};

		char chekdate[DATE_SIZE] = {0};
		char gcexpdate[DATE_SIZE] = {0};

		short kpt_no_ind = -1;
		short approval_date_ind = -1;
		short green_card_exp_date_ind = -1;
		short green_card_exp_period_ind = -1;

		short chekdate_ind = -1;
		short gcexpdate_ind = -1;
				
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(appl_id, application_id);

	if (0 != kpt_number[0] )
	{
		strcpy(kpt_no, kpt_number);	
		kpt_no_ind  = 0;
	}

/*Added by brijesh on 24-09-2002 as per new requirment given by Vasanth*/

	EXEC SQL SELECT TO_CHAR(SYSDATE, 'YYYYMMDD')
	INTO  :approval_date:approval_date_ind
	FROM DUAL;

	if (SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("set_card_expiry_date : Select SYSDATE from DUAL failed for KPT %s: %s", kpt_no, SQLMSG);
#endif
		strcpy(prog_log.remarks,"set_card_expiry_date: Select SYSDATE from DUAL failed ");
		sprintf(excep_log.error_msg, "set_card_expiry_date: Select SYSDATE from DUAL failed for KPT %s : %s", kpt_no, SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return SELECT_ERROR;
	}

	#ifdef DEBUG
		userlog("set_card_expiry_date : Approval date - %s", approval_date);
	#endif


	if(immexpdate[0] != '\0')
	{

		EXEC SQL SELECT
			TO_CHAR(ADD_MONTHS(SYSDATE, 24) - 1, 'YYYYMMDD')
				INTO :green_card_exp_date:green_card_exp_date_ind
			FROM DUAL;

		if(SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog(" set_card_expiry_date : Selecting Card expiry date failed : %s", SQLMSG);
	#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Selecting Card expiry date failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Selecting Card expiry date failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

	#ifdef DEBUG
		userlog("set_card_expiry_date : Card expiry date - %s", green_card_exp_date);
	#endif

		EXEC SQL SELECT TO_DATE(:immexpdate, 'YYYYMMDD') - TO_DATE(:green_card_exp_date, 'YYYYMMDD')
				INTO :day_diff
			FROM DUAL;

		if(SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog(" set_card_expiry_date : Calculating difference betweem IMM expiry date and Card expiry date failed");
	#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Calculating difference betweem IMM expiry date and Card expiry date failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Calculating difference betweem IMM expiry date and Card expiry date failed");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

		if (day_diff <= 0)
		{
			strcpy(green_card_exp_date, immexpdate);
		}
	}
	else
	{


		strcpy((char *)green_card_exp_param.arr, "GREEN_CARD_EXP_PERIOD");
		setlen(green_card_exp_param);

		/* Get the green card expiry period value from SYS_CONFIG_PARMS */

		EXEC SQL SELECT TO_NUMBER(PARMVAL) INTO :green_card_exp_period:green_card_exp_period_ind
				FROM SYS_CONFIG_PARMS
			WHERE PARMNAME = :green_card_exp_param;

		if (SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog("set_card_expiry_date : Select from SYS_CONFIG_PARMS failed for KPT %s: %s", kpt_no, SQLMSG);
	#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Select from SYS_CONFIG_PARMS failed ");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Select from SYS_CONFIG_PARMS failed for KPT %s : %s", kpt_no, SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}
			
	#ifdef DEBUG
		userlog("set_card_expiry_date : Green card expity period - %d", green_card_exp_period);
	#endif

		if (green_card_exp_period_ind != 0)
			green_card_exp_period = 60;	/* Set default as 60 months */

	/*	if(txn_type == TXN_CONV)
		{
			EXEC SQL SELECT TO_CHAR(NVL(APPLAPPROVALDATE,SYSDATE), 'DDMMYYYY')
				INTO  :approval_date:approval_date_ind
				FROM JPN_INFO 
				WHERE KPTNO = :kpt_no:kpt_no_ind;

			if (SQLCODE != 0)
			{
		#ifdef DEBUG
				userlog("set_card_expiry_date : Select from JPN_INFO failed for KPT %s: %s", kpt_no, SQLMSG);
		#endif
				strcpy(prog_log.remarks,"set_card_expiry_date: Select from JPN_INFO failed ");
				sprintf(excep_log.error_msg, "set_card_expiry_date: Select from JPN_INFO failed for KPT %s : %s", kpt_no, SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}
		}
		else if(txn_type == TXN_REPL)
		{
			EXEC SQL SELECT TO_CHAR(NVL(APPLAPPROVALDATE,SYSDATE), 'DDMMYYYY')
				INTO  :approval_date:approval_date_ind
				FROM JPN_INFO 
				WHERE KPTNO = :kpt_no:kpt_no_ind;

			if (SQLCODE != 0)
			{
		#ifdef DEBUG
				userlog("set_card_expiry_date : Select from JPN_INFO failed for KPT %s: %s", kpt_no, SQLMSG);
		#endif
				strcpy(prog_log.remarks,"set_card_expiry_date: Select from JPN_INFO failed ");
				sprintf(excep_log.error_msg, "set_card_expiry_date: Select from JPN_INFO failed for KPT %s : %s", kpt_no, SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}
		}
	*/
			
		/* Add 2 years in Approval date to get the Card expiry date */
		/* Subtract one day from the date after 2 years */

		EXEC SQL SELECT
			TO_CHAR(ADD_MONTHS(TO_DATE(:approval_date:approval_date_ind, 'YYYYMMDD'), :green_card_exp_period) - 1, 'YYYYMMDD')
				INTO :green_card_exp_date:green_card_exp_date_ind
			FROM DUAL;

		if(SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog(" set_card_expiry_date : Selecting Card expiry date failed : %s", SQLMSG);
	#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Selecting Card expiry date failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Selecting Card expiry date failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

	#ifdef DEBUG
		userlog("set_card_expiry_date : Card expiry date - %s", green_card_exp_date);
	#endif

/* Change made by Sushil on 29012003 to convert SYSDATE before substaction 
		EXEC SQL SELECT TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD') - SYSDATE
				INTO :day_diff
			FROM DUAL;
*/

		EXEC SQL SELECT TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD') - TO_DATE(TO_CHAR(SYSDATE,'YYYYMMDD'),'YYYYMMDD')
			INTO :day_diff
		FROM DUAL;

		
		if(SQLCODE != 0)
		{
	#ifdef DEBUG
			userlog(" set_card_expiry_date : Calculating difference betweem IMM expiry date and Card expiry date failed");
	#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Calculating difference betweem IMM expiry date and Card expiry date failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Calculating difference betweem IMM expiry date and Card expiry date failed");
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

		/* If Expiry date is less or equal to than sysdate */

		if (day_diff <= 0)
		{
	#ifdef DEBUG
			userlog("set_card_expiry_date : Card is already expired");
	#endif

			EXEC SQL SELECT TO_CHAR(SYSDATE, 'YYYYMMDD')
					INTO :approval_date:approval_date_ind
				FROM DUAL;

			if(SQLCODE != 0)
			{
	#ifdef DEBUG
				userlog(" set_card_expiry_date : Selecting Approval date from DUAL failed : %s", SQLMSG);
	#endif
				strcpy(prog_log.remarks,"set_card_expiry_date: Selecting Approval date from DUAL failed");
				sprintf(excep_log.error_msg, "set_card_expiry_date: Selecting Approval date from DUAL failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

			/* Add 2 years in Approval date to get the Card expiry date */

			EXEC SQL SELECT
				TO_CHAR(ADD_MONTHS(TO_DATE(:approval_date:approval_date_ind, 'YYYYMMDD'), :green_card_exp_period) - 1, 'YYYYMMDD')
					INTO :green_card_exp_date:green_card_exp_date_ind
				FROM DUAL;

			if(SQLCODE != 0)
			{
	#ifdef DEBUG
				userlog(" set_card_expiry_date : Selecting Card expiry date failed : %s", SQLMSG);
	#endif
				strcpy(prog_log.remarks,"set_card_expiry_date: Selecting Card expiry date failed");
				sprintf(excep_log.error_msg, "set_card_expiry_date: Selecting Card expiry date failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				log_error(ctx);
				
				return SELECT_ERROR;
			}

		}
	}

#ifdef DEBUG
	userlog("set_card_expiry_date : Renewed approval date - %s", approval_date);
	userlog("set_card_expiry_date : Renewed card expiry date - %s", green_card_exp_date);
#endif

	
	/* Update the Approval date and Green card expiry date */
/* Changed by Sushil 06/01/2004 to assign the value to citizen nation code to 9999 if the field is blank  
	EXEC SQL UPDATE APPNT_JPN_INFO
		SET APPLAPPROVALDATE = TO_DATE(:approval_date:approval_date_ind, 'YYYYMMDD'),
			GREENCARDEXPDATE = TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD')
		WHERE APPLID = :appl_id;
*/


		// Added this code on 27/03/2015 for CR 291 
	// for greencardexpirydate checking if it is less than 6 months

	EXEC SQL SELECT TO_CHAR(NVL(GREENCARDEXPDATE,SYSDATE), 'YYYYMMDD')
			INTO  :gcexpdate:gcexpdate_ind
			FROM JPN_INFO 
			WHERE KPTNO = :kpt_no:kpt_no_ind;

		if (SQLCODE != 0)
		{
			#ifdef DEBUG
					userlog("set_card_expiry_date : Select from JPN_INFO failed for KPT %s: %s", kpt_no, SQLMSG);
			#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Select from JPN_INFO failed ");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Select from JPN_INFO failed for KPT %s : %s", kpt_no, SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return SELECT_ERROR;
		}

		#ifdef DEBUG
			userlog("set_card_expiry_date : gcexpdate :%s:", gcexpdate);
		#endif

		EXEC SQL SELECT
			TO_CHAR(ADD_MONTHS(SYSDATE, 6) - 1, 'YYYYMMDD')
				INTO :chekdate:chekdate_ind
			FROM DUAL;

		#ifdef DEBUG
			userlog("set_card_expiry_date : chekdate :%s:", chekdate);
		#endif

		day_diff = 0;
		EXEC SQL SELECT (TO_DATE(:gcexpdate, 'YYYYMMDD') - TO_DATE(:chekdate, 'YYYYMMDD'))
				INTO :day_diff
			FROM DUAL;

		#ifdef DEBUG
			userlog("set_card_expiry_date : day_diff :%d:", day_diff);
		#endif

		// approved mykas application updating jkind to 4
		EXEC SQL UPDATE APPNT_JPN_INFO
		SET JKIND = 4
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
		#ifdef DEBUG
				userlog(" set_card_expiry_date : Updating jkind in APPNT_JPN_INFO failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Updating jkind in APPNT_JPN_INFO failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Updating jkind in APPNT_JPN_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}


	if(day_diff < 1)
	{
	/* Update the Approval date and Green card expiry date */

	EXEC SQL UPDATE APPNT_JPN_INFO
		SET APPLAPPROVALDATE = TO_DATE(:approval_date:approval_date_ind, 'YYYYMMDD'),
			GREENCARDEXPDATE = TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD'),
			CITIZENNATIONCODE = DECODE(CITIZENNATIONCODE,NULL,'9999',CITIZENNATIONCODE)
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
		#ifdef DEBUG
				userlog(" set_card_expiry_date : Updating Approval date in APPNT_JPN_INFO failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Updating Approval date in APPNT_JPN_INFO failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Updating Approval date in APPNT_JPN_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}

		#ifdef DEBUG
			userlog(" set_card_expiry_date : Approval date updated successfully");
		#endif
	}
	else
	{
		strcpy(green_card_exp_date,gcexpdate);

		#ifdef DEBUG
			userlog(" set_card_expiry_date : green_card_exp_date more than 6 months: %s",green_card_exp_date);
		#endif

		EXEC SQL UPDATE APPNT_JPN_INFO
		SET APPLAPPROVALDATE = TO_DATE(:approval_date:approval_date_ind, 'YYYYMMDD'),
			GREENCARDEXPDATE = TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD'),
			CITIZENNATIONCODE = DECODE(CITIZENNATIONCODE,NULL,'9999',CITIZENNATIONCODE)
		WHERE APPLID = :appl_id;

		if(SQLCODE != 0)
		{
		#ifdef DEBUG
				userlog(" set_card_expiry_date : Updating Approval date in APPNT_JPN_INFO failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"set_card_expiry_date: Updating Approval date in APPNT_JPN_INFO failed");
			sprintf(excep_log.error_msg, "set_card_expiry_date: Updating Approval date in APPNT_JPN_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			log_error(ctx);
			
			return UPDATE_ERROR;
		}

		#ifdef DEBUG
			userlog(" set_card_expiry_date : green_card_exp_date more than 6 months sqlcode: %d",sqlca.sqlcode);
		#endif
	}

	/* Update Card expiry date */

	EXEC SQL UPDATE CARD_STATUS
		SET CARDEXPDATE = TO_DATE(:green_card_exp_date:green_card_exp_date_ind, 'YYYYMMDD')
		WHERE KPTNO = :kpt_no:kpt_no_ind
		AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS
								WHERE KPTNO = :kpt_no:kpt_no_ind);

	if(SQLCODE != 0)
	{
#ifdef DEBUG
		userlog(" set_card_expiry_date : Updating Card expiry date in CARD_STATUS failed : %s", SQLMSG);
#endif
		strcpy(prog_log.remarks,"set_card_expiry_date: Updating Card expiry date in CARD_STATUS failed");
		sprintf(excep_log.error_msg, "set_card_expiry_date: Updating Card expiry date in CARD_STATUS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return UPDATE_ERROR;
	}
#ifdef DEBUG
	userlog(" set_card_expiry_date : Card expiry date updated successfully");
#endif

	return SUCCESS;

}

/********************************************************************************/
/* Function name: put_appnt_images												*/
/* Description	: This function inserts the Applicant's imgae info				*/			  
/*                into APPNT_JPN_IMG table										*/
/* Input		: Pointer to image buffer, Pointer to request buffer of			*/
/*                the service													*/
/* Return values: SUCCESS / Error code											*/
/* Limitations	: None															*/
/********************************************************************************/

int put_appnt_images(SET_APPL_STAT_L3_REQ_T *req, char *appnt_img,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	
	typedef struct
	{
		long len;
		char arr[HIGH_RES_PHOTO_SIZE];

	} hrphoto;

	EXEC SQL TYPE hrphoto IS LONG varraw(HIGH_RES_PHOTO_SIZE);

	typedef struct
	{
		long len;
		char arr[ALLOWABLE_LR_PHOTO_SIZE];

	} lrphoto;

	EXEC SQL TYPE lrphoto IS LONG varraw(ALLOWABLE_LR_PHOTO_SIZE);

	EXEC SQL BEGIN DECLARE SECTION;

	char appl_id[APP_ID_SIZE] = {0};
	char writeind = 'N';
	int status = 0;
	varchar error_msg[ERROR_MSG_SIZE] = {0};

	lrphoto lres_photo;
	hrphoto hres_photo;
	long lres_photo_len = 0;
	long hres_photo_len = 0;

	short kpt_no_ind = -1;
	short lres_photo_ind = -1;
	short hres_photo_ind = -1;
	short error_msg_ind  = 0;
	
EXEC SQL END DECLARE SECTION;

	char *imgptr;

	strcpy(appl_id, req->header.application_id);
	

	
#ifdef DEBUG
	userlog("put_appnt_images : Appl id - %s", appl_id);
#endif
	
	if (req->lr_photo_size > ALLOWABLE_LR_PHOTO_SIZE ||
		req->hr_photo_size > HIGH_RES_PHOTO_SIZE)
	{
#ifdef DEBUG
		userlog(" put_appnt_images : Image size is greater than the maximum image size allowed");
#endif
		strcpy(prog_log.remarks,"put_appnt_images: Image size is greater than the maximum image size allowed");
		sprintf(excep_log.error_msg, "put_appnt_images: Image size is greater than the maximum image size allowed");
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return IMG_SIZE_ERROR;
	}
	
	imgptr = appnt_img;

	/* Applicant's LowResolution Photo */ 

	lres_photo.len = req->lr_photo_size;
	lres_photo_len = lres_photo.len;

	memcpy((char *)lres_photo.arr, imgptr, lres_photo.len);
	lres_photo_ind  = 0;

	imgptr = imgptr + lres_photo_len;

#ifdef DEBUG
	userlog("put_appnt_images : LR photo length - %ld",lres_photo_len);
#endif

	/* Applicant's High Resolution Photo */ 

	hres_photo.len = req->hr_photo_size;
	hres_photo_len = hres_photo.len;

	memcpy((char *)hres_photo.arr, imgptr, hres_photo.len);
	hres_photo_ind  = 0;

#ifdef DEBUG
	userlog("put_appnt_images : HR photo length - %ld",hres_photo_len);
	userlog("put_appnt_images : Calling stored procedure UPDATE_APPNT_IMAGES");
#endif

EXEC SQL EXECUTE
	BEGIN
	UPDATE_APPNT_IMAGES(:appl_id, :lres_photo:lres_photo_ind,
				:lres_photo_len, :hres_photo:hres_photo_ind, :hres_photo_len,
				:writeind, :status, :error_msg:error_msg_ind);
	END;
	END-EXEC;

	if(SQLCODE != 0)
	{
#ifdef DEBUG
		userlog("insert_into_appnt_image : Failed to call stored procedure UPDATE_APPNT_IMAGES : %s", SQLMSG);
		userlog("insert_into_appnt_image : SQLCODE for select- %d",status);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_image: Failed to call stored procedure UPDATE_APPNT_IMAGES ");
		sprintf(excep_log.error_msg, "insert_into_appnt_image: Failed to call stored procedure UPDATE_APPNT_IMAGES : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return STORED_PROC_ERROR;
	}

#ifdef DEBUG
	userlog("insert_into_appnt_image : Call to stored procedure UPDATE_APPNT_IMAGES succesfull");
	userlog("insert_into_appnt_image : Write indicator - %c",writeind);
	userlog("insert_into_appnt_image : SQLCODE for select- %d",status);
#endif

	if( status != 0)
	{
		setnull(error_msg);
#ifdef DEBUG
		userlog(" insert_into_appnt_image : Failed to update images into APPNT_JPN_IMG : %s", error_msg.arr);
#endif
		strcpy(prog_log.remarks,"insert_into_appnt_image: Failed to update images into APPNT_JPN_IMG");
		sprintf(excep_log.error_msg, "insert_into_appnt_image: Failed to update images into APPNT_JPN_IMG : %s", error_msg.arr);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		log_error(ctx);
		
		return STORED_PROC_ERROR;
	}

#ifdef DEBUG
	userlog("insert_into_appnt_image : Updated APPNT_JPN_IMG successfully");
#endif

	return SUCCESS;

}


/****************************************************************************/
/* Function name: update_appl_table_chg_kpt										*/
/* Description	: This function											*/
/* Input		: Application Id											*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int update_appl_table_chg_kpt(char *application_id, char *kptno, char *oldkptno,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char kpt_no[KPT_SIZE] = {0};
		char old_kptno[KPT_SIZE] = {0};
		short int kpt_no_ind = 0;
		short int old_kptno_ind = 0;
		char applid[APP_ID_SIZE];
sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN
	strcpy(applid,application_id); 
	strcpy(kpt_no,kptno); 
	strcpy(old_kptno, oldkptno);

#ifdef DEBUG
	userlog("update_appl_table_chg_kpt :applid:%s:", applid);
	userlog("update_appl_table_chg_kpt :kpt_no:%s:", kpt_no);
	userlog("update_appl_table_chg_kpt :old_kptno:%s:", old_kptno);
#endif

	EXEC SQL
		UPDATE APPL_DOC_SERNO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPL_DOC_SERNO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPL_DOC_SERNO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPL_HISTORY SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPL_HISTORY failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPL_HISTORY failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPL_MISSED_OPEX SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPL_MISSED_OPEX failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPL_MISSED_OPEX failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPNT_IMM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_IMM_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_IMM_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPNT_JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_JPJ_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_JPJ_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPNT_JPN_IMG SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_JPN_IMG failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_JPN_IMG failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPNT_JPN_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_JPN_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_JPN_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

/*	EXEC SQL
		UPDATE APPNT_JPN_OFFLINE SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table : update APPNT_JPN_OFFLINE failed");
		sprintf(excep_log.error_msg,"update_appl_table : update APPNT_JPN_OFFLINE failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}
*/
	EXEC SQL
		UPDATE APPNT_PDRM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_PDRM_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_PDRM_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE APPNT_PDRM_SUMMONS SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update APPNT_PDRM_SUMMONS failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update APPNT_PDRM_SUMMONS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE CARD_STATUS SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND) && !(RECORD_EXISTS))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update CARD_STATUS failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update CARD_STATUS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	} else if(RECORD_EXISTS)
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update CARD_STATUS failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update CARD_STATUS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return KPT_EXISTS;
		
	}

	EXEC SQL
		UPDATE CARD_HISTORY SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update CARD_HISTORY failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update CARD_HISTORY failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	/*  this code commented on 24/01/06 as per ijpn requirement
	EXEC SQL
		UPDATE DEBTOR_LIST SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update DEBTOR_LIST failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update DEBTOR_LIST failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE DISPUTED_JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE APPLID = :applid AND KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update DISPUTED_JPJ_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update DISPUTED_JPJ_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}*/

	EXEC SQL
		UPDATE IMM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update IMM_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update IMM_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_BLACKLIST SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_BLACKLIST failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_BLACKLIST failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_CANCEL SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_CANCEL failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_CANCEL failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_ENDORSE SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_ENDORSE failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_ENDORSE failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_REVOKE SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_REVOKE failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_REVOKE failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_SUSPENS SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_SUSPENS failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_SUSPENS failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPJ_LIC_TEST_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPJ_LIC_TEST_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPJ_LIC_TEST_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}

	EXEC SQL
		UPDATE JPN_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND) && !(RECORD_EXISTS))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update JPN_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update JPN_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}
/*
	EXEC SQL
		UPDATE PDRM_INFO SET KPTNO = :kpt_no:kpt_no_ind 
		WHERE KPTNO = :old_kptno;

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND) && !(RECORD_EXISTS))
	{

		strcpy(prog_log.remarks,"update_appl_table : update PDRM_INFO failed");
		sprintf(excep_log.error_msg,"update_appl_table : update PDRM_INFO failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}
*/
	EXEC SQL
		UPDATE APPLICATION SET KPTNO = :kpt_no:kpt_no_ind, OLDKPTNO = :old_kptno:old_kptno_ind
		WHERE APPLID = :applid;
		
//		AND KPTNO = :old_kptno; commented on 10/05/2007

	sqlmsg[0] = '\0';
	strcpy(sqlmsg, SQLMSG);

	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"update_appl_table_chg_kpt : update application failed");
		sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : update application failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return UPDATE_ERROR;
	}
	/* Added by Sushil 06/01/2004 - Insert a record in the table KPT_CHG_OLDNEW to keep track of the old and new kpt */
    /* COMMENTED ON 10/05/2007
		EXEC SQL
			DELETE FROM KPT_CHG_OLDNEW 
			WHERE OLDKPTNO = :old_kptno;
			
			sqlmsg[0] = '\0';
			strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE && !(NO_DATA_FOUND)){
			strcpy(prog_log.remarks,"update_appl_table_chg_kpt : delete from KPT_CHG_OLDNEW failed");
			sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : delete from KPT_CHG_OLDNEW failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return DELETE_ERROR;
		}
		#ifdef DEBUG
		userlog("update_appl_table :Before Insert into KPT_CHG_OLDNEW");
		userlog("update_appl_table :Old Kpt Number: %s", old_kptno);
		userlog("update_appl_table :New Kpt Number: %s", kpt_no);
		#endif


		EXEC SQL
			INSERT INTO KPT_CHG_OLDNEW (OLDKPTNO,NEWKPTNO,TIMESTAMP)
			VALUES(:old_kptno,:kpt_no,SYSDATE);
		
			sqlmsg[0] = '\0';
			strcpy(sqlmsg, SQLMSG);
		
		if(SQLCODE){
			strcpy(prog_log.remarks,"update_appl_table_chg_kpt : insert into KPT_CHG_OLDNEW failed");
			sprintf(excep_log.error_msg,"update_appl_table_chg_kpt : insert into KPT_CHG_OLDNEW failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INSERT_ERROR;
		}
		COMMENT END HERE 10/05/2007*/

	return GMPC_GOOD;
}

int check_kpt_change(char *application_id,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;		
		char applid[APP_ID_SIZE];
		int  nCount = 0;
		short int  nCountInd = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(applid,application_id); 
	EXEC SQL 
		SELECT count(*) INTO :nCount:nCountInd FROM APPL_TXN WHERE
		APPLID = :applid and TXNCODE in ('321','421')
		AND TXNCANCELCODE IS NULL;
	
	if(SQLCODE && !(NO_DATA_FOUND))
	{

		strcpy(prog_log.remarks,"check_kpt_change : select APPL_TXN failed");
		sprintf(excep_log.error_msg,"check_kpt_change : select APPL_TXN failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return SELECT_ERROR;
	}

    // Added this condition on 26/03/2007
    if (nCount == 0 )
	{
	 EXEC SQL SELECT COUNT(*) INTO :nCount:nCountInd 
		 FROM APPL_TXN A, PROBL_RECORD B 
		 WHERE A.APPLID = :applid 
		 AND A.APPLID = B.APPLID 
		 AND A.TXNCODE IN ('324','424') 
		 AND B.GENKPT='G'
		 AND A.TXNCANCELCODE IS NULL;

	 if(SQLCODE && !(NO_DATA_FOUND))
	 {

		strcpy(prog_log.remarks,"check_kpt_change : select APPL_TXN,PROBL_RECORD failed");
		sprintf(excep_log.error_msg,"check_kpt_change : select APPL_TXN,PROBL_RECORD failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);

   	    return SELECT_ERROR;
	 }
	}
    // end

	if(nCount > 0)
		return 1;
	return 0;
}

 /* Added on 24th MAR 2005 for IJPN */

/****************************************************************************/
/* Function name: insert_into_jpn_info										*/
/* Description	: This function inserts the input buffer data into JPN_INFO */
/* Input		: JPN_INFo_T and Application Id								*/
/* Return values: GMPC_GOOD,												*/
/* Limitations	:															*/
/****************************************************************************/
int insert_into_jpn_info(JPN_INFO_T *jpn,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;

		varchar kptno[KPT_SIZE] = {0};
		int  birthdistrictcode = 0;
		varchar policeid[POLICE_ID_SIZE] = {0};
		varchar militaryid[MILITARY_ID_SIZE] = {0};
		varchar kppno[KPP_SIZE] = {0};
		char gender = '\0';
		char personstatcode='\0';
		varchar birthdate[DATE_SIZE] = {0};
		char unknownbirthind = '\0';
		char religioncode  = '\0';
		varchar racecode[RACE_CODE_SIZE] = {0};
		char residentstat = '\0';
		char citizenshipstatcode = '\0';
		varchar colourarticlecode[ARTICLE_COLOR_CODE_SIZE]= {0};
		char hkind = '\0';
		char iccolorcode = '\0';
		varchar origname[ORIG_NAME_SIZE]= {0};
		varchar currlongname[CUR_LONG_NAME_SIZE]= {0};
		varchar currshortname1[CUR_SHORT_NAME_SIZE]= {0};
		varchar currshortname2[CUR_SHORT_NAME_SIZE]= {0};
		varchar gmpcshortname1[GMPC_SNAME1_SIZE]= {0};
		varchar gmpcshortname2[GMPC_SNAME1_SIZE]= {0};
		varchar gmpcshortname3[GMPC_SNAME3_SIZE]= {0};
		varchar address1[ADDRESS1_SIZE]= {0};
		varchar address2[ADDRESS1_SIZE]= {0};
		varchar address3[ADDRESS1_SIZE]= {0};
		varchar postcode[POST_CODE_SIZE]= {0};
		int  citycode=0;
		varchar statecode[STATE_CODE_SIZE]= {0};
		varchar ktindcode[KT_CODE_SIZE]= {0};
		varchar jpnremarks1[JPN_REMARKS_SIZE]= {0};
		varchar jpnremarks2[JPN_REMARKS_SIZE]= {0};
		char afisflag = 0;
		int  cardlostcnt=0;
		char kptapplstat = 0;
		varchar kptappldate[DATE_SIZE]= {0};    
		varchar kptcollectiondate[DATE_SIZE]= {0};
		varchar kptcollectionplaccode[KPT_COLLECTION_PLACE_SIZE]= {0};
		varchar lastaddchangedate[DATE_SIZE]= {0};
		varchar lastcardissuedate[DATE_SIZE]= {0};
		char juvenileflag = 0;
		int  cardversionno=0;
		varchar birthplace[BIRTH_PLACE_SIZE]= {0};
		varchar rjind[RJ_SIZE]= {0};
		varchar birthcertno[BIRTH_CERT_NO_SIZE]= {0};  
		varchar ktstartdate[DATE_SIZE]= {0};
		varchar ktenddate[DATE_SIZE]= {0};
		char blklstind='\0';
		varchar blklstcode[BLKLIST_ACTIVITY_CODE_SIZE]= {0};
		varchar birthregndate[DATE_SIZE]= {0};
		char afisbypass = '\0';
		int kptversionno = 0;
		varchar polmilitaryjoindate[DATE_SIZE]= {0};
        varchar retirementdate[DATE_SIZE]= {0};
		varchar passportissuedate[DATE_SIZE]= {0};
		varchar passportissuecountry[COUNTRY_CODE_SIZE]={0};
		char orignameind=0;
		varchar surrenderdate[DATE_SIZE]= {0};
		varchar applapprovaldate[DATE_SIZE]= {0};
        varchar greencardexpdate[DATE_SIZE]= {0};
		varchar immrefno[IMM_REF_NO_SIZE]= {0};
		varchar immrefdate[DATE_SIZE]= {0};
		varchar immexpdate[DATE_SIZE]= {0};
		char ucflag = 0;
		varchar passportno[PASSPORT_NO_SIZE]= {0};
		varchar permitno[PERMITNO1_SIZE]={0};
		int  permittype= 0;
		int  prdoctype= 0;
		varchar permitissuedate[DATE_SIZE]= {0};
		varchar rjstartdate[DATE_SIZE]= {0};
		varchar rjenddate[DATE_SIZE]= {0};
		varchar citizennationcode[COUNTRY_CODE_SIZE]= {0};
		// Added these two fields for release 3.28 on 27/05/2014
		varchar ktareacode[6+1]= {0};
		varchar apjareacode[8+1]= {0};

		
		short kptno_ind = -1;
		short birthdistrictcode_ind = -1;
		short policeid_ind = -1;
		short militaryid_ind = -1;
		short kppno_ind = -1;
		short gender_ind = -1;
		short personstatcode_ind = -1;
		short birthdate_ind = -1;
		short unknownbirthind_ind = -1;
		short religioncode_ind = -1;
		short racecode_ind = -1;
		short residentstat_ind = -1;
		short citizenshipstatcode_ind = -1;
		short colourarticlecode_ind = -1;
		short hkind_ind = -1;
		short iccolorcode_ind = -1;
		short origname_ind = -1;
		short currlongname_ind = -1;
		short currshortname1_ind = -1;
		short currshortname2_ind = -1;
		short gmpcshortname1_ind = -1;
		short gmpcshortname2_ind = -1;
		short gmpcshortname3_ind = -1;
		short address1_ind = -1;
		short address2_ind = -1;
		short address3_ind = -1;
		short postcode_ind = -1;
		short citycode_ind = -1;
		short statecode_ind = -1;
		short ktindcode_ind = -1;
		short jpnremarks1_ind = -1;
		short jpnremarks2_ind = -1;
		short afisflag_ind = -1;
		short cardlostcnt_ind = -1;
		short kptapplstat_ind = -1;
		short kptappldate_ind = -1;    
		short kptcollectiondate_ind = -1;
		short kptcollectionplaccode_ind = -1;
		short lastaddchangedate_ind = -1;
		short lastcardissuedate_ind = -1;
		short juvenileflag_ind = -1;
		short cardversionno_ind = -1;
		short birthplace_ind = -1;
		short rjind_ind = -1;
		short birthcertno_ind = -1;
		short kptversionno_ind = -1;
		short polmilitaryjoindate_ind = -1;
		short retirementdate_ind = -1;
		short orignameind_ind = -1;
		short surrenderdate_ind = -1;
		short citizennationcode_ind = -1;
		short applapprovaldate_ind = -1;
		short greencardexpdate_ind = -1;
		short immrefno_ind = -1;
		short immrefdate_ind = -1;
		short immexpdate_ind = -1;
		short passportno_ind = -1;
		short passportissuedate_ind = -1;
		short passportissuecountry_ind = -1;
		short ucflag_ind = -1;
		short permitno_ind = -1;
		short permitissuedate_ind = -1;
		short permittype_ind = -1;
		short prdoctype_ind = -1;
		short rjstartdate_ind = -1;
		short rjenddate_ind = -1;
		short ktstartdate_ind = -1;
		short ktenddate_ind = -1;
		short blklstind_ind = -1;
		short blklstcode_ind = -1;
		short birthregndate_ind = -1;
		short afisbypass_ind = -1;
		short ktareacode_ind = -1;
		short apjareacode_ind = -1;

		int icount = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

		/* print the input buffer */
		#ifdef DEBUG
			userlog("insert_into_jpn_info : Input buffer data");
			userlog("insert_into_jpn_info :jpn->kptno %s",jpn->kptno);
			userlog("insert_into_jpn_info :jpn->birthdistrictcode %d",jpn->birthdistrictcode);
			userlog("insert_into_jpn_info :jpn->policeid %s",jpn->policeid);
			userlog("insert_into_jpn_info :jpn->militaryid %s",jpn->militaryid);
			userlog("insert_into_jpn_info :jpn->kppno %s",jpn->kppno);
			userlog("insert_into_jpn_info :jpn->gender %c",jpn->gender);
			userlog("insert_into_jpn_info :jpn->personstatcode %c",jpn->personstatcode);
			userlog("insert_into_jpn_info :jpn->birthdate %s",jpn->birthdate);
			userlog("insert_into_jpn_info :jpn->unknownbirthind %c",jpn->unknownbirthind);
			userlog("insert_into_jpn_info :jpn->religioncode %c",jpn->religioncode);
			userlog("insert_into_jpn_info :jpn->racecode %s",jpn->racecode);
			userlog("insert_into_jpn_info :jpn->residentstat %c",jpn->residentstat);
			userlog("insert_into_jpn_info :jpn->citizenshipstatcode %c",jpn->citizenshipstatcode);
			userlog("insert_into_jpn_info :jpn->colourarticlecode %s",jpn->colourarticlecode);
			userlog("insert_into_jpn_info :jpn->hkind %c",jpn->hkind);
			userlog("insert_into_jpn_info :jpn->iccolorcode %c",jpn->iccolorcode);
			userlog("insert_into_jpn_info :jpn->origname %s",jpn->origname);
			userlog("insert_into_jpn_info :jpn->currlongname %s",jpn->currlongname);
			userlog("insert_into_jpn_info :jpn->currshortname1 %s",jpn->currshortname1);
			userlog("insert_into_jpn_info :jpn->currshortname2 %s",jpn->currshortname2);
			userlog("insert_into_jpn_info :jpn->gmpcshortname1 %s",jpn->gmpcshortname1);
			userlog("insert_into_jpn_info :jpn->gmpcshortname2 %s",jpn->gmpcshortname2);
			userlog("insert_into_jpn_info :jpn->gmpcshortname3 %s",jpn->gmpcshortname3);
			userlog("insert_into_jpn_info :jpn->address1 %s",jpn->address1);
			userlog("insert_into_jpn_info :jpn->address2 %s",jpn->address2);
			userlog("insert_into_jpn_info :jpn->address3 %s",jpn->address3);
			userlog("insert_into_jpn_info :jpn->postcode %s",jpn->postcode);
			userlog("insert_into_jpn_info :jpn->citycode %d",jpn->citycode);
			userlog("insert_into_jpn_info :jpn->statecode %s",jpn->statecode);
			userlog("insert_into_jpn_info :jpn->ktindcode %s",jpn->ktindcode);
			userlog("insert_into_jpn_info :jpn->jpnremarks1 %s",jpn->jpnremarks1);
			userlog("insert_into_jpn_info :jpn->jpnremarks2 %s",jpn->jpnremarks2);
			userlog("insert_into_jpn_info :jpn->afisflag %c",jpn->afisflag);
			userlog("insert_into_jpn_info :jpn->cardlostcnt %d",jpn->cardlostcnt);
			userlog("insert_into_jpn_info :jpn->kptapplstat %c",jpn->kptapplstat);
			userlog("insert_into_jpn_info :jpn->kptappldate %s",jpn->kptappldate);
			userlog("insert_into_jpn_info :jpn->kptcollectiondate %s",jpn->kptcollectiondate);
			userlog("insert_into_jpn_info :jpn->kptcollectionplaccode %s",jpn->kptcollectionplaccode);
			userlog("insert_into_jpn_info :jpn->lastaddchangedate %s",jpn->lastaddchangedate);
			userlog("insert_into_jpn_info :jpn->lastcardissuedate %s",jpn->lastcardissuedate);
			userlog("insert_into_jpn_info :jpn->juvenileflag %c",jpn->juvenileflag);
			userlog("insert_into_jpn_info :jpn->cardversionno %d",jpn->cardversionno);
			userlog("insert_into_jpn_info :jpn->birthplace %s",jpn->birthplace);
			userlog("insert_into_jpn_info :jpn->rjind %s",jpn->rjind);
			userlog("insert_into_jpn_info :jpn->birthcertno %s",jpn->birthcertno);
			userlog("insert_into_jpn_info :jpn->kptversionno %d",jpn->kptversionno);
			userlog("insert_into_jpn_info :jpn->polmilitaryjoindate %s",jpn->polmilitaryjoindate);
			userlog("insert_into_jpn_info :jpn->retirementdate %s",jpn->retirementdate);
			userlog("insert_into_jpn_info :jpn->orignameind %c",jpn->orignameind);
			userlog("insert_into_jpn_info :jpn->surrenderdate %s",jpn->surrenderdate);
			userlog("insert_into_jpn_info :jpn->citizennationcode %s",jpn->citizennationcode);
			userlog("insert_into_jpn_info :jpn->applapprovaldate %s",jpn->applapprovaldate);
			userlog("insert_into_jpn_info :jpn->greencardexpdate %s",jpn->greencardexpdate);
			userlog("insert_into_jpn_info :jpn->immrefno %s",jpn->immrefno);
			userlog("insert_into_jpn_info :jpn->immrefdate %s",jpn->immrefdate);
			userlog("insert_into_jpn_info :jpn->immexpdate %s",jpn->immexpdate);
			userlog("insert_into_jpn_info :jpn->passportno %s",jpn->passportno);
			userlog("insert_into_jpn_info :jpn->passportissuedate %s",jpn->passportissuedate);
			userlog("insert_into_jpn_info :jpn->passportissuecountry %s",jpn->passportissuecountry);
			userlog("insert_into_jpn_info :jpn->ucflag %c",jpn->ucflag);
			userlog("insert_into_jpn_info :jpn->permitno %s",jpn->permitno);
			userlog("insert_into_jpn_info :jpn->permitissuedate %s",jpn->permitissuedate);
			userlog("insert_into_jpn_info :jpn->permittype %d",jpn->permittype);
			userlog("insert_into_jpn_info :jpn->prdoctype %d",jpn->prdoctype);
			userlog("insert_into_jpn_info :jpn->rjstartdate %s",jpn->rjstartdate);
			userlog("insert_into_jpn_info :jpn->rjenddate %s",jpn->rjenddate);
			userlog("insert_into_jpn_info :jpn->ktstartdate %s",jpn->ktstartdate);
			userlog("insert_into_jpn_info :jpn->ktenddate %s",jpn->ktenddate);
			userlog("insert_into_jpn_info :jpn->blklstind %c",jpn->blklstind);
			userlog("insert_into_jpn_info :jpn->blklstcode %s",jpn->blklstcode);
			userlog("insert_into_jpn_info :jpn->birthregndate %s",jpn->birthregndate);
			userlog(" Realease 3.28");
			userlog("insert_into_jpn_info :jpn->ktareacode %s",jpn->ktareacode);
			userlog("insert_into_jpn_info :jpn->apjareacode %s",jpn->apjareacode);
		#endif

				
		/* populate the host variables */
		strcpy((char*)kptno.arr,jpn->kptno);
		setlen(kptno);
		setnull(kptno);
		
		if(jpn->birthdistrictcode > 0)
		{
			birthdistrictcode = jpn->birthdistrictcode;
			birthdistrictcode_ind = 0;

		}
		if(jpn->policeid[0] != '\0')
		{
			strcpy((char*)policeid.arr,jpn->policeid);
			setlen(policeid);
			setnull(policeid);
			policeid_ind = 0;

		}
		if(jpn->militaryid[0] != '\0')
		{
			strcpy((char*)militaryid.arr,jpn->militaryid);
			setlen(militaryid);
			setnull(militaryid);
			militaryid_ind = 0;

		}
		if(jpn->kppno[0] != '\0')
		{
			strcpy((char*)kppno.arr,jpn->kppno);
			setlen(kppno);
			setnull(kppno);
			kppno_ind = 0;

		}

		if(jpn->gender != '\0')
		{
			gender=jpn->gender;
			gender_ind = 0;

		}
		if(jpn->personstatcode != '\0')
		{
			personstatcode=jpn->personstatcode;
			personstatcode_ind = 0;

		}
		if(jpn->birthdate[0] != '\0')
		{
			strcpy((char*)birthdate.arr,jpn->birthdate);
			setlen(birthdate);
			setnull(birthdate);
			birthdate_ind = 0;

		}

		if(jpn->unknownbirthind != '\0')
		{
			unknownbirthind = jpn->unknownbirthind;
			unknownbirthind_ind = 0;

		}
		if(jpn->religioncode != '\0')
		{
			religioncode=jpn->religioncode;
			religioncode_ind = 0;

		}
		
		if(jpn->racecode[0] != '\0')
		{
			strcpy((char*)racecode.arr,jpn->racecode);
			setlen(racecode);
			setnull(racecode);
			racecode_ind = 0;

		}
		if(jpn->residentstat != '\0')
		{
			residentstat=jpn->residentstat;
			residentstat_ind = 0;

		}
		
		if(jpn->citizenshipstatcode != '\0')
		{
			citizenshipstatcode=jpn->citizenshipstatcode;
			citizenshipstatcode_ind = 0;

		}
	
		if(jpn->colourarticlecode[0] != '\0')
		{
			strcpy((char*)colourarticlecode.arr,jpn->colourarticlecode);
			setlen(colourarticlecode);
			setnull(colourarticlecode);
			colourarticlecode_ind = 0;

		}

		if(jpn->hkind != '\0')
		{
			hkind=jpn->hkind;
			hkind_ind = 0;

		}
		if(jpn->iccolorcode != '\0')
		{
			iccolorcode=jpn->iccolorcode;
			iccolorcode_ind = 0;

		}
	
		if(jpn->origname[0] != '\0')
		{
			strcpy((char *)origname.arr, jpn->origname);
			setlen(origname);
			setnull(origname);
			origname_ind = 0;

		}
		
		if(jpn->currlongname[0] != '\0')
		{
			strcpy((char *)currlongname.arr, jpn->currlongname);
			setlen(currlongname);
			setnull(currlongname);
			currlongname_ind = 0;

		}
		
		if(jpn->currshortname1[0] != '\0')
		{
			strcpy((char *)currshortname1.arr, jpn->currshortname1);
			setlen(currshortname1);
			setnull(currshortname1);
			currshortname1_ind = 0;

		}
		if(jpn->currshortname2[0] != '\0')
		{
			strcpy((char *)currshortname2.arr, jpn->currshortname2);
			setlen(currshortname2);
			setnull(currshortname2);
			currshortname2_ind = 0;

		}
		if(jpn->gmpcshortname1[0] != '\0')
		{
			strcpy((char *)gmpcshortname1.arr, jpn->gmpcshortname1);
			setlen(gmpcshortname1);
			setnull(gmpcshortname1);
			gmpcshortname1_ind = 0;

		}
		if(jpn->gmpcshortname2[0] != '\0')
		{
			strcpy((char *)gmpcshortname2.arr, jpn->gmpcshortname2);
			setlen(gmpcshortname2);
			setnull(gmpcshortname2);
			gmpcshortname2_ind = 0;

		}

		if(jpn->gmpcshortname3[0] != '\0')
		{
			strcpy((char *)gmpcshortname3.arr, jpn->gmpcshortname3);
			setlen(gmpcshortname3);
			setnull(gmpcshortname3);
			gmpcshortname3_ind = 0;

		}
		if(jpn->address1[0] != '\0')
		{
			strcpy((char *)address1.arr, jpn->address1);
			setlen(address1);
			setnull(address1);
			address1_ind = 0;

		}

		if(jpn->address2[0] != '\0')
		{
			strcpy((char *)address2.arr, jpn->address2);
			setlen(address2);
			setnull(address2);
			address2_ind = 0;

		}

		if(jpn->address3[0] != '\0')
		{
			strcpy((char *)address3.arr, jpn->address3);
			setlen(address3);
			setnull(address3);
			address3_ind = 0;

		}
		if(jpn->postcode[0] != '\0')
		{
			strcpy((char*)postcode.arr, jpn->postcode);
			setlen(postcode);
			setnull(postcode);
			postcode_ind = 0;

		}
		if(citycode > 0)
		{
			citycode = jpn->citycode;
			citycode_ind = 0;

		}
		
		if(jpn->statecode[0] != '\0')
		{
			strcpy((char*)statecode.arr, jpn->statecode);
			setlen(statecode);
			setnull(statecode);
			statecode_ind = 0;

		}
		if(jpn->ktindcode[0] != '\0')
		{
			strcpy((char*)ktindcode.arr, jpn->ktindcode);
			setlen(ktindcode);
			setnull(ktindcode);
			ktindcode_ind = 0;

		}
		if(jpn->jpnremarks1[0] != '\0')
		{
			strcpy((char *)jpnremarks1.arr, jpn->jpnremarks1);
			setlen(jpnremarks1);
			setnull(jpnremarks1);
			jpnremarks1_ind = 0;

		}
		if(jpn->jpnremarks2[0] != '\0')
		{
			strcpy((char *)jpnremarks2.arr, jpn->jpnremarks2);
			setlen(jpnremarks2);
			setnull(jpnremarks2);
			jpnremarks2_ind = 0;

		}
		if(jpn->afisflag != '\0')
		{
			afisflag = jpn->afisflag;			
			afisflag_ind = 0;

		}
		if(jpn->cardlostcnt > 0)
		{
			cardlostcnt = jpn->cardlostcnt;			
			cardlostcnt_ind = 0;

		}
		
		if(jpn->kptapplstat != '\0')
		{
			kptapplstat = jpn->kptapplstat;			
			kptapplstat_ind = 0;

		}
		if(jpn->kptappldate[0] != '\0')
		{
			strcpy((char*)kptappldate.arr, jpn->kptappldate);
			setlen(kptappldate);
			setnull(kptappldate);
			kptappldate_ind = 0;

		}
		if(jpn->kptcollectiondate[0] != '\0')
		{
			strcpy((char*)kptcollectiondate.arr, jpn->kptcollectiondate);
			setlen(kptcollectiondate);
			setnull(kptcollectiondate);
			kptcollectiondate_ind = 0;

		}
		if(jpn->kptcollectionplaccode[0] != '\0')
		{
			strcpy((char *)kptcollectionplaccode.arr, jpn->kptcollectionplaccode);
			setlen(kptcollectionplaccode);
			setnull(kptcollectionplaccode);
			kptcollectionplaccode_ind = 0;

		}
		if(jpn->lastaddchangedate[0] != '\0')
		{
			strcpy((char*)lastaddchangedate.arr, jpn->lastaddchangedate);
			setlen(lastaddchangedate);
			setnull(lastaddchangedate);
			lastaddchangedate_ind = 0;

		}
		if(jpn->lastcardissuedate[0] != '\0')
		{
			strcpy((char*)lastcardissuedate.arr, jpn->lastcardissuedate);
			setlen(lastcardissuedate);
			setnull(lastcardissuedate);
			lastcardissuedate_ind = 0;

		}
		if(jpn->juvenileflag != '\0')
		{
			juvenileflag = jpn->juvenileflag;
			juvenileflag_ind = 0;

		}
		if(jpn->cardversionno > 0)
		{
			cardversionno = jpn->cardversionno;
			cardversionno_ind = 0;

		}
	
		if(jpn->birthplace[0] != '\0')
		{
			strcpy((char*)birthplace.arr, jpn->birthplace);
			setlen(birthplace);
			setnull(birthplace);
			birthplace_ind = 0;

		}
		if(jpn->rjind[0] != '\0')
		{
			strcpy((char*)rjind.arr, jpn->rjind);
			setlen(rjind);
			setnull(rjind);
			rjind_ind = 0;

		}
		if(jpn->birthcertno[0] != '\0')
		{
			strcpy((char*)birthcertno.arr, jpn->birthcertno);
			setlen(birthcertno);
			setnull(birthcertno);
			birthcertno_ind = 0;

		}
	
		if(jpn->kptversionno > 0)
		{
			kptversionno = jpn->kptversionno;
			kptversionno_ind = 0;

		}
		
		#ifdef DEBUG
		    userlog(" *********** ");
			userlog("insert_into_jpn_info :jpn->polmilitaryjoindate :%s:",jpn->polmilitaryjoindate);
		#endif

		if((jpn->polmilitaryjoindate[0] != '\0') && (jpn->polmilitaryjoindate[0] != ' '))
		{
			strcpy((char*)polmilitaryjoindate.arr, jpn->polmilitaryjoindate);
			setlen(polmilitaryjoindate);
			setnull(polmilitaryjoindate);
			polmilitaryjoindate_ind = 0;

		}

		#ifdef DEBUG
			userlog("insert_into_jpn_info :polmilitaryjoindate.arr :%s:",polmilitaryjoindate.arr);
			userlog("insert_into_jpn_info :jpn->retirementdate :%s:",jpn->retirementdate);
		#endif

		if((jpn->retirementdate[0] != '\0') && (jpn->retirementdate[0] != ' '))
		{
			strcpy((char*)retirementdate.arr, jpn->retirementdate);
			setlen(retirementdate);
			setnull(retirementdate);
			retirementdate_ind = 0;

		}

		#ifdef DEBUG
			userlog("insert_into_jpn_info :retirementdate.arr :%s:",retirementdate.arr);
			userlog(" ********* ");
		#endif

		if(jpn->orignameind != '\0')
		{
			orignameind = jpn->orignameind;
			orignameind_ind = 0;

		}
	
		if(jpn->surrenderdate[0] != '\0')
		{
			strcpy((char*)surrenderdate.arr, jpn->surrenderdate);
			setlen(surrenderdate);
			setnull(surrenderdate);
			surrenderdate_ind = 0;

		}
		if(jpn->citizennationcode[0] != '\0')
		{
			strcpy((char*)citizennationcode.arr, jpn->citizennationcode);
			setlen(citizennationcode);
			setnull(citizennationcode);
			citizennationcode_ind = 0;

		}

		if(jpn->applapprovaldate[0] != '\0')
		{
			strcpy((char*)applapprovaldate.arr, jpn->applapprovaldate);
			setlen(applapprovaldate);
			setnull(applapprovaldate);
			applapprovaldate_ind = 0;

		}
		if(jpn->greencardexpdate[0] != '\0')
		{
			strcpy((char*)greencardexpdate.arr, jpn->greencardexpdate);
			setlen(greencardexpdate);
			setnull(greencardexpdate);
			greencardexpdate_ind = 0;

		}
		if(jpn->immrefno[0] != '\0')
		{
			strcpy((char*)immrefno.arr, jpn->immrefno);
			setlen(immrefno);
			setnull(immrefno);
			immrefno_ind = 0;

		}
		if(jpn->immrefdate[0] != '\0')
		{
			strcpy((char*)immrefdate.arr, jpn->immrefdate);
			setlen(immrefdate);
			setnull(immrefdate);
			immrefdate_ind = 0;

		}

		if(jpn->immexpdate[0] != '\0')
		{
			strcpy((char*)immexpdate.arr, jpn->immexpdate);
			setlen(immexpdate);
			setnull(immexpdate);
			immexpdate_ind = 0;

		}
		if(jpn->passportno[0] != '\0')
		{
			strcpy((char*)passportno.arr, jpn->passportno);
			setlen(passportno);
			setnull(passportno);
			passportno_ind = 0;

		}
		if(jpn->passportissuedate[0] != '\0')
		{
			strcpy((char*)passportissuedate.arr, jpn->passportissuedate);
			setlen(passportissuedate);
			setnull(passportissuedate);
			passportissuedate_ind = 0;

		}
		if(jpn->passportissuecountry[0] != '\0')
		{
			strcpy((char*)passportissuecountry.arr, jpn->passportissuecountry);
			setlen(passportissuecountry);
			setnull(passportissuecountry);
			passportissuecountry_ind = 0;

		}
		if(jpn->ucflag != '\0')
		{
			ucflag = jpn->ucflag;
			ucflag_ind = 0;

		}
		
		if(jpn->permitno[0] != '\0')
		{
			strcpy((char*)permitno.arr, jpn->permitno);
			setlen(permitno);
			setnull(permitno);
			permitno_ind = 0;

		}
		if(jpn->permitissuedate[0] != '\0')
		{
			strcpy((char*)permitissuedate.arr, jpn->permitissuedate);
			setlen(permitissuedate);
			setnull(permitissuedate);
			permitissuedate_ind = 0;

		}
		
		if(jpn->permittype >  0)
		{
			permittype = jpn->permittype;
			permittype_ind = 0;

		}
		if(jpn->prdoctype >  0)
		{
			prdoctype = jpn->prdoctype;
			prdoctype_ind = 0;

		}
		
		if(jpn->rjstartdate[0] != '\0')
		{
			strcpy((char*)rjstartdate.arr, jpn->rjstartdate);
			setlen(rjstartdate);
			setnull(rjstartdate);
			rjstartdate_ind = 0;

		}
		if(jpn->rjenddate[0] != '\0')
		{
			strcpy((char*)rjenddate.arr, jpn->rjenddate);
			setlen(rjenddate);
			setnull(rjenddate);
			rjenddate_ind = 0;

		}
		if(jpn->ktstartdate[0] != '\0')
		{
			strcpy((char*)ktstartdate.arr, jpn->ktstartdate);
			setlen(ktstartdate);
			setnull(ktstartdate);
			ktstartdate_ind = 0;

		}
		if(jpn->ktenddate[0] != '\0')
		{
			strcpy((char*)ktenddate.arr, jpn->ktenddate);
			setlen(ktenddate);
			setnull(ktenddate);
			ktenddate_ind = 0;

		}
		if(jpn->blklstind != '\0')
		{
			blklstind = jpn->blklstind;
			blklstind = 0;

		}
		
		if(jpn->blklstcode[0] != '\0')
		{
			strcpy((char*)blklstcode.arr, jpn->blklstcode);
			setlen(blklstcode);
			setnull(blklstcode);
			blklstcode_ind = 0;

		}
		if(jpn->birthregndate[0] != '\0')
		{
			strcpy((char*)birthregndate.arr, jpn->birthregndate);
			setlen(birthregndate);
			setnull(birthregndate);
			birthregndate_ind = 0;

		}

		if(jpn->ktareacode[0] != '\0')
		{
			strcpy((char*)ktareacode.arr, jpn->ktareacode);
			setlen(ktareacode);
			setnull(ktareacode);
			ktareacode_ind = 0;

		}

		if(jpn->apjareacode[0] != '\0')
		{
			strcpy((char*)apjareacode.arr, jpn->apjareacode);
			setlen(apjareacode);
			setnull(apjareacode);
			apjareacode_ind = 0;

		}
		
		///if(jpn->afisbypass != '\0')
		//{
		//	afisbypass = jpn->afisbypass;
		//	afisbypass_ind = 0;
		//}
		
			
		/* print the host variables after copying from the input buffer */
		#ifdef DEBUG
			userlog("insert_into_jpn_info : local variables copied from Input buffer data");
			userlog("insert_into_jpn_info :kptno %s",kptno.arr);
			userlog("insert_into_jpn_info :birthdistrictcode %d",birthdistrictcode);
			userlog("insert_into_jpn_info :policeid %s",policeid.arr);
			userlog("insert_into_jpn_info :militaryid %s",militaryid.arr);
			userlog("insert_into_jpn_info :kppno %s",kppno.arr);
			userlog("insert_into_jpn_info :gender %c",gender);
			userlog("insert_into_jpn_info :personstatcode %c",personstatcode);
			userlog("insert_into_jpn_info :birthdate %s",birthdate.arr);
			userlog("insert_into_jpn_info :unknownbirthind %c",unknownbirthind);
			userlog("insert_into_jpn_info :religioncode %c",religioncode);
			userlog("insert_into_jpn_info :racecode %s",racecode.arr);
			userlog("insert_into_jpn_info :residentstat %c",residentstat);
			userlog("insert_into_jpn_info :citizenshipstatcode %c",citizenshipstatcode);
			userlog("insert_into_jpn_info :colourarticlecode %s",colourarticlecode.arr);
			userlog("insert_into_jpn_info :hkind %c",hkind);
			userlog("insert_into_jpn_info :iccolorcode %c",iccolorcode);
			userlog("insert_into_jpn_info :origname %s",origname.arr);
			userlog("insert_into_jpn_info :currlongname %s",currlongname.arr);
			userlog("insert_into_jpn_info :currshortname1 %s",currshortname1.arr);
			userlog("insert_into_jpn_info :currshortname2 %s",currshortname2.arr);
			userlog("insert_into_jpn_info :gmpcshortname1 %s",gmpcshortname1.arr);
			userlog("insert_into_jpn_info :gmpcshortname2 %s",gmpcshortname2.arr);
			userlog("insert_into_jpn_info :gmpcshortname3 %s",gmpcshortname3.arr);
			userlog("insert_into_jpn_info :address1 %s",address1.arr);
			userlog("insert_into_jpn_info :address2 %s",address2.arr);
			userlog("insert_into_jpn_info :address3 %s",address3.arr);
			userlog("insert_into_jpn_info :postcode %s",postcode.arr);
			userlog("insert_into_jpn_info :citycode %d",citycode);
			userlog("insert_into_jpn_info :statecode %s",statecode.arr);
			userlog("insert_into_jpn_info :ktindcode %s",ktindcode.arr);
			userlog("insert_into_jpn_info :jpnremarks1 %s",jpnremarks1.arr);
			userlog("insert_into_jpn_info :jpnremarks2 %s",jpnremarks2.arr);
			userlog("insert_into_jpn_info :afisflag %c",afisflag);
			userlog("insert_into_jpn_info :cardlostcnt %d",cardlostcnt);
			userlog("insert_into_jpn_info :kptapplstat %c",kptapplstat);
			userlog("insert_into_jpn_info :kptappldate %s",kptappldate.arr);
			userlog("insert_into_jpn_info :kptcollectiondate %s",kptcollectiondate.arr);
			userlog("insert_into_jpn_info :kptcollectionplaccode %s",kptcollectionplaccode.arr);
			userlog("insert_into_jpn_info :lastaddchangedate %s",lastaddchangedate.arr);
			userlog("insert_into_jpn_info :lastcardissuedate %s",lastcardissuedate.arr);
			userlog("insert_into_jpn_info :juvenileflag %c",juvenileflag);
			userlog("insert_into_jpn_info :cardversionno %d",cardversionno);
			userlog("insert_into_jpn_info :birthplace %s",birthplace.arr);
			userlog("insert_into_jpn_info :rjind %s",rjind.arr);
			userlog("insert_into_jpn_info :birthcertno %s",birthcertno.arr);
			userlog("insert_into_jpn_info :kptversionno %d",kptversionno);
			userlog("insert_into_jpn_info :polmilitaryjoindate %s",polmilitaryjoindate.arr);
			userlog("insert_into_jpn_info :retirementdate %s",retirementdate.arr);
			userlog("insert_into_jpn_info :orignameind %c",orignameind);
			userlog("insert_into_jpn_info :surrenderdate %s",surrenderdate.arr);
			userlog("insert_into_jpn_info :citizennationcode %s",citizennationcode.arr);
			userlog("insert_into_jpn_info :applapprovaldate %s",applapprovaldate.arr);
			userlog("insert_into_jpn_info :greencardexpdate %s",greencardexpdate.arr);
			userlog("insert_into_jpn_info :immrefno %s",immrefno.arr);
			userlog("insert_into_jpn_info :immrefdate %s",immrefdate.arr);
			userlog("insert_into_jpn_info :immexpdate %s",immexpdate.arr);
			userlog("insert_into_jpn_info :passportno %s",passportno.arr);
			userlog("insert_into_jpn_info :passportissuedate %s",passportissuedate.arr);
			userlog("insert_into_jpn_info :passportissuecountry %s",passportissuecountry.arr);
			userlog("insert_into_jpn_info :ucflag %c",ucflag);
			userlog("insert_into_jpn_info :permitno %s",permitno.arr);
			userlog("insert_into_jpn_info :permitissuedate %s",permitissuedate.arr);
			userlog("insert_into_jpn_info :permittype %d",permittype);
			userlog("insert_into_jpn_info :prdoctype %d",prdoctype);
			userlog("insert_into_jpn_info :rjstartdate %s",rjstartdate.arr);
			userlog("insert_into_jpn_info :rjenddate %s",rjenddate.arr);
			userlog("insert_into_jpn_info :ktstartdate %s",ktstartdate.arr);
			userlog("insert_into_jpn_info :ktenddate %s",ktenddate.arr);
			userlog("insert_into_jpn_info :blklstind %c",blklstind);
			userlog("insert_into_jpn_info :blklstcode %s",blklstcode.arr);
			userlog("insert_into_jpn_info :birthregndate %s",birthregndate.arr);
			userlog("insert_into_jpn_info : Release 3.28");
			userlog("insert_into_jpn_info :ktareacode %s",ktareacode.arr);
			userlog("insert_into_jpn_info :apjareacode %s",apjareacode.arr);
		#endif


		#ifdef DEBUG
			userlog("insert_into_jpn_info :Before deleting from  jpn_info ...");			
		#endif

		/* Deleting the existing record to insert the same record 
			with latest info */
		EXEC SQL DELETE FROM JPN_INFO WHERE KPTNO = :kptno;

		if(sqlca.sqlcode == 0)
		{
			#ifdef DEBUG
			userlog("insert_into_jpn_info :Record deleted from jpn_info for kptno : %s",kptno.arr);			
			#endif
		}
		else
		{
			#ifdef DEBUG
			userlog("insert_into_jpn_info :Record not deleted from jpn_info for kptno : %s",kptno.arr);			
			#endif
		}
		#ifdef DEBUG
			userlog("insert_into_jpn_info :After Deleting from  jpn_info");			
		#endif
		

		#ifdef DEBUG
			userlog("insert_into_jpn_info :Before inserting into jpn_info ...");			
		#endif
	
		EXEC SQL

		INSERT INTO JPN_INFO (KPTNO, BIRTHDISTRICTCODE, POLICEID, MILITARYID,
			KPPNO, GENDER, PERSONSTATCODE, BIRTHDATE, UNKNOWNBIRTHIND, RELIGIONCODE, 
			RACECODE, RESIDENTSTAT, CITIZENSHIPSTATCODE, COLOURARTICLECODE, HKIND, 
			ICCOLORCODE, ORIGNAME, CURRLONGNAME, CURRSHORTNAME1, CURRSHORTNAME2, 
			GMPCSHORTNAME1, GMPCSHORTNAME2, GMPCSHORTNAME3, ADDRESS1, ADDRESS2, 
			ADDRESS3, POSTCODE, CITYCODE, STATECODE, KTINDCODE, JPNREMARKS1, 
			AFISFLAG, CARDLOSTCNT, KPTAPPLSTAT, KPTAPPLDATE, KPTCOLLECTIONDATE, 
			KPTCOLLECTIONPLACCODE, LASTADDCHANGEDATE, LASTCARDISSUEDATE, JUVENILEFLAG, 
			CARDVERSIONNO, BIRTHPLACE, RJIND, BIRTHCERTNO, KPTVERSIONNO, POLMILITARYJOINDATE,
			RETIREMENTDATE, ORIGNAMEIND, SURRENDERDATE, CITIZENNATIONCODE, APPLAPPROVALDATE, 
			GREENCARDEXPDATE, IMMREFNO, IMMREFDATE, IMMEXPDATE, PASSPORTNO, PASSPORTISSUEDDATE,
			PASSPORTISSUECOUNTRY, UCFLAG, PERMITNO, PERMITISSUEDATE, PERMITTYPE, PRDOCTYPE,
			RJSTARTDATE, RJENDDATE, KTSTARTDATE, KTENDDATE, BLKLSTIND, BLKLSTCODE, 
			BIRTHREGNDATE,KTAREACODE,APJAREACODE)	VALUES(
			:kptno,:birthdistrictcode:birthdistrictcode_ind,
			:policeid:policeid_ind,:militaryid:militaryid_ind,
			:kppno:kppno_ind,:gender:gender_ind,:personstatcode:personstatcode_ind,
			TO_DATE(:birthdate:birthdate_ind,'DDMMYYYY'),
			:unknownbirthind:unknownbirthind_ind,
			:religioncode:religioncode_ind,:racecode:racecode_ind,
			:residentstat:residentstat_ind,:citizenshipstatcode:citizenshipstatcode_ind,
			:colourarticlecode:colourarticlecode_ind,:hkind:hkind_ind,
			:iccolorcode:iccolorcode_ind,:origname:origname_ind,
			:currlongname:currlongname_ind,:currshortname1:currshortname1_ind,
			:currshortname2:currshortname2_ind,:gmpcshortname1:gmpcshortname1_ind,
			:gmpcshortname2:gmpcshortname2_ind,:gmpcshortname3:gmpcshortname3_ind,
			:address1:address1_ind,:address2:address2_ind,:address3:address3_ind,
			:postcode:postcode_ind,:citycode:citycode_ind,:statecode:statecode_ind,
			:ktindcode:ktindcode_ind,:jpnremarks1:jpnremarks1_ind,
			//:jpnremarks2:jpnremarks2_ind, commented on 24/08/06 to update this data to APPLICATION.APPRVLDOCNO
			:afisflag:afisflag_ind,
			:cardlostcnt:cardlostcnt_ind,:kptapplstat:kptapplstat_ind,
			TO_DATE(:kptappldate:kptappldate_ind,'DDMMYYYY'),
			TO_DATE(:kptcollectiondate:kptcollectiondate_ind,'DDMMYYYY'),
			:kptcollectionplaccode:kptcollectionplaccode_ind,
			TO_DATE(:lastaddchangedate:lastaddchangedate_ind,'DDMMYYYY'),
			TO_DATE(:lastcardissuedate:lastcardissuedate_ind,'DDMMYYYY'),
			:juvenileflag:juvenileflag_ind,
			:cardversionno:cardversionno_ind,:birthplace:birthplace_ind,
			:rjind:rjind_ind,:birthcertno:birthcertno_ind,:kptversionno:kptversionno_ind,
			TO_DATE(:polmilitaryjoindate:polmilitaryjoindate_ind,'DDMMYYYY'),
			TO_DATE(:retirementdate:retirementdate_ind,'DDMMYYYY'),			
			:orignameind:orignameind_ind,
			TO_DATE(:surrenderdate:surrenderdate_ind,'DDMMYYYY'),
			:citizennationcode:citizennationcode_ind,
			TO_DATE(:applapprovaldate:applapprovaldate_ind,'DDMMYYYY'),
			TO_DATE(:greencardexpdate:greencardexpdate_ind,'DDMMYYYY')
			,:immrefno:immrefno_ind,
			TO_DATE(:immrefdate:immrefdate_ind,'DDMMYYYY')
			,TO_DATE(:immexpdate:immexpdate_ind,'DDMMYYYY'),:passportno:passportno_ind,
			TO_DATE(:passportissuedate:passportissuedate_ind,'DDMMYYYY'),
			:passportissuecountry:passportissuecountry_ind,
			:ucflag:ucflag_ind,:permitno:permitno_ind,
			TO_DATE(:permitissuedate:permitissuedate_ind,'DDMMYYYY'),
			:permittype:permittype_ind,:prdoctype:prdoctype_ind,
			TO_DATE(:rjstartdate:rjstartdate_ind,'DDMMYYYY'),
			TO_DATE(:rjenddate:rjenddate_ind,'DDMMYYYY'),
			TO_DATE(:ktstartdate:ktstartdate_ind,'DDMMYYYY'),
			TO_DATE(:ktenddate:ktenddate_ind,'DDMMYYYY'),
			:blklstind:blklstind_ind,:blklstcode:blklstcode_ind,
			TO_DATE(:birthregndate:birthregndate_ind,'DDMMYYYY'),
			:ktareacode:ktareacode_ind,:apjareacode:apjareacode_ind);	

		if(SQLCODE != 0)
		{
			#ifdef DEBUG
			userlog("insert_into_jpn_info :insert into jpn_info failed: %s", SQLMSG);			
			#endif
			strcpy(prog_log.remarks, "insert_into_jpn_info : Service failed due to INSERT_ERROR");
			sprintf(excep_log.error_msg, "put_approved_data : insert into jpn_info failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;
			log_error(ctx);
			return INSERT_ERROR;
		}
		#ifdef DEBUG
			userlog("insert_into_jpn_info :insert into jpn_info Successful");			
		#endif


	return GMPC_GOOD;
}

//Added by Salmi Date:12th May, 2020 Function to insert DLEWAT_APPRV_HISTORY. CRAPPL-  SKP002/CR/2020
/****************************************************************************/
/* Function name: insert_into_dlewat_apprv_history_table					*/
/* Description	: This function inserts into application tables				*/
/* Input		: char appl_id[APP_ID_SIZE]	...	                            */
/* Return values: GMPC_GOOD, ret,INSERT_ERROR								*/
/* Limitations	:															*/
/****************************************************************************/
int insert_into_dlewat_apprv_history_table(char *appl_id, SET_APPL_STAT_L3_REQ_T *apprv_htr, void * ctx)
{

	struct sqlca sqlca = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	char applId[APP_ID_SIZE] = {0};
	int  apprvNo = -1;
	varchar apprvOperId[USER_ID_SIZE]= {0};
	char apprvStatus = '\0';
	varchar apprvIntvDateTime[DATE_TIME_SIZE]= {0};
	varchar apprvRemark[DELWAT_REMARKS_SIZE]= {0};
	char apprvBranch[BRANCH_CODE_SIZE]= {0};
	varchar apprvDateTimeStamp[DATE_TIME_SIZE] = {0};
	char userKptno[KPT_SIZE]= {0};
		
	short int applId_ind = -1;
	short int apprvNo_ind = -1;
	short int apprvOperId_ind = -1;
	short int apprvStatus_ind = -1;
    short int apprvIntvDateTime_ind = -1;
    short int apprvRemark_ind = -1;
    short int apprvBranch_ind = -1;
	short int apprvDateTimeStamp_ind = -1;
	short int userKptno_ind = -1;
		
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;
	
	int ret_code = 0;
	int count = 0;
	int otxncount = 0;
	
	pcCtx = ctx; 
	EXEC SQL CONTEXT USE :pcCtx;

	#ifdef DEBUG
		userlog(" ");
		userlog("request buffer inside DLEWAT_APPRV_HISTORY function ");
		userlog("appl_id :%s:\n", appl_id);
		userlog("apprvNo :%d:\n", apprv_htr->apprvNo);
		userlog("operId :%d:\n", apprv_htr->operId); 
		userlog("status :%c:\n", apprv_htr->status); 
		userlog("intvDateTime :%s:\n", apprv_htr->intvDateTime); 
		userlog("remark :%s:\n", apprv_htr->remark); 
		userlog("apprvBranch :%s:\n", apprv_htr->apprvBranch);
		userlog("dateTimeStamp :%s:\n", apprv_htr->dateTimeStamp); 
		userlog("userKptno :%s:\n", apprv_htr->userKptno); 
		userlog(" ");
		
	#endif
	
	if((appl_id[0] != '\0') && (appl_id[0] != ' '))
	{
		strcpy(applId, appl_id);
	}	
    
	apprvNo = 0;
	apprvOperId.arr[0] = '\0';
	apprvStatus = '\0';
	apprvIntvDateTime.arr[0];
	apprvRemark.arr[0] = '\0';
	apprvBranch[0] = '\0';
	apprvDateTimeStamp.arr[0] = '\0';
	userKptno[0] = '\0';

	apprvNo = apprv_htr->apprvNo;
	
	if((apprv_htr->operId[0] != '\0') && (apprv_htr->operId[0] != ' '))
	{
		strcpy((char*)apprvOperId.arr, apprv_htr->operId);	
		setlen(apprvOperId);
	}
	if((apprv_htr->status != '\0') &&(apprv_htr->status != ' '))	
	{
		apprvStatus = apprv_htr->status;
	}
	if((apprv_htr->intvDateTime[0] != '\0') && (apprv_htr->intvDateTime[0] != ' '))	
	{	
		strcpy((char*)apprvIntvDateTime.arr, apprv_htr->intvDateTime);	
		setlen(apprvIntvDateTime);
	}
	
	if((apprv_htr->remark[0] != '\0') && (apprv_htr->remark[0] != ' '))	
	{	
		strncpy((char*)apprvRemark.arr, apprv_htr->remark, 201);	
		setlen(apprvRemark);
		#ifdef DEBUG
		userlog("apprvRemark :%s:\n", apprvRemark.arr); 
		#endif
	}
	
	if(apprv_htr->apprvBranch[0] != '\0') 
	{	
		strcpy(apprvBranch, apprv_htr->apprvBranch);	
	}

	if((apprv_htr->dateTimeStamp[0] != '\0') && (apprv_htr->dateTimeStamp[0] != ' '))	
	{	
		strcpy((char*)apprvDateTimeStamp.arr, apprv_htr->dateTimeStamp);	
		setlen(apprvDateTimeStamp);
	}

	if(apprv_htr->userKptno[0] != '\0') 
	{	
		strcpy(userKptno, apprv_htr->userKptno);	
	}
		
	applId_ind = 0;
	apprvNo_ind = 0;
	apprvStatus_ind = 0;
	apprvOperId_ind = 0;
	apprvIntvDateTime_ind = 0;
	apprvRemark_ind = 0;
	apprvBranch_ind = 0;
	apprvDateTimeStamp_ind = 0;
	userKptno_ind = 0;
		
	#ifdef DEBUG
		userlog("request buffer before INSERT DLEWAT_APPRV_HISTORY ");
		userlog("applId :%s:\n", applId);
		userlog("apprvNo :%d:\n", apprvNo);
		userlog("apprvStatus :%c:\n", apprvStatus); 
		userlog("apprvOperId :%s:\n", apprvOperId.arr); 
		userlog("apprvIntvDateTime :%s:\n", apprvIntvDateTime.arr);
		userlog("apprvRemark :%s:\n", apprvRemark.arr); 
		userlog("apprvBranch :%s:\n", apprvBranch); 
		userlog("apprvDateTimeStamp :%s:\n", apprvDateTimeStamp.arr); 
		userlog("userKptno :%s:\n", userKptno); 
		userlog(" ");
		
	#endif
	EXEC SQL INSERT INTO DLEWAT_APPRV_HISTORY(
		 APPLID,
		 APPRVNO,
		 OPERID,
		 STATUS,
		 INTVDATETIME,
		 REMARK,
		 APPRVBRANCH,
		 DATETIMESTAMP,
		 USERKPTNO)
		 
		 VALUES(:applId:applId_ind,
				:apprvNo:apprvNo_ind,
				:apprvOperId:apprvOperId_ind,
				:apprvStatus:apprvStatus_ind,
				TO_DATE(:apprvIntvDateTime:apprvIntvDateTime_ind,'DD/MM/YYYY HH24MISS'),
				:apprvRemark:apprvRemark_ind, 
				:apprvBranch:apprvBranch_ind, 
			    TO_DATE(:apprvDateTimeStamp:apprvDateTimeStamp_ind,'DD/MM/YYYY HH24MISS'),
				:userKptno:userKptno_ind
				 );

	    		
        if(SQLCODE != 0)
        {
        	#ifdef DEBUG
        		userlog("SET_APPL_STAT_L3 : failed to insert into DLEWAT_APPRV_HISTORY table ");
        	#endif
        	strcpy(prog_log.remarks,"SET_APPL_STAT_L3 : failed to insert into DLEWAT_APPRV_HISTORY table");
        	sprintf(excep_log.error_msg,"SET_APPL_STAT_L3 : failed to insert into DLEWAT_APPRV_HISTORY table: %s",SQLMSG);
        	excep_log.termination_flag = 'Y';
        	excep_log.severity = FATAL;
        	log_error(ctx);
        
        	return INSERT_ERROR;
        }

    
    #ifdef DEBUG
    	userlog("SET_APPL_STAT_L3 : inserted successfully into DLEWAT_APPRV_HISTORY table ");
    #endif
	return SUCCESS;

}
//Added by Salmi Date:12th May, 2020 Function to insert DLEWAT_APPRV_HISTORY. CRAPPL-  SKP002/CR/2020-End

//Added by Subramaniam.P on 10th June,2020 update_regn_dlewat. CRAPPL-  SKP002/CR/2020
int update_regn_dlewat(char *applid, char *rejectdate,char *appealdate,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 09/03/06
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE]={0};
	char hRejectdate[DATE_TIME_SIZE]={0};
	char hAppealdate[DATE_TIME_SIZE]={0};

	short application_id_ind = 0;
	short hReject_ind = 0;
	short hAppeal_ind = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN


	#ifdef DEBUG
		userlog("update_regn_dlewat :applid :%s:", applid);
		userlog("update_regn_dlewat :Reject Date:%s:",rejectdate);
		userlog("update_regn_dlewat :Appeal Date:%s:",appealdate);
	#endif

	strcpy(application_id,applid);
	strcpy(hRejectdate,rejectdate);
	strcpy(hAppealdate,appealdate);


	#ifdef DEBUG
		userlog("update_regn_dlewat :application_id :%s:", application_id);
		userlog("update_regn_dlewat :hReject Date:%s:",hRejectdate);
		userlog("update_regn_dlewat :hAppeal Date:%s:",hAppealdate);
	#endif

	EXEC SQL UPDATE REGN_DLEWAT 
		SET   REJECTDATE  = TO_DATE(:hRejectdate:hReject_ind, 'DD/MM/YYYY HH24MISS'),
		      APPEALDATE  = TO_DATE(:hAppealdate:hAppeal_ind, 'DD/MM/YYYY HH24MISS')
		WHERE APPLID = :application_id:application_id_ind;

	userlog("update_regn_dlewat : sqlca.sqlcode & sqlmsg : %d, %s",sqlca.sqlcode,SQLMSG);

	if(SQLCODE)
	{
		strcpy(prog_log.remarks,"update_regn_dlewat : Service failed due to UPDATE_ERROR");
		sprintf(excep_log.error_msg,"update_regn_dlewat : updating update_regn_dlewat with rejectdate,appealdate failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return UPDATE_ERROR;
	}

	return GMPC_GOOD;
}

//Added by Subramaniam.P on 10th June,2020 update_regn_dlewat. CRAPPL-  SKP002/CR/2020-End
 /* end IJPN */

//Added by Salmi on 25th June 2020, to maintain correct APPLICATION.priority
int maintain_application_priority(char *applid, void * ctx)
{
/*
	struct sqlca sqlca = {0}; 
	EXEC SQL BEGIN DECLARE SECTION;
	char application_id[APP_ID_SIZE]={0};
	char prnxpress = {0};

	short application_id_ind = 0;
	short prnexpress_ind = 0;

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	#ifdef DEBUG
        userlog("maintain_application_priority : applid %s ", applid);
    #endif

	if((applid[0] != '\0') && (applid[0] != ' '))
	{
		strcpy(application_id, applid);
	}

	EXEC SQL SELECT PRNXPERSS INTO :prnxpress:prnxpress_ind 
			 FROM TXN_CODE WHERE 
			 TXNCODE = (SELECT TXNCODE FROM APPL_TXN WHERE APPLID= :application_id:application_id_ind);

	if(SQLCODE)
	{

	#ifdef DEBUG
        userlog("maintain_application_priority : failed to select TXN_CODE table ");
    #endif

	}
	

	//Select XPRESS_CLUSTER_DET  ????
	

	//Update APPLICATION.priority
	EXEC SQL UPDATE APPLICATION SET PRIORITY = 4 
		WHERE APPLID= :application_id:application_id_ind);

	if(SQLCODE)
	{
	#ifdef DEBUG
		userlog("maintain_application_priority: update APPLICATION sqlcode :%d",sqlca.sqlcode);			
	#endif

	}


	#ifdef DEBUG
		userlog("maintain_application_priority: update APPLICATION success !!!);			
	#endif
*/
	return GMPC_GOOD;


}
//Added by Salmi on 25th June 2020, to maintain correct APPLICATION.priority -End

/********************************************************************/
/* Function name: check_dlkp_trans				     				*/
/* Description	: This function 									*/
/* Input		: Application Id									*/
/* Return values: GMPC_GOOD,										*/
/* Limitations	:													*/
/********************************************************************/
int check_dlkp_trans(char *applid, int * dlkp_flag,void * ctx)
{
	struct sqlca sqlca = {0}; 
	EXEC SQL BEGIN DECLARE SECTION;
		char application_id[APP_ID_SIZE];
		int dlkp = 0;
	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	
	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	strcpy(application_id, applid);

	EXEC SQL
		SELECT DECODE(SUBSTR(b.txncode,1,2),'12',1,0) 
		INTO :dlkp 
		from APPL_TXN a, TXN_CODE b
		WHERE APPLID = :application_id
		AND a.txnserno = 1
		AND a.txncode = b.txncode;

	if((SQLCODE) != 0 && (SQLCODE != 1403))
	{
		strcpy(prog_log.remarks,"check_dlkp_trans : check_dlkp_trans failed");
		sprintf(excep_log.error_msg,"check_dlkp_trans : check_dlkp_trans failed : %s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;
		log_error(ctx);
		return SELECT_ERROR;
	}

	*dlkp_flag = dlkp;

#ifdef DEBUG
	userlog("check_dlkp_trans :dlkp_flag %d", *dlkp_flag);
#endif

	return GMPC_GOOD;
}
