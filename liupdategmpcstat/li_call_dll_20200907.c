#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


#include "gscbdef.h"
#include "gscblookupdef.h"
#include "gscbio.h"
#include "gscblog.h"


#include "KPPdef.h"
#include "KPPstruct.h"
#include "KPPproto.h"
#include "field_id.h"
#include "HTPIJPNCPIC.h"
#include "userlog.h"

void dump_to_file(char *msg_id, char *trans_code, char *ext, char *buf, int len);

int  li_call_dll_st(LI_PUT_HEADER_T put_header, 
			LI_PUT_VAR_DATA_T put_var_data, 
			LI_PUT_FIN_DATA_T put_fin_data,
			unsigned char *msg_id,
			int *error_code,
			unsigned char *pReplyMsg,
			int *iReplyMsgLen,
			char *sErrMessage)
{
	/*************************************************************************/
	/* local variables														 */
	/*************************************************************************/
	
	char *mq_msg, *var_data_ptr;
	long mq_msg_len;

	MSG_HEADER_T *msg_header;
	FIN_DATA_T *msg_fin_data, *temp_fin_ptr;


	/* Date Time variables */
	time_t ltime;
	struct tm *today;
	char curr_date[9], curr_time[7];

	/* Registry read structure */
	READ_REG_GENERIC_T reg_data;

	/* MQSeries specific variables */
	

	/* misc variables */
	int count = 0, li_init_done = 0, ret = 0;
	char *next_sequence = NULL;
	char sequence[5];
	int temp_trans_code = 0;
	char *temp_ptr = NULL;
	int end_of_message = 0xff;
	char region_ind[4];
	char ws_seq_no[4] = {0};

	/* dll return code */
	int nReturn = 0;
	
	
	/*************************************************************************/
	/* Code begins here														 */
	/*************************************************************************/
	
	/* Allocate memory for the acutal message buffer*/
	/* Two additional bytes are required for message terminators 0xff and 0xff */
	temp_trans_code =  atoi(put_header.trans_code);
	
	switch (temp_trans_code)
	{
	case LI_JPN_MASTER_DOWNLOAD:
	case LI_JPN_DISTRIBUTION_DOWNLOAD:
	case LI_JPJ_MASTER_DOWNLOAD:
	case LI_JPJ_DISTRIBUTION_DOWNLOAD:
	case LI_JIM_MASTER_DOWNLOAD:
	case LI_JIM_DISTRIBUTION_DOWNLOAD:
		/* No variable data is to be sent for lookup download requests */
		mq_msg_len = MESSAGE_HEADER_SIZE + 2;
		break;
	default:
		mq_msg_len = MESSAGE_HEADER_SIZE + put_var_data.len + 2;
		break;
	}

	/* check if financial data is present, if yes, allocate that much 
	   additional memory */
	if (put_fin_data.counter > 0)
		mq_msg_len += put_fin_data.len;
	   
	mq_msg = (char *) malloc(mq_msg_len);
	if (mq_msg == NULL)
	{
		/*
		strcpy(prog_log.remarks, "li_put_dll: MEM_ERROR - malloc call failed");
		strcpy(excep_log.error_msg, "li_put_dll: MEM_ERROR - malloc call failed");
		excep_log.severity = FATAL;
		log_error();
		*/
		*error_code = MALLOC_ERROR;
		return GMPC_BAD;
	}

	memset(mq_msg,' ',mq_msg_len);

	/* Get current date time */
	time(&ltime);
	today = localtime(&ltime);
	strftime(curr_date,9,"%Y%m%d",today);
	strftime(curr_time,7,"%H%M%S",today);
	
	/*************************************************************************/
	/* Copy stuff into message header										 */
	/*************************************************************************/

	msg_header = (MSG_HEADER_T *) mq_msg;
	msg_header->msg_class = 'A';
	msg_header->msg_type = put_header.msg_type;
	msg_header->send_to_AFIS = '\0';
	msg_header->AFIS_matching = '\0';
	msg_header->reply_header.reply_indicator = '\0';

	/* The format of the request id is "GMPCMSGYYYYMMDDHHMMSSnnn"	*/
	/* where nnn is a unique number generated by an Oracle sequnce.	*/
	/* copy the brance code*/
	//strcpy(msg_header->request_id,"GMPCMSG");
	strcpy(msg_header->request_id,put_header.gsc_no);
	strcat(msg_header->request_id,curr_date);
	strcat(msg_header->request_id,curr_time);


	if (strlen(put_header.workstation_id) == ((WS_ID_SIZE - 1) - 3))	
	{
		strncpy(ws_seq_no, put_header.workstation_id + 10, 2);
		ws_seq_no[2] = '\0';
		msg_header->trans_machine = (unsigned char) atoi(ws_seq_no);
	}
	else if (strlen(put_header.workstation_id) < 4)	/* WS id by update request */
	{
		userlog("get workstation id after < 4");
		strcpy(ws_seq_no, put_header.workstation_id);
		ws_seq_no[0] = '0';
		ws_seq_no[3] = '\0';
//		strcpy(ws_seq_no, put_header.workstation_id);
		msg_header->trans_machine = (unsigned char) atoi(ws_seq_no);
		userlog("get workstation id end");
	}
	else if ((strlen(put_header.workstation_id) > 4) && (strlen(put_header.workstation_id) < 6))	/* WS id by update request */
	{
		userlog("get workstation id after > 4");
		strcpy(ws_seq_no, put_header.workstation_id);
		ws_seq_no[0] = '0';
		ws_seq_no[3] = '\0';
//		strcpy(ws_seq_no, put_header.workstation_id);
		msg_header->trans_machine = (unsigned char) atoi(ws_seq_no);
	}
	else
	{
		msg_header->trans_machine = 1;
	}


	if (msg_header->trans_machine == 1)
		strcpy(sequence, "99");
	else
		sprintf(sequence,"%d",msg_header->trans_machine);
	
	next_sequence = (char *)&sequence;

	strncat(msg_header->request_id, next_sequence, 3);
	
	strcpy(msg_id,msg_header->request_id);
	msg_header->agency_id = put_header.agency_id;
	strncpy(msg_header->msg_create_date, curr_date,8);
	strncpy(msg_header->msg_create_time, curr_time,6);

	/* The gsc_no is 6 chars while branch_code is 8.  This is a mismatch*/
	strncpy(msg_header->branch_code, put_header.gsc_no,strlen(put_header.gsc_no));

	userlog(" temp_trans_code [%d]", temp_trans_code);
	/* set the transaction mode - new for reversal message (for D2) */
	switch (temp_trans_code)	{
		case LI_JPN_REV_UPDATE_PAYMENT:
		case LI_JPJ_REV_NEW_LICENSE:
		case LI_JPJ_REV_RENEWAL:
		case LI_JPJ_REV_ADD_CLASS:
		case LI_JPJ_REV_SUMMON_PAYMENT:
		case LI_JPJ_REV_UPDATE_PAYMENT:
		case LI_JPJ_REV_LIC_REPL:
		case LI_JPJ_REV_ID_TO_KPT_UPD:
		case LI_JPJ_REV_PSV_GDL_CLASS:
		case LI_JPN_CANCEL_GMPC_UPD:
		case LI_JPN_ADDRESS_REVERSAL:
			msg_header->trans_mode = 'R';
			break;

		default:
			msg_header->trans_mode = 'N';
			break;
	}

	strncpy(msg_header->trans_code, put_header.trans_code,strlen(put_header.trans_code));
	
		
	/* SENDING ONLY FIRST 8 CHARACTERS OF USER ID.  NT LOGIN CAN BE 20 CHARS
		LONG THIS IS A MISMATCH */
	if (strlen(put_header.user_id) > 8)
		strncpy(msg_header->oper_id, put_header.user_id, 8);
	else
		strncpy(msg_header->oper_id, put_header.user_id, strlen(put_header.user_id));

	ltoa(put_fin_data.counter, msg_header->amount_counter,10);
	ltoa(put_fin_data.len, msg_header->amount_length, 10);
	
//	msg_header->send_to_AFIS = put_header.send_to_AFIS;


	/* Check if this is a Master File Download Request */
 
	temp_trans_code = atoi(put_header.trans_code);

	/* Need to pass trans date and time to KPP*Gate */
	// commeted code has been removed from here
	switch (temp_trans_code)
	{
		case LI_JPN_MASTER_DOWNLOAD:
		case LI_JPJ_MASTER_DOWNLOAD:
		case LI_JIM_MASTER_DOWNLOAD:
		{	// Need to put the file type into the filler
			if(put_var_data.len > 1)
			{
				temp_ptr = put_var_data.data;
				li_ddmmyyyy_to_yyyymmdd(msg_header->trans_date, temp_ptr);
				temp_ptr += strlen(temp_ptr) + 1;
				strcpy(msg_header->trans_time, temp_ptr);
				temp_ptr += strlen(temp_ptr) + 1; /* added for jpn_person_blacklist partial download on 07/01/2004 */
				msg_header ->filler[0]= *temp_ptr; /* added for jpn_person_blacklist partial download on 07/01/2004 */
			}
			else
			{
				msg_header->filler[0] = put_var_data.data[0];
				strcpy(msg_header->trans_date, curr_date);
				strcpy(msg_header->trans_time, curr_time);
			}
		}

			break;

		case LI_JPN_DISTRIBUTION_DOWNLOAD:
		case LI_JPJ_DISTRIBUTION_DOWNLOAD:
		case LI_JIM_DISTRIBUTION_DOWNLOAD:
			temp_ptr = put_var_data.data;
			li_ddmmyyyy_to_yyyymmdd(msg_header->trans_date, temp_ptr);
			temp_ptr += strlen(temp_ptr) + 1;
			strcpy(msg_header->trans_time, temp_ptr);
			break;

		case LI_JPJ_UPDATE_PAYMENT_INFO:
		case LI_JPN_UPDATE_PAYMENT_INFO:
			// Use the current date
			//strcpy(msg_header->trans_date, curr_date);
			li_ddmmyyyy_to_yyyymmdd(msg_header->trans_date, put_header.trans_date);
			strcpy(msg_header->trans_time, put_header.trans_time);
			//strcpy(msg_header->trans_time, curr_time);

			// Assuming that GSCB will NEVER split the message so set the msg_no	
			// and msg_total fields to 1											
			strcpy(msg_header->msg_no, "1");
			strcpy(msg_header->msg_total, "1");
			break;

		case LI_JPN_CASH_SUMMARY:
		case LI_JPJ_CASH_SUMMARY:
			// set the msg_no and msg_total fields to 1 assuming we will not split messages 
			// we will utilize the GSCB filler portion
			li_ddmmyyyy_to_yyyymmdd(msg_header->trans_date, put_header.trans_date);
			//strcpy(msg_header->trans_time, curr_time);
			strcpy(msg_header->trans_time, put_header.trans_time);
			strcpy(msg_header->filler_GSCB, "1");
			strcpy(msg_header->filler_GSCB + 2, "1");
			break;

		default:
			if( put_header.trans_date[0] != '\0')	{
				li_ddmmyyyy_to_yyyymmdd(msg_header->trans_date, put_header.trans_date);
				strncpy(msg_header->trans_time, put_header.trans_time,6);
			}
			else	{
				strcpy(msg_header->trans_date, curr_date);
				strcpy(msg_header->trans_time, curr_time);
			}

			break;
	}

	/* Check if request has been put from GSC workstation or Console */
	/* If it is GSC workstation, extract the unique sequence no      */
	/* from Workstation id (last 3 characters)						 */

//	if (strlen(put_header.workstation_id) == ((WS_ID_SIZE - 1) - 3))	
//	{
//		strncpy(ws_seq_no, put_header.workstation_id + 10, 2);
//		ws_seq_no[2] = '\0';
//		msg_header->trans_machine = (unsigned char) atoi(ws_seq_no);
//	}
//	else if (strlen(put_header.workstation_id) < 4)	/* WS id by update request */
//	{
//		strcpy(ws_seq_no, put_header.workstation_id);
//		msg_header->trans_machine = (unsigned char) atoi(ws_seq_no);
//	}
//	else
//	{
//		msg_header->trans_machine = 1;
//	}

#ifdef DEBUG
	userlog("Transaction machine - %d", msg_header->trans_machine);
#endif

	/* Copy the Reference date and time, Refer machine */

	if (put_header.refer_date[0] != ' ')
	{
//		strcpy(msg_header->ref_date, put_header.refer_date);
		li_ddmmyyyy_to_yyyymmdd(msg_header->ref_date, put_header.refer_date);
		strcpy(msg_header->ref_time, put_header.refer_time);

		/* The referred machine is same as transaction machine */
		msg_header->ref_machine = msg_header->trans_machine;
	}

	/* set the region indicator */

	/* read the value from registry */
	strcpy(reg_data.value_name, "RegionIndicator");
	reg_data.value = (unsigned char *)&region_ind[0];

	ret = read_registry(KPP_GATE_INTERFACE_ID, NULL, &reg_data);
	if(GMPC_GOOD != ret)
	{
/*		strcpy(prog_log.remarks, "li_put_dll: Unable to read registry for Region Indicator");
		sprintf(excep_log.error_msg,
			"li_put_dll : Unable to read registry for Region Indicator. " \
			"Using default of %s", TEST_IND);

		excep_log.severity = WARNING;
		log_error();*/

		strcpy(region_ind, TEST_IND);
		
	}


	/* copy value into message header */
	/* it is the last byte of filler and a binary value */
	msg_header->filler[sizeof(msg_header->filler) - 1] = (unsigned char) atoi(region_ind);

	#ifdef DEBUG
		userlog("region_ind - %s", region_ind);
		userlog("msg_header->filler - %s", msg_header->filler);
	#endif

	/*************************************************************************/
	/* Copy financial data into the buffer									 */
	/*************************************************************************/
	
	if(put_fin_data.counter > 0)
	{
		msg_fin_data = (FIN_DATA_T *)(mq_msg + MESSAGE_HEADER_SIZE);
		temp_fin_ptr = put_fin_data.fin_data;

		/* The maximum number of allowed financial messages is 9 */
		/* since we need to fit all messages within 200 bytes */
		if (put_fin_data.counter > 10)
			put_fin_data.counter = 10;

		for(count = 1;count <= put_fin_data.counter; count++)
		{
			memcpy((void *)msg_fin_data,(void *)temp_fin_ptr,sizeof(FIN_DATA_T));
			
			msg_fin_data++;
			temp_fin_ptr++;
		}

	}

	/*************************************************************************/
	/* Copy variable data into the buffer									 */
	/*************************************************************************/
	
	if (put_fin_data.counter > 0)
		var_data_ptr = mq_msg + MESSAGE_HEADER_SIZE + put_fin_data.len; 
	else
		var_data_ptr = mq_msg + MESSAGE_HEADER_SIZE;

	temp_trans_code =  atoi(put_header.trans_code);
	
	/* Lookup download requests do not have any variable data */
	switch (temp_trans_code)
	{
	case LI_JPN_MASTER_DOWNLOAD:
	case LI_JPN_DISTRIBUTION_DOWNLOAD:
	case LI_JPJ_MASTER_DOWNLOAD:
	case LI_JPJ_DISTRIBUTION_DOWNLOAD:
	case LI_JIM_MASTER_DOWNLOAD:
	case LI_JIM_DISTRIBUTION_DOWNLOAD:
		break;
		
	default:
		memcpy(var_data_ptr, put_var_data.data, put_var_data.len);
		var_data_ptr += put_var_data.len;
		break;
	}
	*var_data_ptr = end_of_message;
	var_data_ptr++;
	*var_data_ptr = end_of_message;

#ifdef DEBUG
	userlog("Before call Update JPN.....");
#endif

#ifdef DEBUG
	userlog("Calling dump_to_file.....");
#endif


//#ifdef DEBUG
	dump_to_file(msg_id, put_header.trans_code, ".req", mq_msg, mq_msg_len);
//#endif

	/* Simple isn't it? */
	
	/*************************************************************************/
	/* PUT the message														 */
	/* Call the enquiry dlls												 */
	nReturn = UpdateJPNHost(mq_msg, mq_msg_len,
		pReplyMsg, iReplyMsgLen,sErrMessage);
	if(nReturn!=1)
	{
	#ifdef DEBUG
		userlog("UpdateJPNHost Failed with %s",sErrMessage);
	#endif
		if(sErrMessage != NULL)
		{
			if(strncmp(sErrMessage,"JPN0009E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0001E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0073E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0089E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0093E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0102E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0117E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN0122E",8) == 0)
				*error_code = NO_MSG_ERROR;
			else if(strncmp(sErrMessage,"JPN",3) == 0)
				*error_code = GET_KPT_REC_NOT_FOUND;
			else
				*error_code = CONN_ERROR;

		}
		else		
			*error_code = PUT_ERROR;
		return GMPC_BAD;
	}

//#ifdef DEBUG
	dump_to_file(msg_id, put_header.trans_code, ".rsp", pReplyMsg, *iReplyMsgLen);
//#endif


	*error_code = 0;

#ifdef DEBUG
	userlog("Returning from li_put_dll");
#endif

	return GMPC_GOOD;
}

/************************************************************************/
/* Function Name	: dump_to_file									    */
/* Description		: Function to Write request/response to a file		*/										
/* Input			: Message id for request/response					*/
/*					  extension for the file							*/
/* Return Values	: void												*/
/* Limitations		:													*/
/************************************************************************/

void dump_to_file(char *msg_id, char *trans_code, char *ext, char *buf, int len)
{
	FILE *fp;
	char dump_path[MAX_PATH];
	int ret; 
	
	/* Registry read structure */
	READ_REG_GENERIC_T reg_data; 

	char file_name[MSG_ID_SIZE + 20] = ""; /* 20 chars more for trans code and extension */

#ifdef DEBUG
	userlog("IJpnSna: starting dump to file");
#endif

	strcpy(reg_data.value_name, "MsgDumpPath");
	reg_data.value = (unsigned char *)&dump_path;
	ret = read_registry(KPP_GATE_INTERFACE_ID, NULL, &reg_data);
	if(GMPC_GOOD != ret)
	{
//		userlog("IJpnSna: Error reading 'MsgDumpPath' from registry");
		dump_path[0] = '\0';
	}
	else 
		strcat(dump_path, "\\");

	sprintf(file_name, "%s-%s%s", msg_id, trans_code, ext);
	strcat(dump_path, file_name); 


#ifdef DEBUG
	userlog("IJpnSna: dumped to file %s", dump_path);
#endif
	
	fp = fopen(dump_path, "ab");
	if (!fp)
		return;

	fwrite(buf, len, 1, fp);
	fclose(fp);
}




