#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>

#include <sqlca.h>


#include "gscbdef.h"
#include "gscbio.h"
#include "gscblog.h"
#include "gscblookupdef.h"

#include "KPPdef.h"
#include "KPPstruct.h"
#include "KPPproto.h"

#include "li_update_gmpc_stat.h"

#include "jpn_status_upd_io.h"
#include "jpn_status_upd.h"

#include "userlog.h"

#include "jpn_status_upd_io.h"

//extern "C" void userlog(char* szFormatString, ...);
long gzSleepTime;
extern bool g_bSlpState;

APPL_EXCEP_LOG_T excep_log = { {""},{""},{""},{""},{""},{""}, 0,{""}} ;
PROG_ACCESS_LOG_T prog_log = { {""},{""},{""},{""},{""},{""},{""},{""} };

TXN_LOG_T tran_log;


/************************************************************************************/
/* Function Name:	LoginToOracle()         										*/
/* Input		:	1. sql context							              			*/
/*					2. User id														*/
/*					3. Password														*/
/* Return Values:   GMPC_GOOD/oracle error											*/
/* Description	:	This function connects to oracle using the userid and password	*/
/*					read from the registry											*/
/* Limitations	:   None															*/
/************************************************************************************/

int LoginToOracle(sql_context *ctx)
{

	//extern struct sqlca sqlca = {0};
	EXEC SQL BEGIN DECLARE SECTION;

	char connectstring[CONNECTSTRING_SIZE];
	char passwd[PASSWD_SIZE];
	char sleepTime[3];

	sql_context pcctx;
	EXEC SQL END DECLARE SECTION;
     

	READ_REG_GENERIC_T other_data;

	memset((char *)&other_data, 0, sizeof(READ_REG_GENERIC_T));

		
	/* Allocate memory for reading from registry	*/
	strcpy(other_data.value_name,"ConnectString");
	if (NULL == (other_data.value = (unsigned char *)malloc(CONNECTSTRING_SIZE)))
	{
		/* Log into Ulog */
		userlog("ora_connect: Malloc failed for connect string: errno %d", errno);
		return FAILURE;
	}
	

	/* Get the Oracle connect string				*/
	/* Using Service id 0 to get the default value	*/
	if(GMPC_GOOD != read_registry(0, NULL, &other_data))
	{
		free(other_data.value);
		userlog("ora_connect: Read registry failed for ConnectString",
			   errno);
		return FAILURE;
	}
	else
	{
		strcpy(connectstring, (const char *)other_data.value);
		free(other_data.value);
	}

	

	/* Malloc for Password	*/
	if(NULL == (other_data.value = (unsigned char *) malloc(PASSWD_SIZE)))
	{
		userlog("ora_connect: Unable to malloc for password: errno %d", errno);
		return FAILURE;
	}

	/* Get the Oracle password */
	/* Using Service id 0 to get the default value */
	strcpy(other_data.value_name,"Password");
	if(GMPC_GOOD != read_registry(0, NULL, &other_data))
	{
		free(other_data.value);	
		userlog("ora_connect: Read registry failed for Password");
		return FAILURE;
	}
	else
	{
		strcpy(passwd, (const char *)other_data.value);
		free(other_data.value);
	}



	/* Malloc for JPNSleepTime	*/
	if(NULL == (other_data.value = (unsigned char *) malloc(3)))
	{
		userlog("ora_connect: Unable to malloc for password: errno %d", errno);
		return FAILURE;
	}

	/* Get the Oracle password */
	/* Using Service id 0 to get the default value */
	strcpy(other_data.value_name,"JPNSleepTime");
	if(GMPC_GOOD != read_registry(0, NULL, &other_data))
	{
		free(other_data.value);	
		userlog("ora_connect: Read registry failed for JPNSleepTime");
		return FAILURE;
	}
	else
	{
		strcpy(sleepTime, (const char *)other_data.value);
		free(other_data.value);
	}

	gzSleepTime = atol((char *)sleepTime);


	EXEC SQL CONTEXT ALLOCATE :pcctx;

	*ctx = pcctx;

#ifdef DEBUG
	userlog("LoginToOracle: Using sql context %u", *ctx);
#endif

	EXEC SQL CONTEXT USE :pcctx;

	EXEC SQL CONNECT :connectstring IDENTIFIED BY :passwd;

	if (sqlca.sqlcode)
	{
		userlog("Not connected !!, %s", SQLMSG);
		return sqlca.sqlcode;
	}
	else 
	{
		//setcontex(Ctx);
		userlog("connected !!");
		return GMPC_GOOD;
	}
}

/************************************************************************************/
/* Function Name:	LogoutFromOracle()         										*/
/* Input		:	1. sql context							              			*/
/* Return Values:   GMPC_GOOD/oracle error											*/
/* Description	:	This function disconnects from oracle							*/
/* Limitations	:   None															*/
/************************************************************************************/

int LogoutFromOracle(void * ctx)
{


	//struct sqlca sqlca = {0};

	EXEC SQL BEGIN DECLARE SECTION;

	sql_context pcctx;
	EXEC SQL END DECLARE SECTION;


	pcctx = ctx;
	EXEC SQL CONTEXT USE:pcctx;

	EXEC SQL COMMIT WORK RELEASE;

	#ifdef DEBUG
		userlog("Using sql context %u", ctx);
	#endif

	if (sqlca.sqlcode)
	{
		userlog("Not disconnected !!, %s", SQLMSG);
		return sqlca.sqlcode;
	}
	
	EXEC SQL CONTEXT FREE :pcctx;


	if (sqlca.sqlcode)
	{
		userlog("Not freed !!, %s", SQLMSG);
		return sqlca.sqlcode;
	}
	else 
		userlog("termination ok !!");

	return GMPC_GOOD;

}

int FillRequest(JPN_STATUS_UPD_REQ_T *req,void * ctx)
{

    EXEC SQL BEGIN DECLARE SECTION;
  
	char hzApplid[APP_ID_SIZE]={0};
	char hzBranchCode[BRANCH_CODE_SIZE]={0};
	short hzBranchCode_ind = -1;
	char hzUserID[USER_ID_SIZE]={0};
	short hzUserID_ind = -1;
	char hzWSID[WS_ID_SIZE]={0};
	short hzWSID_ind = -1;
   	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN

	int ret_code=0,i=0;

	#ifdef DEBUG
		userlog("FillRequest: Entered this function");
	#endif

    EXEC SQL DECLARE C1 CURSOR FOR
		 SELECT APPLID 
		 FROM APPNT_JPN_STATUPD
		 WHERE UPDFLAG = 'N';
	
		if (SQLCODE != 0)  
        {
			g_bSlpState = true;
			userlog("FillRequest: CURSOR C1 Declaration Failed : %s", SQLMSG);
			return CALL_NOT_REQUIRED;
		}

	EXEC SQL OPEN C1;
		if (SQLCODE != 0)  
			{
				g_bSlpState = true;
				userlog("FillRequest: CURSOR C1 OPEN Failed : %s", SQLMSG);
				return CALL_NOT_REQUIRED;
			}

		#ifdef DEBUG
			userlog("FillRequest: After C1 cursor open");
		#endif

	while(1)
	{
		memset(req, 0, sizeof(JPN_STATUS_UPD_REQ_T));

		for(i=0;i<19;i++)
			hzApplid[i] = '\0';

		EXEC SQL FETCH C1 INTO :hzApplid;

		#if DEBUG
			userlog("FillRequest: After C1 fetch sqlca.sqlcode: %d",sqlca.sqlcode);	
		#endif

		if(sqlca.sqlcode == 1403) break;

		if (SQLCODE != 0)
		{
			EXEC SQL CLOSE  C1;  // close the cursor

			#ifdef DEBUG
				userlog(" FillRequest:: Error in fetching the C1 cursor : %d : %s", SQLCODE, SQLMSG);
			#endif
			/* Log the error */
			strcpy(prog_log.remarks,"FillRequest: Error in fetching the C1 cursor.");
			sprintf(excep_log.error_msg,"FillRequest: Error in fetching the C1 cursor: %d, %s ", SQLCODE, SQLMSG);
			excep_log.termination_flag = 'Y';
			excep_log.severity = FATAL;
			//log_error(ctx);
			return CALL_NOT_REQUIRED; //SQLCODE;
		}

		#ifdef DEBUG
			userlog("FillRequest: Application id : hzApplid : %s",hzApplid);
		#endif

		strcpy(req->applid,hzApplid);
	
		EXEC SQL SELECT USERID , WSID,BRANCHCODE INTO 
			:hzUserID:hzUserID_ind,
			:hzWSID:hzWSID_ind,
			:hzBranchCode:hzBranchCode_ind 
		   FROM APPLICATION 
		   WHERE APPLID = :hzApplid AND ROWNUM  = 1;

		if(hzBranchCode_ind == 0)
			strcpy(req->header.branch_code, hzBranchCode);
	
		if(hzUserID_ind == 0)
			strcpy(req->header.user_id ,hzUserID);
	
		if(hzWSID_ind == 0)
			strcpy(req->header.workstation_id , hzWSID);
	
		strcpy(req->header.application_id,hzApplid);

#if DEBUG
	userlog("FillRequest: req->header.branch_code:%s",req->header.branch_code);
	userlog("FillRequest: req->header.user_id:%s",req->header.user_id);
	userlog("FillRequest: req->header.workstation_id:%s",req->header.workstation_id);
	userlog("FillRequest: req->header.application_id:%s",req->header.application_id);
	userlog("FillRequest: req->applid:%s",req->applid);
	userlog(" ");
	userlog("FillRequest: Before Calling  Jpn_Status_Upd function");
#endif

	if(GMPC_GOOD != (ret_code = Jpn_Status_Upd(req,ctx)))
	{
		strcpy(prog_log.remarks,"FillRequest:  : Jpn_Status_Upd Function failed");
		strcpy(excep_log.error_msg,"FillRequest:  : Jpn_Status_Upd Function failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		//log_error(ctx);
		
		return ret_code;
	}

#if DEBUG
	userlog("FillRequest: After Calling  Jpn_Status_Upd function");
	userlog(" ");
#endif

	} // end of while

		EXEC SQL CLOSE  C1;  // close the cursor


    
		return CALL_NOT_REQUIRED;

}


/////////////////////////////////////////

int Jpn_Status_Upd(JPN_STATUS_UPD_REQ_T *pReq, void * ctx)
{    

	JPN_STATUS_UPD_REQ_T *req;
	JPN_STATUS_UPD_RESP_T *resp;	

	char curr_date_time[DATE_TIME_SIZE];
	int ret_val = 0;
	char program_id[PROG_ID_SIZE];
	long resp_len = 0;
	int msgid = 0;
	int txn_srno = 0;
	char req_flag = '\0';

	LI_P_HEADER_T hdr = {0}; // included this on 1/12/2006 to make it local from global declaration
	
	memset(&prog_log, 0, PROG_LOG_SIZE);
	memset(&excep_log, 0, APPL_EXCEP_LOG_SIZE);
	
	/* Initialize the variables used for logging	*/
	/* Get current date-time for logging			*/
	strcpy(curr_date_time, get_date_time());

	/* Assign request buffer	*/
	req = (JPN_STATUS_UPD_REQ_T *) pReq;


#if DEBUG	
	userlog(" ");
	userlog("Inside the Jpn_Status_Upd function");
	userlog(" ");
#endif
	/* Program access log variable */
	itoa(JPN_STATUS_UPD_ID, program_id, 10);
	strcpy(prog_log.program_id, program_id);
	strcpy(prog_log.user_id, req->header.user_id);
	strcpy(prog_log.workstation_id, req->header.workstation_id);
	strcpy(prog_log.branch_code, req->header.branch_code);
	strcpy(prog_log.access_start_time, curr_date_time);
	strcpy(prog_log.remarks, "");
	strcpy(prog_log.application_id, req->header.application_id);
	
	/* Application exception log variable */
	strcpy(excep_log.program_id, program_id);
	strcpy(excep_log.user_id, req->header.user_id); 	
	strcpy(excep_log.workstation_id, req->header.workstation_id);
	strcpy(excep_log.branch_code, req->header.branch_code);
	strcpy(excep_log.error_date, curr_date_time);
	strcpy(excep_log.error_msg, "");
	strcpy(excep_log.application_id, req->header.application_id); 	
	excep_log.severity = '\0';	
	excep_log.termination_flag = 'Y';	

	strcpy(prog_log.remarks,"JPN_STATUS_UPD: Initiated");
	
	
	//appl_kptno = (APPL_KPTNO_T *)(req+1); to be removed
	
	
	resp_len = sizeof(JPN_STATUS_UPD_RESP_T);

	/* Allocate response buffer	*/
	if(NULL == (resp = (JPN_STATUS_UPD_RESP_T *) malloc(resp_len)))
	{
		strcpy(prog_log.remarks,"JPN_STATUS_UPD : Memory allocation for response buffer failed");
		sprintf(excep_log.error_msg,"JPN_STATUS_UPD : ");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		//log_error(ctx);

		//tpreturn(TPFAIL, RESP_BUF_ERR, (char *) NULL, 0, 0);
		return RESP_BUF_ERR;
	}

	memset(resp, 0, sizeof(JPN_STATUS_UPD_RESP_T));

	#ifdef DEBUG
			userlog("JPN_STATUS_UPD : req->header.application_id:%s:",req->header.application_id);
			userlog("JPN_STATUS_UPD : req->header.branch_code:%s:", req->header.branch_code);
			userlog("JPN_STATUS_UPD : req->header.service_id:%d:", req->header.service_id);
			userlog("JPN_STATUS_UPD : req->header.user_id:%s:", req->header.user_id);
			userlog("JPN_STATUS_UPD : req->header.workstation_id:%s:", req->header.workstation_id);
			userlog("JPN_STATUS_UPD : req->applid:%s:",req->applid);			
	#endif

	resp->header = req->header;

	/* Begin a transaction	----> for data selection we don't require this <-----*/
	if(GMPC_GOOD != (ret_val = gscbbegin_trans(ctx)))
	{
		strcpy(prog_log.remarks,"JPN_STATUS_UPD : gscbbegin_trans failed");
		strcpy(excep_log.error_msg,"JPN_STATUS_UPD : gscbbegin_trans failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		//log_error(ctx);

		//tpreturn(TPSUCCESS, BEGIN_TRAN_ERROR, (char *) resp, resp_len, 0);
		//*pRespSize = resp_len;
		//*pResp = resp;
		return BEGIN_TRAN_ERROR;
	}

	#ifdef DEBUG
		userlog("JPN_STATUS_UPD :");		
	#endif
	
	
	req_flag = GMPC_STAT_UPD;
			
	/* Request for updation of card details */
					
	if (SUCCESS != (ret_val = update_gmpc_status_to_host(req, msgid, GMPC_STAT_UPD,hdr,ctx)))
	{
	#ifdef DEBUG
		userlog("JPN_STATUS_UPD : update_gmpc_status_to_host() failed with return code %d", ret_val);
	#endif
	
	//tpreturn(TPSUCCESS, ret_val, (char *)resp, sizeof (JPN_STATUS_UPD_RESP_T), 0);
		//*pRespSize = resp_len;
		//*pResp = resp;
		return ret_val;
	}


	#ifdef DEBUG
		userlog("JPN_STATUS_UPD : Completed Successfully");
	#endif

		strcpy(prog_log.remarks,"JPN_STATUS_UPD: Completed Successfully");
		//prog_access_log(ctx);

	/* Commit	*/
	if(GMPC_GOOD != (ret_val = gscbcommit_trans(ctx)))
	{
		strcpy(prog_log.remarks,"JPN_STATUS_UPD : Function gscbcommit_trans failed");
		strcpy(excep_log.error_msg,"JPN_STATUS_UPD : Function gscbcommit_trans failed");
		excep_log.termination_flag = 'Y';
		excep_log.severity = FATAL;
		//log_error(ctx);

		//tpreturn(TPSUCCESS, ret_val, (char *) resp, resp_len, 0);
		//*pRespSize = resp_len;
		//*pResp = resp;
		return ret_val;
	}
	

	#ifdef DEBUG
		userlog("JPN_STATUS_UPD :Service Completed");
	#endif

	//tpreturn(TPSUCCESS, GMPC_GOOD, (char *) resp, resp_len, 0);
		//*pRespSize = resp_len;
		//*pResp = resp;
		return GMPC_GOOD;
}


/***************************************************************/
/* Function Name:update_gmpc_status_to_host					   */
/* Description  :Gets applstat from APPLICATION table          */
/*				 And update the same to JPNHOST with other data*/
/* Input        :APPLID                      			       */   
/* Return Values:SUCCESS or SELECT_ERROR				       */
/***************************************************************/
int update_gmpc_status_to_host(JPN_STATUS_UPD_REQ_T *req, int msgid, char request_flag,LI_P_HEADER_T hdr,void * ctx)
{
	struct sqlca sqlca = {0}; // added on 13/03/06
	EXEC SQL BEGIN DECLARE SECTION;

	char  applid[20];
	char  appl_status = '\0';
	short appl_status_ind = -1;
	varchar  jpnstat[3]= {0};
	short jpnstat_ind = -1;
	int	  cardstat=0;
	short cardstat_ind = -1;

	char  lgmpcstat[4] = {0};
	
	int  status_copied=0;

	char kpt_no[KPT_SIZE] = {0};
	short kpt_no_ind = -1;
	char applstat = 0;
	short applstat_ind = -1;
	int cardversion = 0;
	short cardversion_ind = -1;
	char card_issue_dt[DATE_SIZE] = {0};
	short card_issue_dt_ind = -1;
	char collection_dt[DATE_SIZE] = {0};
	short collection_dt_ind = -1;
	char personalise_dt[DATE_SIZE] = {0};
	short personalise_dt_ind = -1;
	char appl_date[DATE_SIZE] = {0};
	short appl_date_ind = -1;
	char issue_branch[BRANCH_CODE_SIZE] = {0};
	short issue_branch_ind = -1;
	char license_idno[ID_SIZE] = {0};
	short license_idno_ind = -1;
	
	
	char  processind[PROCESS_IND_SIZE] = {0};
	varchar  appln_staff_id[USER_ID_SIZE] = {0}; // changed from char to varchar on 23/04/2007
	short appln_staff_id_ind = -1;
	char  issue_user_id[USER_ID_SIZE] = {0};
	short issue_user_id_ind = -1;
	int   card_stat = 0;
	char  txn_code[TRANSACTION_CODE_SIZE] = {0};
	short txn_code_ind = -1;
	int   txn_type = 0;
	short txn_type_ind = -1;
	char  appl_legacy_branch[LEGACY_BRANCH_CODE_SIZE] = {0};
	short appl_legacy_branch_ind = -1;
	char  issuing_legacy_branch[LEGACY_BRANCH_CODE_SIZE] = {0};
	short issuing_legacy_branch_ind = -1;
	int   lost_count = 0;
	short lost_count_ind = -1;
	//int   txn_count = 0;	
	
	char  legapplid[25];	
	short legapplid_ind = -1;

	char  tstamp[DATE_SIZE] = {0};
	short tstamp_ind = -1;

	varchar  ws_id[WS_ID_SIZE] = {0};
	short ws_id_ind = 0;

	/* Added for IJPN */
	varchar reason_desc[161] = {0};
	short reason_desc_ind = -1;
	varchar reject_code[9]={0};
	short reject_code_ind = -1;	
	char branch_code[7] = {0};
	/* End for IJPN */

	varchar capplstat[4] = {0};
	int scount=0;
	int prcode=0;
	int applpriority=0;
	short int applpriority_ind = -1;

	varchar  bundleid[BATCHNO_SIZE]= {0};  // included on 28/10/05 for IJPN
	short  bundleid_ind = -1;

	char ApplStat = 0;
	int k=0,sflag=0;
	char leg_header_date[DATE_TIME_SIZE] = {"\0"};
	short leg_header_date_ind = -1;

	char leg_msgid[MSG_ID_SIZE] = {0};

	sql_context pcCtx; // Modification for IJPN
	EXEC SQL END DECLARE SECTION;


	LI_UPDATE_GMPC_STAT_REQ_T lireq;

	int  ret_code=0,ret_val=0;
	unsigned char leg_msg_id[MSG_ID_SIZE];
	int  error_code = 0;
	
	int  reqstat = 0;
	char reqflag = '\0';

	char appl_ws_id[WS_ID_SIZE] = {"\0"};
	char appl_user_id[USER_ID_SIZE] = {"\0"};
	
	
	/* Added for IJPN */
	unsigned char pReplyMsg[LI_REPLY_MSG_SIZE];
	int iReplyMsgLen;
	char sErrMessage[LI_ERROR_MSG_SIZE]= {"\0"};
    /* End for IJPN */

	pcCtx = ctx; // Modification for IJPN
	EXEC SQL CONTEXT USE :pcCtx;// Modification for IJPN


	memset(&lireq,'\0',sizeof(LI_UPDATE_GMPC_STAT_REQ_T));
	//strcpy(leg_msgid, "\0");

	#ifdef DEBUG	
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : The applid from input buffer :%s", req->applid);		
	#endif

	strcpy(applid,req->applid);
		
	#ifdef DEBUG	
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : applid : %s ",applid);		
	#endif

/* Added this code on 19/09/05 for IJPN*/

		// check the ijpn_legacy_request for each application
		// if LEGREQFLAG  = 'C' AND   CHECKAGENCY = '1' then skip 
		// the status update to host and update the flag as Y in 
		// APPNT_JPN_STATUPD table, since these are issued applns.

		userlog(" Checking the IJPN_LEGACY_REQUEST for LEGREQFLAG = C for this application");
		scount = 0;
////Commented on 5th March '07
/*		EXEC SQL SELECT COUNT(*) INTO :scount 
			FROM IJPN_LEGACY_REQUEST
			WHERE (APPLID = :applid)
			AND   LEGREQFLAG  = 'C'
			AND   CHECKAGENCY = '1'
			AND   LEGREQSTAT  = 0;

		userlog("count and sqlcode : %d, %d",scount,sqlca.sqlcode);*/

//Added on 5th March '07
		EXEC SQL SELECT APPLSTAT 
			INTO :ApplStat
			FROM APPLICATION
			WHERE APPLID = :applid;

		if(SQLCODE == 0 && ApplStat == 'R')	//(scount > 0))
		{

		// No need to fire li_update_gmpc_stat_p,so update the UPDFLAG as 'Y'

		EXEC SQL UPDATE APPNT_JPN_STATUPD 
		SET UPDFLAG			= 'Y',
			LEGREQDATETIME  =  TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS')
			//LEGMSGID        = :leg_msgid				
		WHERE APPLID  = :applid;

			if (SQLCODE != 0)
			{
			#ifdef DEBUG
				userlog("update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed: %s", SQLMSG);
			#endif
				strcpy(prog_log.remarks,"update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD  failed ");
				sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				//log_error(ctx);	
				
				return UPDATE_ERROR;
			}

			userlog(" Skipping the execution of li_update_gmpc_stat_p, since LEGREQFLAG  = C in IJPN_LEGACY_REQUEST");
			userlog(" Exiting the service after updating the updflag = Y in APPNT_JPN_STATUPD");

			// added this code on 30/10/2006 to insert a record into APPNT_JPN_STATUPD_ARC 
			// to keep track

			EXEC SQL INSERT INTO APPNT_JPN_STATUPD_ARC(APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON) 
				SELECT APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON
				FROM APPNT_JPN_STATUPD WHERE APPLID = :applid;

			if(sqlca.sqlcode == 0)
			{
				EXEC SQL DELETE FROM APPNT_JPN_STATUPD
					WHERE APPLID = :applid;
			}

			return SUCCESS;

		}
		else
			userlog("Proceeding to fire li_update_gmpc_stat_p message since the LEGREQFLAG  is not C in IJPN_LEGACY_REQUEST");

/* end IJPN */

/* Added this code on 26/01/06, if legapplid is nuul then also no need to fire 
this message, just come out with out firing the 201250 message */

	legapplid[0] = '\0';
	EXEC SQL SELECT LEGAPPLID,APPLPRIORITY INTO :legapplid:legapplid_ind,
		:applpriority:applpriority_ind
		FROM  APPLICATION 
		WHERE APPLID = :applid;

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed : %s", SQLMSG); 
		#endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed");
			sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed  :%s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
					
			return SELECT_ERROR;
		}

	userlog("update_gmpc_status_to_host : legapplid : %s",legapplid);

	if((legapplid_ind == 0) && ((legapplid[0] != '\0') && (legapplid[0] != ' ')))
	{
		strcpy(lireq.appl_no, legapplid);
	}
	else
	{
		// No need to fire li_update_gmpc_stat_p,so update the UPDFLAG as 'Y'

		EXEC SQL UPDATE APPNT_JPN_STATUPD 
		SET UPDFLAG			= 'Y',
			LEGREQDATETIME  =  TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS')
			//LEGMSGID        = :leg_msgid				
		WHERE APPLID  = :applid;

			if (SQLCODE != 0)
			{
			#ifdef DEBUG
				userlog("update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed: %s", SQLMSG);
			#endif
				strcpy(prog_log.remarks,"update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD  failed ");
				sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				//log_error(ctx);	
				
				return UPDATE_ERROR;
			}

			userlog(" Skipping the execution of li_update_gmpc_stat_p, since legapplid is null");
			userlog(" Exiting the service after updating the updflag = Y in APPNT_JPN_STATUPD");

			// added this code on 30/10/2006 to insert a record into APPNT_JPN_STATUPD_ARC 
			// to keep track

			EXEC SQL INSERT INTO APPNT_JPN_STATUPD_ARC(APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON) 
				SELECT APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON
				FROM APPNT_JPN_STATUPD WHERE APPLID = :applid;

			if(sqlca.sqlcode == 0)
			{
				EXEC SQL DELETE FROM APPNT_JPN_STATUPD
					WHERE APPLID = :applid;
			}

			return SUCCESS;

	}
	
/* end IJPN */



		EXEC SQL SELECT KPTNO, TO_CHAR(APPLDATE,'DDMMYYYY'), USERID,
			TO_CHAR(TIMESTAMP,'DDMMYYYY')
			INTO :kpt_no:kpt_no_ind,
				 :appl_date:appl_date_ind,
				 :appln_staff_id:appln_staff_id_ind,
				 :tstamp:tstamp_ind
			FROM APPLICATION
			WHERE APPLID = :applid;

		setlen(appln_staff_id);
	    setnull(appln_staff_id);

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : kpt_no : %s", kpt_no); 
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : appl_date : %s", appl_date);
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : appln_staff_id : %s", appln_staff_id.arr);
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : tstamp : %s", tstamp);

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed : %s", SQLMSG); 
		#endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed");
			sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLICATION failed  :%s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
					
			return SELECT_ERROR;
		}


		EXEC SQL SELECT LTRIM(RTRIM(CAPPLSTAT)) INTO :capplstat 
			FROM APPNT_JPN_STATUPD
				WHERE APPLID = :applid;

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : capplstat : %s",capplstat.arr);

		setlen(capplstat);
		setnull(capplstat);

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : capplstat : %s",capplstat.arr);

				
		if (SQLCODE != 0) 
		{
		 #ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPNT_JPN_STATUPD failed : %s", SQLMSG); 
		 #endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPNT_JPN_STATUPD failed");
			sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPNT_JPN_STATUPD failed  :%s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
					
			return SELECT_ERROR;
		}


		
		// Added this query on 09/02/2010 to get the userid and timestamp from cardstatus 
		// for P3 and P4
		

		if ((strcmp((char *)capplstat.arr, "P3") == 0) || (strcmp((char *)capplstat.arr, "P4") == 0))
		{

			EXEC SQL SELECT TO_CHAR(TIMESTAMP,'DDMMYYYY'),USERID 
				INTO :tstamp:tstamp_ind, appln_staff_id:appln_staff_id_ind
				FROM CARD_STATUS 
				WHERE APPLID = :applid
				AND CARDVERSIONNO = ( SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS WHERE APPLID = :applid);

			if (SQLCODE != 0)
			{
			#ifdef DEBUG
				userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS failed : %s", SQLMSG); 
			#endif
				strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS failed");
				sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS failed  :%s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				//log_error(ctx);
						
				return SELECT_ERROR;
			}

			setlen(appln_staff_id);
			setnull(appln_staff_id);

		}

		// end of code adding 09/02/2010



//Added on 5th March '07
		if(ApplStat == 'T' && capplstat.arr[0] != 'T')	//(scount > 0))
		{

		// No need to fire li_update_gmpc_stat_p,so update the UPDFLAG as 'Y'

		EXEC SQL UPDATE APPNT_JPN_STATUPD 
		SET UPDFLAG			= 'Y',
			LEGREQDATETIME  =  TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS')
			//LEGMSGID        = :leg_msgid				
		WHERE APPLID  = :applid;

			if (SQLCODE != 0)
			{
			#ifdef DEBUG
				userlog("update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed: %s", SQLMSG);
			#endif
				strcpy(prog_log.remarks,"update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD  failed ");
				sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed : %s", SQLMSG);
				excep_log.termination_flag = YES;
				excep_log.severity = FATAL;

				//log_error(ctx);	
				
				return UPDATE_ERROR;
			}

			userlog(" Skipping the execution of li_update_gmpc_stat_p, since LEGREQFLAG  = C in IJPN_LEGACY_REQUEST");
			userlog(" Exiting the service after updating the updflag = Y in APPNT_JPN_STATUPD");

			// added this code on 30/10/2006 to insert a record into APPNT_JPN_STATUPD_ARC 
			// to keep track

			EXEC SQL INSERT INTO APPNT_JPN_STATUPD_ARC(APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON) 
				SELECT APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
				LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON
				FROM APPNT_JPN_STATUPD WHERE APPLID = :applid;

			if(sqlca.sqlcode == 0)
			{
				EXEC SQL DELETE FROM APPNT_JPN_STATUPD
					WHERE APPLID = :applid;
			}

			return SUCCESS;

		}
//End 5th March '07

	EXEC SQL SELECT LTRIM(RTRIM(JPNSTAT)) INTO :jpnstat:jpnstat_ind
		FROM APPLSTAT_REL_GMPCJPN
			WHERE GMPCSTAT = :capplstat; 

	userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : sqlca.sqlcode : %d",sqlca.sqlcode);
	userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : jpnstat : %s",jpnstat.arr);


	if (SQLCODE != 0) 
	{
	 #ifdef DEBUG
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : Select from APPLSTAT_REL_GMPCJPN failed : %s", SQLMSG); 
	 #endif
		strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLSTAT_REL_GMPCJPN failed");
		sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from APPLSTAT_REL_GMPCJPN failed  :%s", SQLMSG);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		//log_error(ctx);
					
		return SELECT_ERROR;
	}

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : jpnstat : %s",jpnstat.arr);

		setlen(capplstat);
		setnull(capplstat);

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : jpnstat : %s",jpnstat.arr);
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : length of jpnstat : %d",jpnstat.len);

		if(jpnstat.len == 1)
		{
			lireq.appln_stat  = jpnstat.arr[0];
			lireq.appln_stat2 = '\0';
		}
		else if(jpnstat.len > 1)
		{
			if(strncmp((char *)jpnstat.arr,"QE",2) == 0)
			{
				// if reasoncode is C0100 then send 'E' else send 'Q'
				prcode = 0;
				EXEC SQL SELECT COUNT(*) INTO :prcode
				FROM PROBL_RECORD WHERE APPLID = :applid
				AND PROBLREASONCODE = 'C0100'; 

				if (SQLCODE != 0) 
				{
				 #ifdef DEBUG
					userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from PROBL_RECORD failed : %s", SQLMSG); 
				 #endif
					strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from PROBL_RECORD failed");
					sprintf(excep_log.error_msg,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from PROBL_RECORD failed  :%s", SQLMSG);
					excep_log.termination_flag = YES;
					excep_log.severity = FATAL;

					//log_error(ctx);
					
					return SELECT_ERROR;
				}
				
				userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) PROBLREASONCODE C0100 count: %d",prcode); 

				
				if(prcode == 0)
					lireq.appln_stat  = jpnstat.arr[1];  //jpnstat.arr[0]; changed this on 23/8/06 req from vasanth
				else
					lireq.appln_stat  = jpnstat.arr[0];  //jpnstat.arr[1]; changed this on 23/8/06 req from vasanth

				lireq.appln_stat2 = '\0';
			}
			else
			{
			lireq.appln_stat  = jpnstat.arr[0];
			lireq.appln_stat2 = jpnstat.arr[1];
			}
		}

	#ifdef DEBUG
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : lireq.appln_stat : %c",lireq.appln_stat);
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : lireq.appln_stat2 : %c",lireq.appln_stat2);
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : capplstat.arr : %s",capplstat.arr);
	#endif


	/* If the message is to be sent at Issaunce, then only Card details */
	/* are to be sent, otherwise skip the selection						*/

	bundleid.arr[0] = '\0';

	if (request_flag == GMPC_STAT_UPD)
	{
		card_stat = ACTIVE;

	if((strcmp((char *)capplstat.arr,"T") != 0) && (strcmp((char *)capplstat.arr,"H") != 0))
	{

		EXEC SQL SELECT A.CARDVERSIONNO, TO_CHAR(A.CARDISSUEDATE, 'DDMMYYYY'),
				TO_CHAR(A.CARDPERSONALDATE, 'DDMMYYYY'), A.BATCHNO,
				TO_CHAR(B.CARDCOLLDATE, 'DDMMYYYY'), B.USERID
		  INTO :cardversion:cardversion_ind,
			   :card_issue_dt:card_issue_dt_ind,
			   :personalise_dt:personalise_dt_ind, :bundleid:bundleid_ind,
			   :collection_dt:collection_dt_ind, 
			   :issue_user_id
		 FROM CARD_STATUS A, APPLICATION B
		 WHERE A.APPLID = :applid
		 AND CARDVERSIONNO = (SELECT MAX(CARDVERSIONNO) FROM CARD_STATUS WHERE APPLID = :applid)		 
		 AND B.APPLID = A.APPLID;

		//AND A.CARDSTAT = :card_stat

			setlen(bundleid);
			setnull(bundleid);
	}
	else
	{	

		EXEC SQL SELECT TO_CHAR(CARDCOLLDATE, 'DDMMYYYY'), USERID
			INTO :collection_dt:collection_dt_ind,:issue_user_id
			FROM APPLICATION WHERE APPLID = :applid
			AND :capplstat IN ('T','H');
	}

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS/APPLICATION failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS/APPLICATION failed ");
			sprintf(excep_log.error_msg, "JPN_STATUS_UPD(update_gmpc_status_to_host) : Select from CARD_STATUS/APPLICATION failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
			
			return SELECT_ERROR;
		}
	}

	//strcpy(processind, APPL_REGISTER);

	EXEC SQL SELECT B.BRANCHCODEJPN
		INTO :appl_legacy_branch:appl_legacy_branch_ind
		FROM BRANCH_INFO B, APPLICATION A
		WHERE A.APPLID = :applid
		AND   B.BRANCHCODE = A.BRANCHCODE;			 

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting JPN Branch code from BRANCH_INFO failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting  JPN Branch code from BRANCH_INFO failed");
			sprintf(excep_log.error_msg, "JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting JPN Branch code from BRANCH_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
		
			return SELECT_ERROR;
		}  

	/* If the message is to be sent at Issaunce, then only Issaunce */
	/* details are to be sent, otherwise skip the selection			*/

	if (request_flag == GMPC_STAT_UPD)
	{
		strcpy(processind,ISSUE_CARD);
		strcpy(issue_branch, req->header.branch_code);
		issue_branch_ind = 0;

		EXEC SQL SELECT BRANCHCODEJPN
			 INTO :issuing_legacy_branch:issuing_legacy_branch_ind
			 FROM BRANCH_INFO
			 WHERE BRANCHCODE  = :issue_branch:issue_branch_ind;

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting Application details of Issuance failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting Application details of Issuance failed ");
			sprintf(excep_log.error_msg, "JPN_STATUS_UPD(update_gmpc_status_to_host) : Selecting Application details of Issuance failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
			
			return SELECT_ERROR;
		}

	}

	/* Copy the the values into the lireq structure */

	if (kpt_no_ind == 0)
	{
		strcpy(lireq.appnt_kpt, kpt_no); // kptno
	}

	#ifdef DEBUG
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : Before setnull(bundleid)");
	#endif



	#ifdef DEBUG
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : bundleid : %s",bundleid.arr);
	#endif

//	userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : bundleid : %c",bundleid.arr[0]);
//	userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : bundleid : %s",bundleid.arr);
	

	// if status is k only send this field to host
	if(strcmp((char *)jpnstat.arr, "K") == 0)
	{
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) jpnstat.arr for bundleid inside the loop : %s",jpnstat.arr);

		if((bundleid_ind == 0) && ((bundleid.arr[0] != '\0') && (bundleid.arr[0] != ' ')))
		{
			strcpy(lireq.bundleid,(char *)bundleid.arr);  // batchno
		}

		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : personalise_dt : %s",personalise_dt);

		if((personalise_dt_ind == 0) && ((personalise_dt[0] != '\0') && (personalise_dt[0] != ' ')))
		{
			strcpy(lireq.personlised_date,personalise_dt);
		}

	}
	else if(strcmp((char *)jpnstat.arr, "K1") == 0)
	{
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) jpnstat.arr for bundleid inside the loop : %s",jpnstat.arr);

		if((bundleid_ind == 0) && ((bundleid.arr[0] != '\0') && (bundleid.arr[0] != ' ')))
		{
			strcpy(lireq.bundleid,(char *)bundleid.arr);  // batchno
		}

	}
	else if((applpriority == 4) && (strcmp((char *)jpnstat.arr, "K1") == 0))
	{
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : personalise_dt : %s",personalise_dt);

		if((personalise_dt_ind == 0) && ((personalise_dt[0] != '\0') && (personalise_dt[0] != ' ')))
		{
			strcpy(lireq.personlised_date,personalise_dt);
		}

	}
	else if (strcmp((char *)jpnstat.arr, "PK") == 0)
	{
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) jpnstat.arr for bundleid inside the loop : %s",jpnstat.arr);		

		if((bundleid_ind == 0) && ((bundleid.arr[0] != '\0') && (bundleid.arr[0] != ' ')))
		{
			strcpy(lireq.bundleid,(char *)bundleid.arr);  // batchno
		}

	}
	else
		userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : status is not K or K1 or PK so bundleid or batchno is not sent to host");

	userlog("JPN_STATUS_UPD (update_gmpc_status_to_host) : lireq.bundleid : %s",lireq.bundleid);


	if (request_flag == GMPC_STAT_UPD)
	{
	  /* Check whether the application status is 'ISSUED' */

	  //if (applstat != ISSUED)
	  //{
	  //#ifdef DEBUG
	  //	userlog("upd_card_details : Invalid application status - %c", applstat);
	  //#endif
	  //	strcpy(prog_log.remarks,"upd_card_details : Invalid application status");
	  //	sprintf(excep_log.error_msg, "upd_card_details : Invalid application status - %c", applstat);
	  //	excep_log.termination_flag = YES;
	  //	excep_log.severity = FATAL;
	  //
	  //	log_error(ctx);
	  //			
	  //	return INVALID_APPL_STAT;		
	  //}
	  //else
	  //{
	  //	card_dtls.appln_stat = applstat; // appl_status
	  //}

	  /* The fields below are to be sent only for GMPC status update request */

	/* commeneted on 20/08/2005 as this is sent only for Issued by vasanth, used in JPN_UPDATE service 
	  if (cardversion_ind == 0)
	  {
		lireq.gmpc_version_no = cardversion; //gmpc_version_no
	  }

  	  if (personalise_dt_ind == 0)
	  {
		strcpy(lireq.gmpc_pc_date , personalise_dt); //gmpc_pc_date
	  }

	*/
	  if(issuing_legacy_branch_ind == 0)
	  {
		
		strcpy(lireq.appln_gsc_no , issuing_legacy_branch); // application brach code
	  }


	}
	
	/* commented as this is sent for only status X and Q only used in JPN_UPDATE service
	if (appl_date_ind == 0)
	{
		strcpy(lireq.appln_date , appl_date);
	}
	*/

	if(appl_legacy_branch_ind == 0)
	{
		
		strcpy(lireq.appln_gsc_no , appl_legacy_branch);
	}

	// added this code on 23/04/07 to trim the null spaces for appln_staff_id at the end
	//if (appln_staff_id_ind == 0)
	//{
	//	
	//	strcpy(lireq.appln_staff_id , appln_staff_id.arr);
	//}

	#ifdef DEBUG
		userlog("update_gmpc_status_to_host : appln_staff_id.arr before trimming : %s", appln_staff_id.arr);
	#endif

	if((appln_staff_id_ind == 0) && ((appln_staff_id.arr[0] != '\0') && (appln_staff_id.arr[0] != ' ')))
	{
		sflag=0;
		for(k=0;k<9;k++)
		{
			if(appln_staff_id.arr[k] == ' ')
			{
				if((appln_staff_id.arr[k] == ' ') && (sflag == 1))
				{
					sflag=0;
					break;
				}
				else
				{					
					sflag=1;
				}
			}
			lireq.appln_staff_id[k] = appln_staff_id.arr[k];
		}
		lireq.appln_staff_id[k-1] = '\0';
	}

	#ifdef DEBUG
		userlog("update_gmpc_status_to_host : appln_staff_id.arr after trimming : %s", appln_staff_id.arr);
		userlog("update_gmpc_status_to_host : lireq.appln_staff_id after trimming : %s", lireq.appln_staff_id);
	#endif

	if(tstamp_ind == 0)
		strcpy(lireq.appln_date , tstamp);

	userlog("applpriority :%d:",applpriority);
	userlog("jpnstat.arr :%s:",jpnstat.arr);

	// this condition and  code is added on 30/01/07
	if((applpriority == 4) && (strcmp((char *)jpnstat.arr, "K1") == 0))
	{
		userlog("Inside the loop of service");
		lireq.applpriority = applpriority;
	}



		/* Populate the header to be sent to legacy	*/

		strcpy(branch_code, req->header.branch_code);

		/* legacy branch code */
		EXEC SQL SELECT BRANCHCODEJPN
			INTO :appl_legacy_branch:appl_legacy_branch_ind
			FROM BRANCH_INFO 
			WHERE BRANCHCODE = :branch_code;
	
		userlog("update_gmpc_status_to_host : appl_legacy_branch : %s",appl_legacy_branch);
		userlog("update_gmpc_status_to_host : appl_legacy_branch_ind : %d",appl_legacy_branch_ind);
		 

		if (SQLCODE != 0)
		{
			#ifdef DEBUG
				userlog("update_gmpc_status_to_host : Selecting JPN Branch code from BRANCH_INFO failed : %s", SQLMSG);
			#endif
			strcpy(prog_log.remarks,"update_gmpc_status_to_host : Selecting  JPN Branch code from BRANCH_INFO failed");
			sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Selecting JPN Branch code from BRANCH_INFO failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);
		
			return SELECT_ERROR;
		}  

		if(appl_legacy_branch_ind == 0)
			strcpy(hdr.gsc_no,appl_legacy_branch);

	/* get the legacy transaction date and time */
	
	EXEC SQL SELECT TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS') 
			INTO :leg_header_date:leg_header_date_ind 
			FROM DUAL;

	userlog("leg_header_date : %s",leg_header_date);
	userlog("leg_header_date_ind : %d",leg_header_date_ind);

	if(leg_header_date_ind == 0)
	{
		strncpy(hdr.trans_date, leg_header_date, 8);
		hdr.trans_date[DATE_SIZE - 1] = '\0';

		strncpy(hdr.trans_time, leg_header_date + 9, 6);
		hdr.trans_time[TIME_SIZE - 1] = '\0';
	}

	strcpy(hdr.user_id, req->header.user_id);


	EXEC SQL SELECT LITXNWSID.NEXTVAL 	INTO :ws_id:ws_id_ind
	FROM  DUAL;

	setlen(ws_id);
	setnull(ws_id);
	
	//strcpy(hdr.workstation_id, ws_id.arr);

	#ifdef DEBUG
		userlog("update_gmpc_status_to_host : ws_id.arr before trimming : %s", ws_id.arr);
	#endif

	if((ws_id_ind == 0) && ((ws_id.arr[0] != '\0') && (ws_id.arr[0] != ' ')))
	{
		sflag=0;
		for(k=0;k<16;k++)
		{
			if(ws_id.arr[k] == ' ')
			{
				if((ws_id.arr[k] == ' ') && (sflag == 1))
				{
					sflag=0;
					break;
				}
				else
				{					
					sflag=1;
				}
			}
			hdr.workstation_id[k] = ws_id.arr[k];
		}
		hdr.workstation_id[k-1] = '\0';
	}

	#ifdef DEBUG
		userlog("update_gmpc_status_to_host : ws_id.arr after trimming : %s", ws_id.arr);
		userlog("update_gmpc_status_to_host : hdr.workstation_id after trimming : %s", hdr.workstation_id);
	#endif


#ifdef DEBUG
	userlog("update_gmpc_status_to_host : KPT - %s", lireq.appnt_kpt);
	userlog("update_gmpc_status_to_host : Appl status - %c", lireq.appln_stat);
	userlog("update_gmpc_status_to_host : Appl date - %s", lireq.appln_date);
	userlog("update_gmpc_status_to_host : Branch code - %s", lireq.appln_gsc_no);
	userlog("update_gmpc_status_to_host : User id - %s", lireq.appln_staff_id);	
	userlog("update_gmpc_status_to_host : GMPC PC date - %s", lireq.gmpc_pc_date);		
	userlog("update_gmpc_status_to_host : Appl status2 - %c", lireq.appln_stat2);
	userlog("update_gmpc_status_to_host : Card version no - %d", lireq.gmpc_version_no);
	userlog("update_gmpc_status_to_host : legapplid - %s", lireq.appl_no);
	userlog("update_gmpc_status_to_host : personlised_date - %s", lireq.personlised_date);
	userlog("update_gmpc_status_to_host : ws_id - %s", ws_id.arr);
	userlog("update_gmpc_status_to_host : hdr.workstation_id - %s", hdr.workstation_id);
	//userlog("update_gmpc_status_to_host : lireq.bundleid - %s", lireq.bundleid);
#endif


	/* Put the request */
	sErrMessage[0] = '\0';
	if ((ret_code = li_update_gmpc_stat_p(hdr, lireq, leg_msg_id, &error_code,pReplyMsg, &iReplyMsgLen, sErrMessage)) != GMPC_GOOD)
	{
	
	#ifdef DEBUG
		userlog("update_gmpc_status_to_host : Unable to put the GMPC status update request : %d", error_code);
		userlog("update_gmpc_status_to_host : Unable to put the GMPC status update request : %s", sErrMessage);
	#endif
		strcpy(prog_log.remarks,"update_gmpc_status_to_host : Unable to put the GMPC status update request");
		sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Unable to put the GMPC status update request : Error code - %d", error_code);
		excep_log.termination_flag = YES;
		excep_log.severity = FATAL;

		//log_error(ctx);

		if(leg_msg_id != NULL && strlen((char *)leg_msg_id) > 20)
			strcpy(leg_msgid, (char *)leg_msg_id);

		reject_code.arr[0] = '\0';
		reason_desc.arr[0] = '\0';

		if((sErrMessage[0] != '\0') && (sErrMessage[0] != ' '))
		{
		strncpy((char *)reject_code.arr,sErrMessage,8);
		setlen(reject_code);

		strcpy((char *)reason_desc.arr,sErrMessage);
		setlen(reason_desc);
		}

		userlog("reject_code : %s",reject_code.arr);
		if(reject_code.arr[0] != '\0')
			reject_code_ind = 0;
		else 
			reject_code_ind = -1;
	

		userlog("reason_desc : %s",reason_desc.arr);
		if(reason_desc.arr[0] != '\0')
			reason_desc_ind = 0;
		else
			reason_desc_ind = -1;

		
		EXEC SQL UPDATE APPNT_JPN_STATUPD 
		SET UPDFLAG			= 'F',
			LEGREQDATETIME  =  TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'),
			LEGMSGID        = :leg_msgid,
			LEGREJCODE      = :reject_code:reject_code_ind,
			LEGREJREASON    = :reason_desc:reason_desc_ind		
		WHERE APPLID  = :applid;
		

		if (SQLCODE != 0 && SQLCODE != 1403)
		{
		#ifdef DEBUG
			userlog("update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD with LEGREJCODE and LEGREJREASON failed : %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD with LEGREJCODE and LEGREJREASON failed ");
			sprintf(excep_log.error_msg, "update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD failed with LEGREJCODE and LEGREJREASON : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);				
		}

	/* Commit the changes here*/
	if(GMPC_GOOD != (ret_val = gscbcommit_trans(ctx)))
	{
		#ifdef DEBUG
			userlog("update_gmpc_status_to_host : Function gscbcommit_trans failed");
		#endif		

	}

		#ifdef DEBUG
			userlog("update_gmpc_status_to_host : Updated APPNT_JPN_STATUPD with LEGREJCODE and LEGREJREASON");
		#endif
			
		return error_code;

	}
		
	/* Legacy function was successfull so update the flag in APPNT_JPN_STATUPD */

	strcpy(leg_msgid, (char *)leg_msg_id);

	
	if(ret_code == GMPC_GOOD)
	{
		//li_update_gmpc_stat_p is successful so update the table

		EXEC SQL UPDATE APPNT_JPN_STATUPD 
		SET UPDFLAG			= 'Y',
			LEGREQDATETIME  =  TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY HH24MISS'),'DDMMYYYY HH24MISS'),
			LEGMSGID        = :leg_msgid,
			LEGREJCODE      =  NULL,
			LEGREJREASON    =  NULL			
		WHERE APPLID  = :applid;

		if (SQLCODE != 0)
		{
		#ifdef DEBUG
			userlog("update_gmpc_status_to_host : Updateing APPNT_JPN_STATUPD after the successful li_put failed: %s", SQLMSG);
		#endif
			strcpy(prog_log.remarks,"update_mykid_issuance : Updateing APPNT_JPN_STATUPD after the successful li_put failed ");
			sprintf(excep_log.error_msg, "update_mykid_issuance : Updateing APPNT_JPN_STATUPD failed after the successful li_put failed : %s", SQLMSG);
			excep_log.termination_flag = YES;
			excep_log.severity = FATAL;

			//log_error(ctx);	
			
			return UPDATE_ERROR;
		}

		// added this code on 30/10/2006 to insert a record into APPNT_JPN_STATUPD_ARC 
		// to keep track

		EXEC SQL INSERT INTO APPNT_JPN_STATUPD_ARC(APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
			LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON) 
			SELECT APPLID, CAPPLSTAT, TIMESTAMP, UPDFLAG, 
			LEGREQDATETIME, LEGMSGID, LEGREJCODE, LEGREJREASON
			FROM APPNT_JPN_STATUPD WHERE APPLID = :applid;

		if(sqlca.sqlcode == 0)
		{
			EXEC SQL DELETE FROM APPNT_JPN_STATUPD
				WHERE APPLID = :applid;
		}

	}

	return SUCCESS;

}

